<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>[笔记]深入C语言和程序运行原理（更新中） - PPD&#39;s blog</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="PPD" />
  <meta name="description" content="第零讲 课前热身 数据量单位 位（bit）： 是最小存储单位，每个位可以存一个二进制码值得 0 或 1 字节（byte）： 通常是由八个位组成的一个存储单元，" />

  <meta name="keywords" content="PPD, blog" />






<meta name="generator" content="Hugo 0.86.0-DEV" />


<link rel="canonical" href="https://ppd0705.github.io/post/learn_c/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.b3a8813c06e6d785beba22bf8264e174fa2cb3a396b22f9ba24e2c00c18aaf7f.css" integrity="sha256-s6iBPAbm14W&#43;uiK/gmThdPoss6OWsi&#43;bok4sAMGKr38=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="[笔记]深入C语言和程序运行原理（更新中）" />
<meta property="og:description" content="第零讲 课前热身 数据量单位 位（bit）： 是最小存储单位，每个位可以存一个二进制码值得 0 或 1 字节（byte）： 通常是由八个位组成的一个存储单元，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ppd0705.github.io/post/learn_c/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-31T17:04:50+08:00" />
<meta property="article:modified_time" content="2022-04-17T10:48:50+08:00" />

<meta itemprop="name" content="[笔记]深入C语言和程序运行原理（更新中）">
<meta itemprop="description" content="第零讲 课前热身 数据量单位 位（bit）： 是最小存储单位，每个位可以存一个二进制码值得 0 或 1 字节（byte）： 通常是由八个位组成的一个存储单元，"><meta itemprop="datePublished" content="2022-01-31T17:04:50+08:00" />
<meta itemprop="dateModified" content="2022-04-17T10:48:50+08:00" />
<meta itemprop="wordCount" content="14075">
<meta itemprop="keywords" content="C," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[笔记]深入C语言和程序运行原理（更新中）"/>
<meta name="twitter:description" content="第零讲 课前热身 数据量单位 位（bit）： 是最小存储单位，每个位可以存一个二进制码值得 0 或 1 字节（byte）： 通常是由八个位组成的一个存储单元，"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">PPD's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/about">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      PPD's blog
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/about">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">[笔记]深入C语言和程序运行原理（更新中）</h1>
      
      <div class="post-meta">
        <time datetime="2022-01-31" class="post-time">
          2022-01-31
        </time>
        <div class="post-category">
            <a href="https://ppd0705.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"> 计算机 </a>
            
          </div>
        <span class="more-meta"> 14075 words </span>
          <span class="more-meta"> 29 min read </span>

        
        
          <span id="busuanzi_container_page_pv">
            | 阅读 <span id="busuanzi_value_page_pv"></span>
          </span>
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#第零讲-课前热身">第零讲 课前热身</a>
      <ul>
        <li><a href="#数据量单位">数据量单位</a></li>
        <li><a href="#汇编语言">汇编语言</a></li>
        <li><a href="#寄存器">寄存器</a></li>
      </ul>
    </li>
    <li><a href="#第一讲-一个c程序的完整生命周期">第一讲 一个C程序的完整生命周期</a>
      <ul>
        <li><a href="#c核心语法">C核心语法</a>
          <ul>
            <li><a href="#入口函数">入口函数</a></li>
            <li><a href="#数组">数组</a></li>
            <li><a href="#结果体和联合体">结果体和联合体</a></li>
            <li><a href="#控制语句">控制语句</a></li>
            <li><a href="#指针">指针</a></li>
            <li><a href="#宏">宏</a></li>
            <li><a href="#断言">断言</a></li>
            <li><a href="#函数内联">函数内联</a></li>
          </ul>
        </li>
        <li><a href="#c-语言编程范式">C 语言编程范式</a></li>
        <li><a href="#编译和运行">编译和运行</a></li>
      </ul>
    </li>
    <li><a href="#第二讲-数据和量值">第二讲 数据和量值</a>
      <ul>
        <li><a href="#量值">量值</a>
          <ul>
            <li><a href="#变量">变量</a></li>
            <li><a href="#常量">常量</a></li>
          </ul>
        </li>
        <li><a href="#数据的存储形式">数据的存储形式</a>
          <ul>
            <li><a href="#补码">补码</a></li>
            <li><a href="#ieee-754">IEEE-754</a></li>
          </ul>
        </li>
        <li><a href="#数据的存储位置">数据的存储位置</a></li>
      </ul>
    </li>
    <li><a href="#第三讲-运算符">第三讲 运算符</a>
      <ul>
        <li><a href="#运算符分类">运算符分类</a></li>
        <li><a href="#算数关系为赋值运算">算数、关系、为、赋值运算</a></li>
        <li><a href="#逻辑运算符">逻辑运算符</a></li>
        <li><a href="#成员访问运算符">成员访问运算符</a></li>
        <li><a href="#其他运算符">其他运算符</a></li>
      </ul>
    </li>
    <li><a href="#第四讲-控制逻辑">第四讲 控制逻辑</a>
      <ul>
        <li><a href="#表达式">表达式</a></li>
        <li><a href="#语句">语句</a>
          <ul>
            <li><a href="#选择语句">选择语句</a></li>
            <li><a href="#迭代语句">迭代语句</a></li>
            <li><a href="#跳转语句">跳转语句</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第五讲-函数调用上">第五讲 函数调用（上）</a>
      <ul>
        <li><a href="#快速回顾">快速回顾</a></li>
        <li><a href="#c-函数的调用约定">C 函数的调用约定</a></li>
        <li><a href="#参数约定">参数约定</a></li>
        <li><a href="#返回值传递">返回值传递</a></li>
        <li><a href="#寄存器使用">寄存器使用</a></li>
        <li><a href="#堆栈清理">堆栈清理</a></li>
        <li><a href="#其他约定">其他约定</a></li>
        <li><a href="#保存函数调用信息的栈帧">保存函数调用信息的栈帧</a></li>
      </ul>
    </li>
    <li><a href="#第六讲-函数调用下">第六讲 函数调用（下）</a>
      <ul>
        <li><a href="#函数参数求值顺序">函数参数求值顺序</a></li>
        <li><a href="#尾递归调用优化tail-call-optimization">尾递归调用优化（tail-call optimization）</a></li>
        <li><a href="#kr-函数声明">K&amp;R 函数声明</a></li>
      </ul>
    </li>
    <li><a href="#第七讲-枚举结构和联合是如何实现的">第七讲 枚举、结构和联合是如何实现的？</a>
      <ul>
        <li><a href="#枚举-enumeration">枚举 Enumeration</a></li>
        <li><a href="#结构-struct">结构 Struct</a>
          <ul>
            <li><a href="#内存数据对齐">内存数据对齐</a></li>
            <li><a href="#填充字节">填充字节</a></li>
          </ul>
        </li>
        <li><a href="#联合-union">联合 Union</a></li>
      </ul>
    </li>
    <li><a href="#第八讲-指针是如何灵活使用内存的">第八讲 指针是如何灵活使用内存的</a>
      <ul>
        <li><a href="#指针的基本使用">指针的基本使用</a></li>
        <li><a href="#指针和数组">指针和数组</a></li>
        <li><a href="#指针的其他运算">指针的其他运算</a>
          <ul>
            <li><a href="#算术运算">算术运算</a></li>
            <li><a href="#关系运算">关系运算</a></li>
          </ul>
        </li>
        <li><a href="#堆内存指针">堆内存指针</a></li>
      </ul>
    </li>
    <li><a href="#第九讲-预处理器">第九讲 预处理器</a>
      <ul>
        <li><a href="#预处理流程">预处理流程</a></li>
        <li><a href="#宏函数常用技巧">宏函数常用技巧</a>
          <ul>
            <li><a href="#为返回值添加括号">为返回值添加括号</a></li>
            <li><a href="#为参数添加括号">为参数添加括号</a></li>
            <li><a href="#警惕多次副作用">警惕多次副作用</a></li>
            <li><a href="#定义完备的多语句宏函数">定义完备的多语句宏函数</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第十讲-字符字符串与数学计算">第十讲 字符、字符串与数学计算</a>
      <ul>
        <li><a href="#字符和字符串">字符和字符串</a>
          <ul>
            <li><a href="#字符">字符</a></li>
            <li><a href="#字符串">字符串</a></li>
          </ul>
        </li>
        <li><a href="#字符库函数">字符库函数</a>
          <ul>
            <li><a href="#统计字符串长度">统计字符串长度</a></li>
            <li><a href="#拼接字符串">拼接字符串</a></li>
            <li><a href="#拷贝字符串">拷贝字符串</a></li>
            <li><a href="#格式化字符串">格式化字符串</a></li>
            <li><a href="#字符的判断和转换">字符的判断和转换</a></li>
          </ul>
        </li>
        <li><a href="#数学运算库函数">数学运算库函数</a></li>
      </ul>
    </li>
    <li><a href="#第十一讲-io-标准库">第十一讲 IO 标准库</a>
      <ul>
        <li><a href="#基本使用">基本使用</a></li>
        <li><a href="#接口级别">接口级别</a></li>
        <li><a href="#低级-io-背后的系统调用">低级 IO 背后的系统调用</a></li>
      </ul>
    </li>
    <li><a href="#第十二讲-非本地跳转和可变参数实现原理">第十二讲 非本地跳转和可变参数实现原理</a>
      <ul>
        <li><a href="#本地跳转">本地跳转</a></li>
        <li><a href="#setjmp-和-longjmp-函数">setjmp 和 longjmp 函数</a>
          <ul>
            <li><a href="#运作原理">运作原理</a></li>
            <li><a href="#自定义实现">自定义实现</a></li>
          </ul>
        </li>
        <li><a href="#可变参数">可变参数</a>
          <ul>
            <li><a href="#基本使用-1">基本使用</a></li>
            <li><a href="#运作原理-1">运作原理</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第十三讲-c-并发编程">第十三讲 C 并发编程</a>
      <ul>
        <li><a href="#进程-vs-线程">进程 vs 线程</a></li>
        <li><a href="#线程的基本控制">线程的基本控制</a></li>
        <li><a href="#数据竞争">数据竞争</a></li>
        <li><a href="#竞态条件">竞态条件</a></li>
        <li><a href="#指令重排">指令重排</a></li>
      </ul>
    </li>
    <li><a href="#第十四讲-如何协调线程">第十四讲 如何协调线程</a>
      <ul>
        <li><a href="#互斥量">互斥量</a></li>
        <li><a href="#原子操作">原子操作</a></li>
        <li><a href="#条件变量">条件变量</a></li>
        <li><a href="#本地变量">本地变量</a></li>
      </ul>
    </li>
    <li><a href="#第十五讲-信号">第十五讲 信号</a>
      <ul>
        <li><a href="#什么是信号">什么是信号</a></li>
        <li><a href="#信号与软中断">信号与软中断</a></li>
        <li><a href="#c-代码样例">C 代码样例</a></li>
        <li><a href="#可重入函数">可重入函数</a></li>
        <li><a href="#多线程信号处理">多线程信号处理</a></li>
      </ul>
    </li>
    <li><a href="#第十六讲-日期时间与实用函数">第十六讲 日期、时间与实用函数</a>
      <ul>
        <li><a href="#日期与时间">日期与时间</a>
          <ul>
            <li><a href="#日历时间">日历时间</a></li>
            <li><a href="#处理器时间">处理器时间</a></li>
            <li><a href="#字符串到数值的转换">字符串到数值的转换</a></li>
            <li><a href="#生成随机数">生成随机数</a></li>
            <li><a href="#动态内存管理">动态内存管理</a></li>
            <li><a href="#进程控制">进程控制</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第十七讲-断言错误处理和对齐">第十七讲 断言、错误处理和对齐</a>
      <ul>
        <li><a href="#断言-1">断言</a></li>
        <li><a href="#错误处理">错误处理</a></li>
        <li><a href="#对齐">对齐</a></li>
      </ul>
    </li>
    <li><a href="#第十八讲-极致优化上">第十八讲 极致优化（上）</a>
      <ul>
        <li><a href="#高速缓存">高速缓存</a></li>
        <li><a href="#内联">内联</a></li>
        <li><a href="#restrict关键字">restrict关键字</a></li>
        <li><a href="#消除不需要的内存引用">消除不需要的内存引用</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h1 id="第零讲-课前热身">第零讲 课前热身</h1>
<h2 id="数据量单位">数据量单位</h2>
<p>位（bit）： 是最小存储单位，每个位可以存一个二进制码值得 0 或 1
字节（byte）： 通常是由八个位组成的一个存储单元，是计算机最小的可寻址单位
位（word）：是处理器使用的自然数据单位，处理器单个指令可以操作的最大的内存块
一般为一个字节大小</p>
<h2 id="汇编语言">汇编语言</h2>
<p>汇编语言（Assembly Language）是一种低级编程语言，和 CPU 架构相关。</p>
<p>汇编语言使用助记符（Mnemonic）来表示每个低级的机器指令，不同的汇编指令可以使用不同的参数形式，以 mov 指令举例，有如下三种形式：</p>
<ul>
<li>mov r/m, r</li>
<li>mov r, r/m</li>
<li>mov r/m, imm</li>
</ul>
<p>指令参数中，r 表示 寄存器（register），m 表示内存（memory），imm 表示立即数（immediate）。
指令<code>mov ebx 1</code>的含义是将立即数 1 存到寄存器 ebx 中。
在x86指令集中，受限于 CPU 实现的复杂的，不存在将两个内存地址同时作为 src 和 dest 参数的指令。</p>
<p>指令<code>mov ebx 1</code>对应的机器码为 <code>bb 01 00 00 00</code>
机器码由 OpCode 和 Immediata Data 两部分组成，OpCode 占用一个字节，mov 对应的指令是 0xb8，寄存器对应阈值为 0x3， 组合在一起即为 0xbb；由于 mov 传送 32 位数，所以立即数单独占用 4 个字节 （使用小端序）</p>
<h2 id="寄存器">寄存器</h2>
<p>寄存器可以简单理解为 CPU 提供的一组由位于芯片上的高速存储器硬件，拥有最快的数据访问速度和最低的延迟</p>
<p>寄存器通常分为如下几类：</p>
<ul>
<li>统一寄存器：一般存放程序运行过程中产生的临时数据</li>
<li>状态寄存器：一般存放之间执行结果相关的状态信息，如指令是否引起进位等</li>
<li>系统寄存器：一般由操作系统使用，存放中断、CPU模式等信息</li>
</ul>
<p>x86-64 架构中定义了 16 个通用寄存器，每个寄存器可以存放4个指令字（每个指令字16字节）</p>
<p>在汇编代码中，可以使用每个寄存器的不同别名来访问对应的低 8 位，低 16 位，低 32 位，以及完整的 64 位数据</p>
<p><img src="/image/learn_c/0_1.jpg" alt="register_alias"></p>
<p>需要注意的是当重写寄存器的低32位数据时，高32位数据会被置零，可以使用如下代码进行对比。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">register</span> <span class="kt">long</span> <span class="n">num</span> <span class="k">asm</span><span class="p">(</span><span class="s">&#34;rax&#34;</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x100000000</span><span class="p">;</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&#34;movl $0x1, %eax&#34;</span><span class="p">);</span>
  <span class="c1">// asm(&#34;movw $0x1, %ax&#34;);
</span><span class="c1"></span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="第一讲-一个c程序的完整生命周期">第一讲 一个C程序的完整生命周期</h1>
<h2 id="c核心语法">C核心语法</h2>
<p>实例程序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt; </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define BOOL_TRUE 1  </span><span class="c1">// 定义用到的宏常量与宏函数；
</span><span class="c1"></span><span class="cp">#define BOOL_FALSE 0
</span><span class="cp">#define typename(x) _Generic((x), \
</span><span class="cp">  unsigned short: &#34;unsigned short int&#34;, \
</span><span class="cp">  unsigned long: &#34;unsigned long int&#34;, \
</span><span class="cp">  default: &#34;unknown&#34;)
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">Host</span><span class="p">,</span> <span class="n">IP</span> <span class="p">}</span> <span class="n">IP_ADDR_TYPE</span><span class="p">;</span>  <span class="c1">// 定义枚举类型 IP_ADDR_TYPE，用于表示联合中生效的字段；
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>  <span class="c1">// 定义结构 CONN；
</span><span class="c1"></span>  <span class="n">size_t</span> <span class="n">id</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">closed</span><span class="p">;</span>
  <span class="n">IP_ADDR_TYPE</span> <span class="n">addr_type</span><span class="p">;</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">host_name</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">ip</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
  <span class="p">};</span>
<span class="p">}</span> <span class="n">CONN</span><span class="p">;</span>

<span class="kr">inline</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">findAddr</span><span class="p">(</span><span class="k">const</span> <span class="n">CONN</span><span class="o">*</span> <span class="n">pip</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 定义函数 findAddr，用于打印 CONN 对象的信息；
</span><span class="c1"></span>  <span class="n">assert</span><span class="p">(</span><span class="n">pip</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// 运行时断言，判断传入的 CONN 指针是否有效；
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="n">addr_type</span> <span class="o">==</span> <span class="n">Host</span> <span class="o">?</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="nl">host_name</span> <span class="p">:</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>  <span class="c1">// 入口函数；
</span><span class="c1"></span>  <span class="n">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">CONN</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0x400</span><span class="p">,</span> <span class="s">&#34;the size of CONN object exceeds limit.&#34;</span><span class="p">);</span>  <span class="c1">// 静态断言，判断 CONN 对象的大小是否符合要求；
</span><span class="c1"></span>  <span class="k">const</span> <span class="n">CONN</span> <span class="n">conns</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>  <span class="c1">// 构造一个数组，包含三个 CONN 对象；
</span><span class="c1"></span>    <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="n">BOOL_TRUE</span><span class="p">,</span> <span class="n">IP</span><span class="p">,</span> <span class="p">{</span> <span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="s">&#34;127.0.0.1&#34;</span> <span class="p">}</span> <span class="p">},</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8080</span><span class="p">,</span> <span class="n">BOOL_FALSE</span><span class="p">,</span> <span class="n">IP</span><span class="p">,</span> <span class="p">{</span> <span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="s">&#34;192.168.1.1&#34;</span> <span class="p">}</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8088</span><span class="p">,</span> <span class="n">BOOL_FALSE</span><span class="p">,</span> <span class="n">Host</span><span class="p">,</span> <span class="p">{</span> <span class="p">.</span><span class="n">host_name</span> <span class="o">=</span> <span class="s">&#34;http://localhost/&#34;</span> <span class="p">}</span> <span class="p">}</span>
  <span class="p">};</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">conns</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONN</span><span class="p">));</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 遍历上述 CONN 数组，并打印其中的内容；
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span>
      <span class="s">&#34;Port: %d</span><span class="se">\n</span><span class="s">&#34;</span>
      <span class="s">&#34;Host/Addr: %s</span><span class="se">\n</span><span class="s">&#34;</span>
      <span class="s">&#34;Internal type of `id` is: %s</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">,</span>
      <span class="n">conns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">port</span><span class="p">,</span>
      <span class="n">findAddr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conns</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
      <span class="kr">typename</span><span class="p">(</span><span class="n">conns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">)</span>
    <span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="入口函数">入口函数</h3>
<p>使用 main 函数作为入口函数，返回值为 0 表示成功。</p>
<h3 id="数组">数组</h3>
<p>conns 即为数组</p>
<h3 id="结果体和联合体">结果体和联合体</h3>
<p>结果体中所有定义的字段对应内存连续排列
联合体中同时只有一个字段生效，分配的内存为最大字段占用内存</p>
<h3 id="控制语句">控制语句</h3>
<h3 id="指针">指针</h3>
<h3 id="宏">宏</h3>
<p>宏函数 typename 使用了 C11标准引入的 _Generic 关键字</p>
<h3 id="断言">断言</h3>
<p>断言分为静态断言和动态断言，静态断言在代码编译时进行检查</p>
<h3 id="函数内联">函数内联</h3>
<p>使用 inline 内联关键字，可以建议编译器将该函数的内部逻辑直接替换到函数的
调用位置处，以减少函数调用开销提升性能</p>
<h2 id="c-语言编程范式">C 语言编程范式</h2>
<p>C 语言属于命令式编程（Imperative Programing），这种范式更关注计算机完成任务所执行的具体步骤；与之对的另外一种编程范式为声明式编程（Declararive Programing），这种范式更倾向于表达计算逻辑。区别实例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># 命令式
#define ARR_LEN 5
int main(void) { 
  int arr[ARR_LEN] = { 1, 5, 10, 9, 0 };
  for (int i = 0; i &lt; ARR_LEN; ++i) {
    if (arr[i] &gt; 7) {
      // save this element somewhere else.
    }
  }
  return 0;
}


# 声明式
let arr = [1, 5, 10, 9, 0]
let result = arr.filter(n =&gt; n &gt; 7)
</code></pre></td></tr></table>
</div>
</div><h2 id="编译和运行">编译和运行</h2>
<p><img src="/image/learn_c/1_1.webp" alt="compile"></p>
<ol>
<li>代码预处理：编译器会移除所有注释信息、处理宏指令。</li>
<li>编译优化：编译器优化源码，将代码编程成汇编格式。</li>
<li>汇编：编译器将汇编代码编译成操作系统使用的某种对象格式。</li>
<li>链接：编译器将依赖的对象文件进行整合，设置好程序中所有调用函数的正确地址，生成二进制执行文件。</li>
</ol>
<h1 id="第二讲-数据和量值">第二讲 数据和量值</h1>
<h2 id="量值">量值</h2>
<p>量值可以粗略地分为变量（Variable）和常量（constant）</p>
<h3 id="变量">变量</h3>
<p>C 语言变量类型占用的具体字节大小与程序运行所在的硬件体系结构紧密相关</p>
<h3 id="常量">常量</h3>
<p>在 C 语言中，通过内联方式直接写到源码中的字面量值一般被称为常量。</p>
<p>使用 const 关键字修饰的变量更接近于只读变量，不具有”常量表达式“属性，因此无法用来表示定长数组大小或使用在 case 语句中。
常量表达式在编译时被求值，而只读变量在运行时才被确定</p>
<h2 id="数据的存储形式">数据的存储形式</h2>
<p>计算机内部使用 补码（Two&rsquo;s-complement）存放有符号整数，使用对应的二进制来存放无符号整数，使用 IEEE-754 标准来存放浮点数。</p>
<h3 id="补码">补码</h3>
<p>一个补码所表示的实际数值，由负权重位的值（最高位）和正权重为的值求和。
如 1101，是及对应的值为 -3（-8 + 5）。
由此也得出四位补码的最小值为 -8（1000），最大值为 7（0111）。</p>
<h3 id="ieee-754">IEEE-754</h3>
<h2 id="数据的存储位置">数据的存储位置</h2>
<p><img src="/image/learn_c/2_1.webp" alt="data_store_position"></p>
<p>应用程序被正常加载前，需要将应用程序代码机器相关依赖数据映射到内存的某个位置，这段内存称之为进程的VAS（Virtual Address Space 虚拟地址空间）.</p>
<p>初始化的全局变量和静态变量和应用程序具有同样的生命周期，其值通常会被存放到进程VAS内的 .data 中。</p>
<p>局部变量存放于寄存器或者 VAS 的栈中</p>
<p>通过 malloc 创建的内存存放于 VAS 的堆中</p>
<p>未初始化的全局变量和静态变量存放于 VAS 的 .bss 中</p>
<p>常量会按照数据的大小和类型存放于 VAS的 .text （通常存放代码） 或 .rodata （通常存放只读数据） 中</p>
<p><img src="/image/learn_c/2_2.webp" alt="const_data_store_position"></p>
<h1 id="第三讲-运算符">第三讲 运算符</h1>
<p>运算符（operator）、表达式（expression）和语句（statement）是组成 C 语言程序的三个基本的语法结构，且一般依次呈包含关系。</p>
<h2 id="运算符分类">运算符分类</h2>
<p><img src="/image/learn_c/3_2.webp" alt="operator_class"></p>
<h2 id="算数关系为赋值运算">算数、关系、为、赋值运算</h2>
<p>这四类运算符经过编译后，可以直接对应到由目标平台上相应的机器指令组成的简单计算逻辑。</p>
<p>拿下图的 foo 函数举例</p>
<p><img src="/image/learn_c/3_2.webp" alt="foo"></p>
<p><code>DWORD PRT [rbp-8]</code> 指 将寄存器 rbp 的值减去 8 得到的结果作为起始地址，然后操作一个 大小为 DWORD 的空间。intel体系中 WORD 表示 16 位，DWROD 表示 32 位，QWORD 表示 64 位。</p>
<p><code>int arithmetic = x + y;</code>对应的汇编代码中，前两行代码为分别从栈内存中将变量 x 和 y 存入 寄存器 edx 和 eax，接着通过 add 指令计算两者之和，最后通过 mov 指令将寄存器 eax 的值移到 局部变量 arithmetic 对应的栈内存中。</p>
<p>FLAGS 寄存器是一组用于反映程序当前运行状态的标志寄存器，详情如下</p>
<p><img src="/image/learn_c/3_3.webp" alt="flags_register"></p>
<p>cmp 指令会在 CPU 内部对两个操作数进行隐式减法运算，然后设置 FLAGS寄存器状态。</p>
<h2 id="逻辑运算符">逻辑运算符</h2>
<p>以与运算符 &amp;&amp; 举例，示例代码如下</p>
<p><img src="/image/learn_c/3_4.webp" alt="and_operator"></p>
<p>je 指令会判断 ZF 标志位是否为 0， 如果是则跳转到指定地址</p>
<p>与运算的高级编辑优化，编译器会采用 test、setne、movzx来实现，
这种方式减少了对栈内存即条件跳转指令的使用，是的程序减少了
访问内存时产生的延迟，以及由于分支预测失败导致的CPU周期延迟。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-as" data-lang="as"><span class="nx">test</span>    <span class="nx">edi</span><span class="o">,</span> <span class="nx">edi</span>  <span class="o">;</span> <span class="nx">edi</span> <span class="o">&lt;-</span> <span class="nx">x</span><span class="p">.</span>
<span class="nx">setne</span>   <span class="nx">al</span>
<span class="nx">test</span>    <span class="nx">esi</span><span class="o">,</span> <span class="nx">esi</span>  <span class="o">;</span> <span class="nx">esi</span> <span class="o">&lt;-</span> <span class="nx">y</span><span class="p">.</span>
<span class="nx">setne</span>   <span class="nx">sil</span>
<span class="nx">movzx</span>   <span class="nx">esi</span><span class="o">,</span> <span class="nx">sil</span>
<span class="nx">and</span>     <span class="nx">esi</span><span class="o">,</span> <span class="nx">eax</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="成员访问运算符">成员访问运算符</h2>
<p><img src="/image/learn_c/3_5.webp" alt="address_operator"></p>
<p><code>int* n_ptr = &amp;n;</code>对应的汇编指令中首先 lea 指令将寄存器 rbp 中的值减去 16 后，存放到 rax 寄存器，即将n在站上的地址存放到 rax 寄存器；然后将 rax 寄存器的值存到 变量 n_ptr对应的栈内存的存储位置。</p>
<p><code>int m = *n_ptr;</code>对应的汇编指令中首先将 n_ptr的值传送到 寄存器 ra；随后将 rax 的值作为地址，将该地址上的值以 DWORD（即 int）形式传送到 eax 寄存器；最后将 eax 寄存器中的结果只传送到 变量 m 在栈内存的存储位置。</p>
<h2 id="其他运算符">其他运算符</h2>
<p>这里介绍 <code>sizeof</code> 和 <code>(type)</code>，示例如下：</p>
<p><img src="/image/learn_c/3_6.webp" alt="other_operator"></p>
<p><code>size_t n = sizeof(int)</code> 的汇编指令可以看出直接将结果4存到了 n 对应的栈内存。</p>
<p><code>short f = (short) n;</code>的汇编指令首先将变量 n 的值移到 rax 寄存器，然后将其中低 16位的数据（ax）地道 f 所在的内存趋于</p>
<h1 id="第四讲-控制逻辑">第四讲 控制逻辑</h1>
<h2 id="表达式">表达式</h2>
<p>表达式（expression）是由一系列运算符和操作数（operand）组成的一种语法结构。</p>
<p>对表达式的求值过程，实际上就是根据运算符的优先级和结合性，来对表达式和它所包含的子表达式进行递归求值的过程。</p>
<p>可以使用<code>clang -Xclang -ast-dump -fsyntax-only main.c</code> 命令得到 C 程序对应的 AST 结构</p>
<h2 id="语句">语句</h2>
<p>语句（statement）是用来描述程序的基本构建块。</p>
<p>语句可以包含或者不含表达式；语句在执行时不返回任何结果；语句以分号结尾。</p>
<p>语句分为复合语句、表达式语句、选择语句、迭代语句、跳转语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 复合语句；
</span><span class="c1"></span> <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// 表达式语句；
</span><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 复合语句；
</span><span class="c1"></span>   <span class="n">sum</span> <span class="o">=</span> <span class="o">-</span><span class="n">sum</span><span class="p">;</span>  <span class="c1">// 表达式语句；
</span><span class="c1"></span> <span class="p">}</span>
 <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="选择语句">选择语句</h3>
<p><code>if...else</code> 语句示例如下：</p>
<p><img src="/image/learn_c/4_1.webp" alt="if_else_statement"></p>
<p><code>switch...case</code>语句示例如下：</p>
<p><img src="/image/learn_c/4_2.webp" alt="switch_case_statement"></p>
<h3 id="迭代语句">迭代语句</h3>
<p>迭代语句主要包含 <code>do...while</code>、<code>for</code>、<code>while</code> 三种形式，u示例如下：
<img src="/image/learn_c/4_3.webp" alt="do_while_statement"></p>
<h3 id="跳转语句">跳转语句</h3>
<p>跳转语句主要包含 <code>break</code>、<code>continue</code>、<code>return</code>、<code>goto</code> 四种形式</p>
<h1 id="第五讲-函数调用上">第五讲 函数调用（上）</h1>
<h2 id="快速回顾">快速回顾</h2>
<p>借用函数，可以将一个程序的实现过程拆分为多个子步骤，并以结构化的方式来构建程序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;tgmath.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Point</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">Point</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="n">handler</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">handler</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">Point</span> <span class="n">p</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">10</span> <span class="p">};</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">handler</span><span class="p">));</span>  <span class="c1">// 5.
</span><span class="c1"></span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 

</code></pre></td></tr></table>
</div>
</div><p>函数类型的参数默认以指针传递，可以省略表明指针类型的<code>*</code>符号</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">Point</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="c-函数的调用约定">C 函数的调用约定</h2>
<p>我们将编译器实现函数调用所遵循的一系列规则称之为函数的调用约定（Calling Convention）</p>
<p>调用约定并非 C 语言标准的一部分，不同平台有不同的标准，
Unix系统使用 System V AMD64 ABI （简称 SysV）的调用约定</p>
<p>SysV 函数调用示例如下：</p>
<p><img src="/image/learn_c/5_1.webp" alt="sysv_calling_convention"></p>
<p>函数调用是通过 call 指令来完成，每个函数执行完毕后通过 ret 指令
来退出函数的执行，并转移代码执行流程到之前函数调用指令的下一条指令上</p>
<p><img src="/image/learn_c/5_2.webp" alt="call_and_ret"></p>
<h2 id="参数约定">参数约定</h2>
<p>对于整形和指针类型的实参，需要分别使用寄存器 rdi、rsi、rdx、rcx、r8、r9，按函数定义是参数从左到右的顺序进行传值。如果参数超过 6 个，
则余下参数通过栈内存进行传送，多出来的参数从右到左入栈</p>
<p>对于浮点数，使用 xmm0 到 xmm7 共 8 个寄存器进行存储。
对于更宽的值，也可能使用 ymm 与 zmm 寄存器来代替 xmm 寄存器。</p>
<h2 id="返回值传递">返回值传递</h2>
<p>整数类型返回值，小于 64 位，使用 rax 寄存器（32 位的别名为 eax ），小于 128 位，使用 rax和 rdx 分别返回低 64 位和高 64 位</p>
<p>浮点数会使用 xmm、ymm、zmm 寄存器。</p>
<h2 id="寄存器使用">寄存器使用</h2>
<p>对于 rbx、rbp、rsp 和 r12 ~ r15 寄存器，若函数需要使用它们，
需要使用前暂存，退出前恢复。</p>
<h2 id="堆栈清理">堆栈清理</h2>
<p>每个函数在结束前，需要清理自身的堆栈，可以通过 leave 指令完成</p>
<h2 id="其他约定">其他约定</h2>
<ul>
<li>函数在 call 调用前， 需要保证栈顶地址值 16 字节对齐</li>
<li>从栈顶向上保留128 字节作为 “Red Zone”</li>
<li>系统调用使用寄存器 rdi、rsi、rdx、r10、r8 和 r9 传递参数</li>
</ul>
<p>Red Zone 是位于栈顶向上的一段固定长度的内存段，这块区域可以被调用函数栈中的 “叶子” 函数（即不再调取其他函数的函数）使用，这样在需要额外栈内存时，就能省去调整栈内存大小的过程。</p>
<h2 id="保存函数调用信息的栈帧">保存函数调用信息的栈帧</h2>
<p>我们将栈内存数据块称之为帧栈，帧栈存放有返回地址、实参
局部地址、返回值和暂存的寄存器值。</p>
<p>在进程内存中，栈内存是从高向低增长的，即栈底位于高地址处，栈顶位于
低地址处。</p>
<p>rsp 寄存器又称之为 Stack Pointer，其存放着栈顶地址，即其决定了
栈内存大小，通过减小其存储的值，就能扩大栈内存。</p>
<p><img src="/image/learn_c/5_3.webp" alt="stack_memory"></p>
<p>bar 函数第一行指令 <code>push rbp</code> 会将当前 rbp 寄存器的值存到栈中，
rbp 寄存器 又称为 Frame Pointer， 通常来存储调用前的栈高度，即
rsp的旧值，以便进行帧栈寻址，并在退出前将栈中数据恢复到调用前的状态；
第二行指令<code>mov rbp, rsp</code>便是将 rsp 的值保存到 rbp 中；
第三行指令<code>mov eax, 10</code> 将结果存入 eax 寄存器;
第四行指令<code>pop rbp</code> 恢复 rbp 寄存器的值；
第五行指令<code>ret</code> 将程序的执行转移到函数调用前。</p>
<p>main 函数第 29 行指令<code>sub rsp, 16</code>减小 rsp 的值，将栈空间扩大 16 字节；
第 30、31 行指令分别将 1 和 2 存入 rbp-4 和 rbp-8 的位置；
第 34、35 行指令，借助 push， 将 8 和 7 存入 rbp-12 、 rbp-16的位置。</p>
<p>leave 指令会恢复 rsp的值来“清理”栈数据，并恢复 rbp的值。
等效于: <code>mov rsp, rbp; pop rbp</code>; 与之对应的 enter 指令等效于 <code>push rbp; mov rpb, rsp</code></p>
<p><img src="/image/learn_c/5_4.webp" alt="main_func_memory"></p>
<h1 id="第六讲-函数调用下">第六讲 函数调用（下）</h1>
<h2 id="函数参数求值顺序">函数参数求值顺序</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d %d %d&#34;</span><span class="p">,</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">n</span><span class="o">++</span><span class="p">);</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>如上示例程序，C 函数参数的求值顺序并没有被明确规定，有的编译器按从左到右计算，有的从左到右计算。</p>
<p>为了程序健壮性，不要编写需要依赖特定函数参数求值顺序的代码。</p>
<h2 id="尾递归调用优化tail-call-optimization">尾递归调用优化（tail-call optimization）</h2>
<p><img src="/image/learn_c/6_1.webp" alt="factorial_function"></p>
<p>函数调用过程所需数据是以帧栈的形式存到到进程的栈内存中，而栈内存的清理工作是在函数准备ret 返回前，通过 leave指令进行。
对于正常的递归函数，由于函数不断调用自己，产生的帧栈越来越多，可能导致内存溢出；另外函数调用会创建和销毁帧栈，这也是消耗性能的。</p>
<p>尾递归调用优化是指在一定条件下，编译器直接利用跳转指令代替函数调用指令，来模拟函数调用过程，这样便可省去函数调用帧栈的不断创建和销毁，
而且也只使用了有限的栈内存。</p>
<p>尾递归调用优化一个前提条件是：递归语句必须是在函数返回前的最后一条语句。在这种情况下，编译器才能确定函数的返回值没有被上一个帧栈所使用。</p>
<p><img src="/image/learn_c/6_2.webp" alt="factorial_function2"></p>
<p>上面的函数开启最高编译优化等级”-O3“后，会使用尾递归优化，
在执行 ret 前，会判断寄存器 edi 的值是否为0 （ZF=1），来决定调转</p>
<h2 id="kr-函数声明">K&amp;R 函数声明</h2>
<p>K&amp;R 函数声明可能不知道函数的参数列表，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">add</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>  <span class="c1">// ?
</span><span class="c1"></span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这样导致参数是一个随机值，不建议使用。</p>
<h1 id="第七讲-枚举结构和联合是如何实现的">第七讲 枚举、结构和联合是如何实现的？</h1>
<h2 id="枚举-enumeration">枚举 Enumeration</h2>
<p><img src="/image/learn_c/7_1.webp" alt="enum"></p>
<p>从汇编代码可以看出自定义枚举类型都是以 int 类型存储的，枚举值 Mon 在底层是由 0 表示。</p>
<p>C 标准直接将枚举值当做整数进行处理，这样导致foo 函数在调用时，实际上允许传入任何可以被隐式转换为 int 类型的值。</p>
<h2 id="结构-struct">结构 Struct</h2>
<p>结构和数组类型，都是使用连续的内存存放数据，不过结构可以存放不同的类型的数据。</p>
<p><img src="/image/learn_c/7_2.webp" alt="struct"></p>
<p>本质上，结构只是对内部所包含的各类数据的一个封装，因此只需要它分装的这些数据放在连续的内存装即可。</p>
<p><img src="/image/learn_c/7_3.webp" alt="struct_stack_memory"></p>
<p>如上图的栈内存所示，字符转指针 p 位于 [rbp-32] 处，占用 8 个字节，字符 c 位于 [rbp-24] 处，占用 1 个字节，长整形 x 位于 [rbp-16]处，占用 8 个字节。</p>
<h3 id="内存数据对齐">内存数据对齐</h3>
<p>自然对齐是指被操作数据所在的地址为该数据大小的整数倍，当内存中的数据
满足自然对齐时，CPU通常能够以最高的效率进行数据操作。</p>
<h3 id="填充字节">填充字节</h3>
<p>某些情况即使结果对象各个数据成员都满足自然对齐的要求，额外的填充字节也会被添加，如下示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>  <span class="c1">// 8 bytes.
</span><span class="c1"></span><span class="kt">char</span> <span class="n">c</span><span class="p">;</span>  <span class="c1">// 1 bytes.
</span><span class="c1">// (padding): 7 bytes.
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>之所以会这样，因为编译器想保证：当结构体被连续存放时，前一个对象结束的位置正好可以满足后一个对象的起始位置时自然对齐的要求。
这样也就要求结构对象本身的大小必须是内部最大成员大小的整数倍。</p>
<h2 id="联合-union">联合 Union</h2>
<p>联合和结构语法类型，只要把 关键字从 struct 改为 union。
顾名思义，联合就是所有字段共同使用一个内存区域。</p>
<p>联合对象的大小与内部定义最大成员的大小相同。</p>
<p>对一个单独的联合对象来说，哪个字段在生效我们无从得知，所以需要一个标签字段来配合指明正在生效的字段，这样模式叫做“Tagged Union”.</p>
<p><img src="/image/learn_c/7_4.webp" alt="union"></p>
<h1 id="第八讲-指针是如何灵活使用内存的">第八讲 指针是如何灵活使用内存的</h1>
<h2 id="指针的基本使用">指针的基本使用</h2>
<p>通过 类型说明符加 * 符号可以定义一个指向该数据类型的指针。
通过 const 关键字可以限制指针变量的行为</p>
<p><img src="/image/learn_c/8_1.webp" alt="pointer_basic_usage"></p>
<h2 id="指针和数组">指针和数组</h2>
<p><img src="/image/learn_c/8_2.webp" alt="pointer_and_array"></p>
<p>从上图看出，数据中的元素被分配在连续的栈内存中。</p>
<p>当 arr 作为实参传入函数 sum 后，实际传入的是一个指向 int 类型的指针，有关 arr 的大小和类型都全部丢失，这种情况称之为”数组的退化“。</p>
<h2 id="指针的其他运算">指针的其他运算</h2>
<h3 id="算术运算">算术运算</h3>
<p><img src="/image/learn_c/8_3.webp" alt="pointer_math_operation"></p>
<p>当我们对指针进行加减运算时，编译器是以当前指针所指向值对应的某个固定
长度为单位，对指针中存放的地址值进行相应调整的。</p>
<h3 id="关系运算">关系运算</h3>
<p>大多数情况，编译器会使用 cmp 和 setg 等指令来判断关系运算两侧操作数的大小</p>
<h2 id="堆内存指针">堆内存指针</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#define N 5
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>  
  <span class="c1">// 分配用于存放 N 个整数的堆内存；
</span><span class="c1"></span>  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
  <span class="c1">// 将数组 arr 中的元素复制到分配的堆内存中；
</span><span class="c1"></span>  <span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>  
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 通过指针遍历堆空间中的数据；
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="c1">// 释放先前分配的堆空间，让操作系统可以回收内存；
</span><span class="c1"></span>  <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在 VAS 中，堆内存位于栈内存的下方，堆内存是从低地址向高地址逐渐增长</p>
<p><img src="/image/learn_c/8_4.webp" alt="heap_memory"></p>
<p>堆内存可以动态创建，可以保持和程序相同的生命周期。
另外和全局变量、静态变量这种将值完全暴露给所有程序代码相比，
使用堆内存可以将数据的使用限制在所需的最小范围内，加强了程序对内存的精细化管理程度。</p>
<h1 id="第九讲-预处理器">第九讲 预处理器</h1>
<h2 id="预处理流程">预处理流程</h2>
<p>预处理流程如下：</p>
<ol>
<li>删除代码注释</li>
<li>处理宏定义 #define，进行展开和替换</li>
<li>处理条件预编译 #if、#elif，仅保留符合条件的代码</li>
<li>处理文件包含预编译指令 #include，将被包含的文件内容插入到指令所在位置</li>
<li>处理其他可识别的预处理指令如 #program</li>
<li>添加其他具有辅助性功能的注释信息</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#pragma GCC warning &#34;Just FYI!&#34;
</span><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span><span class="cp">#define PI 3.14
</span><span class="cp">#define SQUARE(x) (x * x)
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if defined PI
</span><span class="cp"></span>  <span class="c1">// Some specific calculations.
</span><span class="c1"></span>  <span class="k">const</span> <span class="kt">double</span> <span class="n">area</span> <span class="o">=</span> <span class="n">SQUARE</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">PI</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">bool</span> <span class="n">isAreaGT100</span> <span class="o">=</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="mf">100.0</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用<code>gcc -O0 -Wall -E exmaple.c -o example.I</code> 得到预处理后的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp"># 1 &#34;macro.c&#34;
</span><span class="cp"># 1 &#34;&lt;built-in&gt;&#34;
</span><span class="cp"># 1 &#34;&lt;command-line&gt;&#34;
</span><span class="cp"># 31 &#34;&lt;command-line&gt;&#34;
</span><span class="cp"># 1 &#34;/usr/include</span><span class="cpf">/stdc-predef.h&#34; 1 3 4</span><span class="cp">
</span><span class="cp"># 32 &#34;&lt;command-line&gt;&#34; 2
</span><span class="cp"># 1 &#34;macro.c&#34;
</span><span class="cp"></span>
<span class="cp"># 1 &#34;/usr/lib/gcc/x86_64-redhat-linux/8/include</span><span class="cpf">/stdbool.h&#34; 1 3 4</span><span class="cp">
</span><span class="cp"># 3 &#34;macro.c&#34; 2
</span><span class="cp"></span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">const</span> <span class="kt">double</span> <span class="n">area</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mf">3.14</span><span class="p">;</span>
  <span class="k">const</span>
<span class="cp"># 8 &#34;macro.c&#34; 3 4
</span><span class="cp"></span>       <span class="n">_Bool</span>
<span class="cp"># 8 &#34;macro.c&#34;
</span><span class="cp"></span>            <span class="n">isAreaGT100</span> <span class="o">=</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="mf">100.0</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="宏函数常用技巧">宏函数常用技巧</h2>
<h3 id="为返回值添加括号">为返回值添加括号</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="c1">// #define FOO(x) 1 + x * x
</span><span class="c1"></span><span class="n">define</span> <span class="nf">FOO</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">FOO</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="为参数添加括号">为参数添加括号</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="c1">// #define FOO(x) (1 + x * x)
</span><span class="c1"></span><span class="n">define</span> <span class="nf">FOO</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">FOO</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="警惕多次副作用">警惕多次副作用</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#define FOO(x) (1 + (x) * (x))
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">FOO</span><span class="p">(</span><span class="o">++</span><span class="n">i</span><span class="p">));</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="定义完备的多语句宏函数">定义完备的多语句宏函数</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="c1">// #define SAY() printf(&#34;Hello, &#34;); printf(&#34;world!&#34;)
</span><span class="c1"></span>
<span class="cp">#define SAY() do { printf(&#34;Hello, &#34;); printf(&#34;world!&#34;)} while (0)
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">input</span><span class="p">;</span>
  <span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>  
  <span class="k">if</span> <span class="p">(</span><span class="n">input</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">SAY</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="第十讲-字符字符串与数学计算">第十讲 字符、字符串与数学计算</h1>
<p><img src="/image/learn_c/10_1.webp" alt="c_std_library"></p>
<h2 id="字符和字符串">字符和字符串</h2>
<p>在 C 语言中，字符用单引号表示，字符串用双引号表示</p>
<h3 id="字符">字符</h3>
<p>C 语言保证 char 类型只占用一个字节大小。</p>
<p>大多数情况编译器会选择 char 类型视为有符号整数类型。</p>
<h3 id="字符串">字符串</h3>
<p>字符串可以使用指针或者数组形式表示。</p>
<p>连续出现的字符串之间如果仅有空格分隔，则会将它们视为一个整体。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">// read-only string.
</span><span class="c1"></span><span class="k">const</span> <span class="kt">char</span> <span class="n">strA</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Hello, geek!&#34;</span><span class="p">;</span>  
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">strB</span> <span class="o">=</span> <span class="s">&#34;Hello&#34;</span> <span class="s">&#34;, geek!&#34;</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>上述字符串在内存的布局如下：</p>
<p><img src="/image/learn_c/10_2.webp" alt="string_memory_layout"></p>
<p>字符串被存放在连续的内存段上，且每个字符串最后都以一个空字符作为终止符。</p>
<p>使用数组和指针形式定义的字符串，其底层的数据引用方式会有所区别。
其中数组方式会将字符串从 .rodata 中拷贝到其他位置（比如栈内存），因此修改这些这些数据不会改变原始的 .rodata 中的副本；而使用指针形式时指针会直接引用位于 .rodata 中的字符串数据，因此通过指针修改字符串的值会影响相同指向的指针字符串。</p>
<h2 id="字符库函数">字符库函数</h2>
<h3 id="统计字符串长度">统计字符串长度</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;Hi&#34;</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%zu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>  <span class="c1">// 2.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>strlen 函数不会计入字符串多余的终止符。</p>
<h3 id="拼接字符串">拼接字符串</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#define STRLEN 14
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">strA</span><span class="p">[</span><span class="n">STRLEN</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;Hello,&#34;</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">strB</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34; world!&#34;</span><span class="p">;</span>
  <span class="n">strncat</span><span class="p">(</span><span class="n">strA</span><span class="p">,</span> <span class="n">strB</span><span class="p">,</span> <span class="n">STRLEN</span> <span class="o">-</span> <span class="n">strlen</span><span class="p">(</span><span class="n">strA</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">strA</span><span class="p">);</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>strncat 可控制被拼接字符串的长度</p>
<h3 id="拷贝字符串">拷贝字符串</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">strA</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;aaaaaa&#34;</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">strB</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;bbbbbbb&#34;</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">strncpy</span><span class="p">(</span><span class="n">strA</span><span class="p">,</span> <span class="n">strB</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">strA</span><span class="p">)));</span>  <span class="c1">// &#34;bbbbbb&#34;.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="格式化字符串">格式化字符串</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#define LEN 128
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">dest</span><span class="p">[</span><span class="n">LEN</span><span class="p">];</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="n">strA</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Hello, &#34;</span><span class="p">;</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="s">&#34;%sworld!&#34;</span><span class="p">,</span> <span class="n">strA</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>sprintf 会将格式化后的字符串保存到第一个参数传入的数组中</p>
<h3 id="字符的判断和转换">字符的判断和转换</h3>
<p>ctype.h 中包含众多用于字符的函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;ctype.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">isalnum</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>  <span class="c1">// 1.
</span><span class="c1"></span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">isalpha</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>  <span class="c1">// 1.
</span><span class="c1"></span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">isblank</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>  <span class="c1">// 0.
</span><span class="c1"></span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">isdigit</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>  <span class="c1">// 0.
</span><span class="c1"></span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%c</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>  <span class="c1">// &#39;A&#39;.
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="数学运算库函数">数学运算库函数</h2>
<p>math.h 和 stdlib.h 包含了众多数学运算函数</p>
<p>thmath.h 里面提供了泛型办的数学运算函数，大体思路是通过宏来判断参数类型进而转换到正确类型的底层函数去，详情参考<a href="https://git.musl-libc.org/cgit/musl/tree/include/tgmath.h">实现</a></p>
<h1 id="第十一讲-io-标准库">第十一讲 IO 标准库</h1>
<p>C 语言采用标准库 stdio 的方式，提供对 I/O 相关接口的支持</p>
<h2 id="基本使用">基本使用</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Enter some characters:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
  <span class="n">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">&#34;./temp.txt&#34;</span><span class="p">,</span> <span class="s">&#34;w+&#34;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
      <span class="n">putc</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">perror</span><span class="p">(</span><span class="s">&#34;File open failed.&#34;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>通过 printf 将指定文本传送到标准输出流 stdout</li>
<li>通过 fopen 打开指定的文件，并将其与一个特定的文件 IO 流关联</li>
<li>通过 perror 将指定错误信息传送到标准错误流 stderr</li>
<li>通过 scanf 从 标准输入流 stdin 读取输入的信息</li>
<li>通过 putc 将 字符写入指定文件</li>
</ul>
<h2 id="接口级别">接口级别</h2>
<p>IO 接口一般分为两个级别：</p>
<ul>
<li>标准 IO：ISO C 标准定义的一些列接口，实现与具体操作系统无关</li>
<li>低级 IO：使用具体操作系统相关的一系列底层接口来提供相应的 IO 能力</li>
</ul>
<p>上面的代码使用低级 IO 接口实现如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Enter some characters:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&#34;./temp.txt&#34;</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
      <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ch</span><span class="p">));</span>    
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="n">errMsg</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;File open failed.&#34;</span><span class="p">;</span>
    <span class="n">write</span><span class="p">(</span><span class="n">STDERR_FILENO</span><span class="p">,</span> <span class="n">errMsg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">errMsg</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>和低级 IO 相比，标准 IO 会为我们提供带缓冲的输入和输出操作。</p>
<h2 id="低级-io-背后的系统调用">低级 IO 背后的系统调用</h2>
<p>低级 IO 接口通过系统调用来完成相应的 IO 操作，与调用用户函数不同使用 call 指令 不同，在 x86-64 平台，通过 syscall 指令来执行一个系统调用函数。</p>
<p>每个系统调用函数有一个唯一整形 ID, open 函数的 ID 为 2。
SyxV 调用约定使用寄存器 rdi、rsi、rdx、r10、r8、r9 来进行实参的传递，寄存器 rax 用于存放系统调用对应的 ID，并接收系统调用的结果。</p>
<p>上面的代码使用汇编改造如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Enter some characters:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
  <span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fileName</span> <span class="o">=</span> <span class="s">&#34;./temp.txt&#34;</span><span class="p">;</span>
  <span class="c1">// Call to `open` starts:
</span><span class="c1"></span>  <span class="c1">// const int fd = open(&#34;./temp.txt&#34;, O_RDWR | O_CREAT);
</span><span class="c1"></span>  <span class="k">volatile</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&#34;mov $2, %%rax</span><span class="se">\n\t</span><span class="s">&#34;</span>
      <span class="s">&#34;mov %0, %%rdi</span><span class="se">\n\t</span><span class="s">&#34;</span>
      <span class="s">&#34;mov $66, %%rsi</span><span class="se">\n\t</span><span class="s">&#34;</span>  <span class="c1">// 2 | 64 -&gt; 66;
</span><span class="c1"></span>      <span class="s">&#34;syscall</span><span class="se">\n\t</span><span class="s">&#34;</span>
      <span class="s">&#34;mov %%rax, %1</span><span class="se">\n\t</span><span class="s">&#34;</span>
       <span class="o">:</span> <span class="s">&#34;=m&#34;</span> <span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
       <span class="o">:</span> <span class="s">&#34;m&#34;</span> <span class="p">(</span><span class="n">fd</span><span class="p">));</span>
  <span class="c1">// Call ended.
</span><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
      <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ch</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="n">errMsg</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;File open failed.&#34;</span><span class="p">;</span>
    <span class="n">write</span><span class="p">(</span><span class="n">STDERR_FILENO</span><span class="p">,</span> <span class="n">errMsg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">errMsg</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的代码中，将 ID 2 存入 寄存器 rax, 将 fileName 首地址存入寄存器
rdi，将 文件操作模式 66 存入寄存器 rsi，调用结果 从 寄存器 rax 存入 局部变量 fd。</p>
<h1 id="第十二讲-非本地跳转和可变参数实现原理">第十二讲 非本地跳转和可变参数实现原理</h1>
<h2 id="本地跳转">本地跳转</h2>
<p><img src="/image/learn_c/12_1.webp" alt="local_jump"></p>
<p>本地跳转一般指由 goto 语句完成的程序执行流的转移过程</p>
<h2 id="setjmp-和-longjmp-函数">setjmp 和 longjmp 函数</h2>
<p><img src="/image/learn_c/12_2.webp" alt="long_jump"></p>
<p>如上图所示，在调用 longjmp 之后，程序会调到 call setjmp 下一条指令，
这种跳转为我们提供了一种可以暂存函数调用状态并在未来某个时刻再恢复的能力。</p>
<h3 id="运作原理">运作原理</h3>
<p>setjmp 函数在执行时，会将程序此刻的调用环境信息存储在由其第一个参数指定的 jmp_buf 类型的对象中，并同时将 0 作为结果返回，后续当程序执行到 longjmp 时，
该函数便回从同一个 jmp_buf 对象中再次恢复之前保存的函数调用上下文，通过这种方式，程序的执行流程得到了重置。</p>
<p>SysV 调用约定，属于 Callee-saved 类型的寄存器信息需要在 call 指令调用时，由被调用函数 caller 负责保存和恢复。</p>
<h3 id="自定义实现">自定义实现</h3>
<p>setjmp 汇编如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="na">.global</span> <span class="no">setjmp</span>  <span class="c"># 将 setjmp 暴露给链接器
</span><span class="c"></span><span class="no">.intel_syntax</span> <span class="no">noprefix</span>  <span class="c"># 使用汇编语法
</span><span class="c"></span><span class="no">setjmp</span><span class="p">:</span>
  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="p">],</span> <span class="no">rbx</span>
  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x8</span><span class="p">],</span> <span class="no">rbp</span>
  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x10</span><span class="p">],</span> <span class="no">r12</span>
  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x18</span><span class="p">],</span> <span class="no">r13</span>
  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x20</span><span class="p">],</span> <span class="no">r14</span>
  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x28</span><span class="p">],</span> <span class="no">r15</span>
  <span class="nf">lea</span>  <span class="no">rdx</span><span class="p">,</span> <span class="p">[</span><span class="no">rsp</span><span class="err">+</span><span class="mi">0x8</span><span class="p">]</span>
  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x30</span><span class="p">],</span> <span class="no">rdx</span>
  <span class="nf">mov</span>  <span class="no">rdx</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rsp</span><span class="p">]</span>
  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x38</span><span class="p">],</span> <span class="no">rdx</span>
  <span class="nf">xor</span>  <span class="no">eax</span><span class="p">,</span> <span class="no">eax</span>
  <span class="nf">ret</span>
</code></pre></td></tr></table>
</div>
</div><p>由 SysV 规定，寄存器 rdi 接收第一个实参，所以 rdi 保存着
jmp_buf 的首地址， jmp_buf 可以看做是一个具有足够大小的字节数组。</p>
<p>在 4~9 行我们将寄存器 rdx、rbp、r12、r13、r14、r15 的值进行保存，
在 10~11 行我们将 setjmp 调用之前的 rsp 寄存器进行了暂存，
在 12~13 行我们将 setjmp 调用后的地址进行暂存，这个地址将由 longjmp 使用</p>
<p>longjmp 汇编如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="na">.global</span> <span class="no">longjmp</span>
<span class="na">.intel_syntax</span> <span class="no">noprefix</span>
<span class="nl">longjmp:</span>
  <span class="nf">xor</span>  <span class="no">eax</span><span class="p">,</span> <span class="no">eax</span>
  <span class="nf">cmp</span>  <span class="no">esi</span><span class="p">,</span> <span class="mi">0x1</span>
  <span class="nf">adc</span>  <span class="no">eax</span><span class="p">,</span> <span class="no">esi</span>
  <span class="nf">mov</span>  <span class="no">rbx</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="p">]</span>
  <span class="nf">mov</span>  <span class="no">rbp</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x8</span><span class="p">]</span>
  <span class="nf">mov</span>  <span class="no">r12</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x10</span><span class="p">]</span>
  <span class="nf">mov</span>  <span class="no">r13</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x18</span><span class="p">]</span>
  <span class="nf">mov</span>  <span class="no">r14</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x20</span><span class="p">]</span>
  <span class="nf">mov</span>  <span class="no">r15</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x28</span><span class="p">]</span>
  <span class="nf">mov</span>  <span class="no">rsp</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x30</span><span class="p">]</span>
  <span class="nf">jmp</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x38</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>在 4~5 行我们将对 long_jmp 的第二个参数做处理，如果实参为 0，将其改为 1，这样做是为了能够通过寄存器 rax 中的值区分当前代码是在 setjmp 函数调用后首次执行的，还是 long_jmp 恢复后执行的</p>
<p>将汇编代码编译成对象文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">gcc -c setjmp.s -o setjmp.o
gcc -c longjmp.s -o longjmp.o
</code></pre></td></tr></table>
</div>
</div><p>完整代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdnoreturn.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="c1">// 定义 jmp_buf 类型；
</span><span class="c1"></span><span class="k">typedef</span> <span class="kt">long</span> <span class="n">jmp_buf</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="c1">// 提供函数原型；
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">setjmp</span><span class="p">(</span><span class="n">jmp_buf</span><span class="p">);</span>
<span class="n">noreturn</span> <span class="kt">void</span> <span class="nf">longjmp</span><span class="p">(</span><span class="n">jmp_buf</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="c1">// 原始 C 示例程序代码；
</span><span class="c1"></span><span class="n">jmp_buf</span> <span class="n">jb</span><span class="p">;</span>
<span class="n">noreturn</span> <span class="kt">void</span> <span class="nf">inspect</span><span class="p">(</span><span class="kt">char</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">putchar</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
  <span class="n">longjmp</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">volatile</span> <span class="kt">char</span> <span class="n">count</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">setjmp</span><span class="p">(</span><span class="n">jb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="sc">&#39;J&#39;</span><span class="p">)</span>
    <span class="n">inspect</span><span class="p">(</span><span class="n">count</span><span class="o">++</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>编译、测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">gcc main.c setjmp.o longjmp.o -o main <span class="o">&amp;&amp;</span> ./main
</code></pre></td></tr></table>
</div>
</div><p>通常非本地跳转主要用来实现异常处理、协程等功能</p>
<p>使用非本地调整实现的 try &hellip; catch 可以参考<a href="http://groups.di.unipi.it/~nids/docs/longjump_try_trow_catch.html">longjump_try_trow_catch</a></p>
<h2 id="可变参数">可变参数</h2>
<h3 id="基本使用-1">基本使用</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">print_sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">va_list</span> <span class="n">ap</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span> 
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print_sum</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="运作原理-1">运作原理</h3>
<p><a href="https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf">SysV ABI</a> 规定了可变参数列表的实现要求</p>
<p>首先实参将会按类型按顺序依次存入寄存器，
接着一块名为 Register Save Area 的 栈内存被构建，每个通过寄存器传入的实参值都会按照 rdi、rsi、rdx、rcx、r8、r9、xmm0~15 的寄存器先后顺序拷贝到 RSA 中，
接下来创建 结构体 va_list</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gp_offset</span><span class="p">;</span>  <span class="c1">// 下一个整型数据相较于 RSA 的偏移；
</span><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fp_offset</span><span class="p">;</span>  <span class="c1">// 下一个浮点数据相较于 RSA 的偏移；
</span><span class="c1"></span>  <span class="kt">void</span> <span class="o">*</span><span class="n">overflow_arg_area</span><span class="p">;</span>  <span class="c1">// 指向使用栈进行传递的数据；
</span><span class="c1"></span>  <span class="kt">void</span> <span class="o">*</span><span class="n">reg_save_area</span><span class="p">;</span>  <span class="c1">//  指向 RSA 的指针；
</span><span class="c1"></span><span class="p">}</span> <span class="n">va_list</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><p><code>va_start(ap, count)</code> 语句对 ap 进行了初始化，reg_save_area 指向了 RSA 起始位置，gp_offset 设置为 从 RSA 中读整数实参相对 reg_save_area 的偏移</p>
<p><code>va_arg(ap, int)</code> 语句根据 va_list 及提取参数的类型从 RSA 中取出相应的数据值</p>
<p><code>va_end(ap)</code> 释放了 ap</p>
<h1 id="第十三讲-c-并发编程">第十三讲 C 并发编程</h1>
<p>C11 标准加入了 thread.h 和 stdatomic.h 标准库，提供了一套通用的并发编程接口</p>
<h2 id="进程-vs-线程">进程 vs 线程</h2>
<p>默认情况，操作系统会为每一个运行的程序创建一个相应的进程，作为程序的运行实例。
进程中包含一系列运行时信息，比如 VAS、PID、 处理器上下文（如通用寄存器和指令寄存器的值），进程状态分配调度相关资源。这些信息被放在 <code>进程控制块 PCB</code> 数据结构中。</p>
<p>相比进程，线程提供了更细粒度的运行单元，线程在共享程序运行资源的情况下，负责程序某个子任务的具体执行过程。线程的状态信息被放在 <code>线程控制块 TCB</code> 数据结构中</p>
<p><img src="/image/learn_c/13_1.webp" alt="thread1"></p>
<h2 id="线程的基本控制">线程的基本控制</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">thrd_t</span> <span class="n">id</span> <span class="o">=</span> <span class="n">thrd_current</span><span class="p">();</span>  <span class="c1">// 返回该函数运行所在线程的标识符；
</span><span class="c1"></span>  <span class="n">printf</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">thrd_success</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef __STDC_NO_THREADS__
</span><span class="cp"></span>  <span class="n">thrd_t</span> <span class="kr">thread</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
  <span class="c1">// 创建一个线程；
</span><span class="c1"></span>  <span class="n">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="s">&#34;Hello C11 thread with id: %lu.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">thrd_join</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="n">thrd_success</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 等待其他线程退出；
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Thread returns %d at the end.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>  
  <span class="p">}</span>  
<span class="cp">#endif
</span><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其他线程控制函数如下表：</p>
<p><img src="/image/learn_c/13_2.webp" alt="thread2"></p>
<h2 id="数据竞争">数据竞争</h2>
<p>数据竞争 Data Race 是指在一个多线程的环境中，有两个及以上的线程同一时间对同一块内存的数据进行了非原子操作，示例如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#define THREAD_COUNT 20
</span><span class="cp">#define THREAD_LOOP 100000000
</span><span class="cp"></span><span class="kt">long</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 全局变量，用来记录线程的累加值；
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_LOOP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">counter</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// 在线程中递增全局变量的值；
</span><span class="c1"></span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Thread %d terminates.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">thrd_success</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef __STDC_NO_THREADS__
</span><span class="cp"></span>  <span class="kt">int</span> <span class="n">ids</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>  <span class="c1">// 用于存放线程序号的数组；
</span><span class="c1"></span>  <span class="n">thrd_t</span> <span class="n">threads</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>  
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">run</span><span class="p">,</span> <span class="n">ids</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>  <span class="c1">// 创建 THREAD_COUNT 个线程；
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">thrd_join</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// 让当前线程等待其他线程执行完毕；
</span><span class="c1"></span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Counter value is: %ld.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>  <span class="c1">// 输出 counter 变量最终结果；
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>  
</code></pre></td></tr></table>
</div>
</div><p><code>counter++</code> 语句可能会编译为如下几条机器指令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">mov</span> <span class="no">eax</span><span class="p">,</span> <span class="no">DWORD</span> <span class="no">PTR</span> <span class="no">counter</span><span class="p">[</span><span class="no">rip</span><span class="p">]</span>
<span class="nf">add</span> <span class="no">eax</span><span class="p">,</span> <span class="mi">1</span>
<span class="nf">mov</span> <span class="no">DWORD</span> <span class="no">PTR</span> <span class="no">counter</span><span class="p">[</span><span class="no">rip</span><span class="p">],</span> <span class="no">eax</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="竞态条件">竞态条件</h2>
<p>竞态条件 Race Condition 是指由于程序中某些事件的发生时机和顺序不一致，从而影响正确性的一种缺陷</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdatomic.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span><span class="cp">#define THREAD_COUNT 10
</span><span class="cp"></span><span class="n">atomic_int</span> <span class="n">accountA</span> <span class="o">=</span> <span class="mi">100000000</span><span class="p">;</span>  <span class="c1">// 转出账户初始金额；
</span><span class="c1"></span><span class="n">atomic_int</span> <span class="n">accountB</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 转入账户初始金额；
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">_amount</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">v</span><span class="p">);</span>  <span class="c1">// 获得当前线程的转移金额；
</span><span class="c1"></span>  <span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
    <span class="c1">// 首先判断转出账户金额是否足够，不够则直接退出；
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">accountA</span> <span class="o">&lt;</span> <span class="n">_amount</span><span class="p">)</span> <span class="k">return</span> <span class="n">thrd_error</span><span class="p">;</span>  
    <span class="n">atomic_fetch_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">accountB</span><span class="p">,</span> <span class="n">_amount</span><span class="p">);</span>  <span class="c1">// 将金额累加到转入账户；
</span><span class="c1"></span>    <span class="n">atomic_fetch_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">accountA</span><span class="p">,</span> <span class="n">_amount</span><span class="p">);</span>  <span class="c1">// 将金额从转出账户中扣除；
</span><span class="c1"></span>  <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if !defined(__STDC_NO_THREADS__) &amp;&amp; !defined(__STDC_NO_ATOMICS__)
</span><span class="cp"></span>  <span class="n">thrd_t</span> <span class="n">threads</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>  
  <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">amount</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">50</span><span class="p">;</span>  <span class="c1">// 为每一个线程生成一个随机转移金额；
</span><span class="c1"></span>    <span class="n">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">run</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amount</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">thrd_join</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;A: %d</span><span class="se">\n</span><span class="s">B: %d&#34;</span><span class="p">,</span> <span class="n">accountA</span><span class="p">,</span> <span class="n">accountB</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><p>由于加钱和减钱的操作是分开的，可能导致错误的结果</p>
<h2 id="指令重排">指令重排</h2>
<p>现代编译器和处理器会采用指令重排来进一步提升程序的运行效率。
这种技术会在不影响程序可观测执行结果的情况下，对生成的机器指令或实际执行顺序进行适当的重排。</p>
<p>对于编译器来说，其表象是源码中的语句出现顺序和汇编代码实现的顺序不一致。</p>
<p>对于处理器来说，则是程序在真正执行时产生副作用的顺序（如变量赋值），与汇编代码指令出现顺序不一致</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdatomic.h&gt;</span><span class="cp">
</span><span class="cp">#if !defined(__STDC_NO_ATOMICS__)
</span><span class="cp"></span><span class="n">atomic_int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>  <span class="c1">// ！变量 y 的值可能被优先更新！
</span><span class="c1"></span><span class="p">}</span>
<span class="kt">int</span> <span class="nf">observe</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span><span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">20</span><span class="p">)</span> <span class="p">;</span>  <span class="c1">// 忙等待；
</span><span class="c1"></span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>  <span class="c1">// 只在 x 被更新后打印；
</span><span class="c1"></span><span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if !defined(__STDC_NO_THREADS__)
</span><span class="cp"></span>  <span class="n">thrd_t</span> <span class="n">threadA</span><span class="p">,</span> <span class="n">threadB</span><span class="p">;</span>  
  <span class="n">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threadA</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threadB</span><span class="p">,</span> <span class="n">observe</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">thrd_join</span><span class="p">(</span><span class="n">threadA</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">thrd_join</span><span class="p">(</span><span class="n">threadB</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="第十四讲-如何协调线程">第十四讲 如何协调线程</h1>
<h2 id="互斥量">互斥量</h2>
<p>互斥量 mtx_t_init 初始化有三种模式</p>
<ul>
<li>mtx_plain: 普通模式</li>
<li>mtx_recursive： 可重入模式</li>
<li>mtx_timed：有超时限制，超过后互斥失效</li>
</ul>
<p>另外两个互斥相关函数</p>
<ul>
<li>mtx_trylock: 加锁或者直接返回</li>
<li>call_once：仅调用一次</li>
</ul>
<h2 id="原子操作">原子操作</h2>
<p>stdaotmic.h 文件中 提供了一些原子操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdatomic.h&gt;</span><span class="cp">
</span><span class="cp">#define THREAD_COUNT 10
</span><span class="cp">#define THREAD_LOOP 100000000
</span><span class="cp">#if !defined(__STDC_NO_ATOMICS__)
</span><span class="cp"></span><span class="n">_Atomic</span> <span class="kt">long</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 定义一个原子类型全局变量，用来记录线程的累加值；
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_LOOP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">atomic_fetch_add_explicit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>  <span class="c1">// 使用原子加法操作；
</span><span class="c1"></span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Thread %d terminates.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">thrd_success</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if !defined(__STDC_NO_THREADS__) || !defined(__STDC_NO_ATOMICS__)
</span><span class="cp"></span>  <span class="kt">int</span> <span class="n">ids</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>
  <span class="n">thrd_t</span> <span class="n">threads</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>  
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">run</span><span class="p">,</span> <span class="n">ids</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">thrd_join</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Counter value is: %ld.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过 <code>_Atomic</code> 声明一个院子类型变量，使用 atomic_fetch_add_explicit 来进行原子变量的加法操作，内存顺序有三种：</p>
<p><img src="/image/learn_c/14_1.webp" alt="memory_order"></p>
<p>更多原子操作相关函数如下：</p>
<p><img src="/image/learn_c/14_2.webp" alt="atomic_functions"></p>
<h2 id="条件变量">条件变量</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">mtx_t</span> <span class="n">mutex</span><span class="p">;</span>
<span class="n">cnd_t</span> <span class="n">cond</span><span class="p">;</span>  <span class="c1">// 定义一个条件变量；
</span><span class="c1"></span><span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">mtx_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> 
  <span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">cnd_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>  <span class="c1">// 通知等待中的线程；
</span><span class="c1"></span>  <span class="n">mtx_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> 
  <span class="k">return</span> <span class="n">thrd_success</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef __STDC_NO_THREADS__
</span><span class="cp"></span>  <span class="n">mtx_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="n">mtx_plain</span><span class="p">);</span> 
  <span class="n">cnd_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>  <span class="c1">// 初始化条件变量；
</span><span class="c1"></span>  <span class="n">thrd_t</span> <span class="kr">thread</span><span class="p">;</span>  
  <span class="n">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">mtx_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> 
  <span class="k">while</span> <span class="p">(</span><span class="n">done</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cnd_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>  <span class="c1">// 让当前线程进入等待队列；
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="n">mtx_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> 
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;The value of done is: %d&#34;</span><span class="p">,</span> <span class="n">done</span><span class="p">);</span>
  <span class="n">mtx_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">cnd_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>  <span class="c1">// 销毁条件变量；
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>条件变量提供了线程间通知能力，某个线程可以在完成了某件事后，通知并唤醒等待线程。</p>
<h2 id="本地变量">本地变量</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdatomic.h&gt;</span><span class="cp">
</span><span class="cp">#define THREAD_COUNT 10
</span><span class="cp">#define THREAD_LOOP 10000
</span><span class="cp"></span><span class="n">_Thread_local</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 定义线程本地变量；
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_LOOP</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 更新当前线程所属的 counter 变量值；
</span><span class="c1"></span>  <span class="k">return</span> <span class="n">counter</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="n">thrd_t</span> <span class="n">threads</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">run</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">thrd_join</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">result</span><span class="p">;</span>  <span class="c1">// 累加每个线程的计算值；
</span><span class="c1"></span>  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;The value of count is %d.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>线程本地变量的值仅能够在某个线程的生存期内可用，变量的实际存储空间会在线程开始时分配，线程结束时回收。</p>
<p><img src="/image/learn_c/14_3.webp" alt="thread_local_variable"></p>
<h1 id="第十五讲-信号">第十五讲 信号</h1>
<h2 id="什么是信号">什么是信号</h2>
<p>信号实际上是一种可以用来传递特定消息的机制，操作系统将程序运行过程中发生的各类特殊情况转发给程序，并按照其指定的逻辑进行处理。</p>
<p>信号的产生是一个随机的过程，所以程序需要提前”告诉“操作系统，信号到来时，应该如何处理。这就是一种典型的异步事件处理方式。</p>
<h2 id="信号与软中断">信号与软中断</h2>
<p>信号是一种软中断，当特定事件发生时，操作系统会将对应的信号值发送给相关程序，通常情况下，如果对应程序并未设置自定义的信号处理程序，则操作系统会执行默认信号处理程序。整个程序处理过程中，存在着 CPU 从用户态到信号处理程序的执行流程转移。</p>
<h2 id="c-代码样例">C 代码样例</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">sigHandler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Signal %d catched!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGFPE</span><span class="p">,</span> <span class="n">sigHandler</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>C 标准库提供了 6 种不同类型的信号</p>
<p><img src="/image/learn_c/15_1.webp" alt="signal_num"></p>
<p>信号处理函数的原型为 <code>void (*handler) (int)</code>，即接受一个整形的信号值，不返回任何内容。</p>
<p>除零异常的信号交互逻辑如下：</p>
<ol>
<li>CPU 执行触发指令 idiv</li>
<li>发现除零异常，CPU 暂停当前程序运行，并将控制权转交给操作系统</li>
<li>操作系统将信号 SIGFPE 发送给出错的程序</li>
<li>操作系统根据情况执行相应的信号处理程序</li>
<li>信号处理程序执行完毕后，如果程序未退出，则将程序执行恢复到之前的中断点，即 CPU 会重新执行 idiv 指令</li>
</ol>
<h2 id="可重入函数">可重入函数</h2>
<p>当程序在执行函数 A 时收到了某个信号，信号处理函数中也对函数 A 发起了调用，这样可能会影响之前还未完成调用的函数 A 执行状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#define BUF_SIZE 16  </span><span class="c1">// 全局静态数组大小；
</span><span class="c1"></span><span class="cp">#define FORMAT_NUM_(N) &#34; $&#34;#N
</span><span class="cp">#define FORMAT_NUM(N) FORMAT_NUM_(N)
</span><span class="cp">#define RAISE_EXP_false_ASM()
</span><span class="cp"></span><span class="c1">// 调用 raise 函数向当前程序发送信号；
</span><span class="c1"></span><span class="cp">#define RAISE_EXP_true_ASM() \
</span><span class="cp">  &#34;movl    $4, %%edi\n\t&#34; \
</span><span class="cp">  &#34;call    raise\n\t&#34;
</span><span class="cp"></span><span class="c1">// 内联汇编实现；
</span><span class="c1"></span><span class="cp">#define INLINE_ASM(ID, HAS_EXP) \
</span><span class="cp">  &#34;mov     %0, %%r8\n\t&#34; </span><span class="cm">/* 复制传入的字符串数据到全局静态数组 */</span><span class="cp"> \
</span><span class="cp">  &#34;testq   %%rsi, %%rsi\n\t&#34; \
</span><span class="cp">  &#34;je      .L1&#34; #ID &#34;\n\t&#34; \
</span><span class="cp">  &#34;xorl    %%eax, %%eax\n\t&#34; \
</span><span class="cp">  &#34;.L3&#34; #ID &#34;:\n\t&#34; \
</span><span class="cp">  &#34;movzbl  (%%rdi,%%rax), %%ecx\n\t&#34; \
</span><span class="cp">  &#34;movb    %%cl, (%%r8,%%rax)\n\t&#34; \
</span><span class="cp">  &#34;addq    $1, %%rax\n\t&#34; \
</span><span class="cp">  &#34;cmpq    %%rsi, %%rax\n\t&#34; \
</span><span class="cp">  &#34;jne     .L3&#34; #ID &#34;\n\t&#34; \
</span><span class="cp">  &#34;.L1&#34; #ID &#34;:\n\t&#34; \
</span><span class="cp">  RAISE_EXP_##HAS_EXP##_ASM() </span><span class="cm">/* 选择性调用 raise 函数 */</span><span class="cp"> \
</span><span class="cp">  &#34;mov     $1, %%rax\n\t&#34; \
</span><span class="cp">  &#34;mov     $1, %%rdi\n\t&#34; \
</span><span class="cp">  &#34;mov     %0, %%rsi\n\t&#34; \
</span><span class="cp">  &#34;mov&#34; FORMAT_NUM(BUF_SIZE) &#34;, %%rdx\n\t&#34; \
</span><span class="cp">  &#34;syscall\n\t&#34;  </span><span class="cm">/* 触发系统调用，打印内容 */</span><span class="cp">
</span><span class="cp"></span>  
<span class="k">static</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>  <span class="c1">// 用于保存字符的全局静态数组；
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">print_with_exp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 会引起信号中断的版本；
</span><span class="c1"></span>  <span class="k">asm</span><span class="p">(</span><span class="n">INLINE_ASM</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">::</span> <span class="s">&#34;g&#34;</span> <span class="p">(</span><span class="n">buf</span><span class="p">));</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">print_normal</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 正常的版本；
</span><span class="c1"></span>  <span class="k">asm</span><span class="p">(</span><span class="n">INLINE_ASM</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="o">::</span> <span class="s">&#34;g&#34;</span> <span class="p">(</span><span class="n">buf</span><span class="p">));</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">sigHandler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;Hello&#34;</span><span class="p">;</span>
  <span class="n">print_normal</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">signal</span><span class="p">(</span><span class="n">SIGILL</span><span class="p">,</span> <span class="n">sigHandler</span><span class="p">);</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;, world!&#34;</span><span class="p">;</span>
  <span class="n">print_with_exp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="/image/learn_c/15_2.webp" alt="reentrant_function"></p>
<p>不受中断和重新调用影响的函数称之为可重入函数</p>
<h2 id="多线程信号处理">多线程信号处理</h2>
<p>C 语言没有对并发编程的信号处理做规范，所以多线程应用中使用 signal 和 raise 函数会产生未定义的行为</p>
<h1 id="第十六讲-日期时间与实用函数">第十六讲 日期、时间与实用函数</h1>
<h2 id="日期与时间">日期与时间</h2>
<h3 id="日历时间">日历时间</h3>
<p>使用 time_t 类型表示，其代表从 1970-01-01: 00:00:00 到当前时间秒数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">time_t</span> <span class="n">currTime</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">currTime</span> <span class="o">!=</span> <span class="p">(</span><span class="n">time_t</span><span class="p">)</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;the current timestamp is: %ld(s)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">currTime</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;local time is: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">asctime</span><span class="p">(</span><span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">currTime</span><span class="p">)));</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;UTC time is: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">asctime</span><span class="p">(</span><span class="n">gmtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">currTime</span><span class="p">)));</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="处理器时间">处理器时间</h3>
<p>处理器时间即 CPU 资源被调度以支持程序在某段时间内正常运作所花费的时间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">clock_t</span> <span class="n">startTime</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>    
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">clock_t</span> <span class="n">endTime</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Consumed CPU time is：%fs</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> 
   <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">);</span> 
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><h3 id="字符串到数值的转换">字符串到数值的转换</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 一次性字符串到数值转换；
</span><span class="c1"></span>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">strA</span> <span class="o">=</span> <span class="s">&#34;1.0&#34;</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">atof</span><span class="p">(</span><span class="n">strA</span><span class="p">));</span>
  <span class="c1">// 带溢出检查的转换函数，执行后会保存不能被转换部分的地址；
</span><span class="c1"></span>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">strB</span> <span class="o">=</span> <span class="s">&#34;200000000000000000000000000000.0&#34;</span><span class="p">;</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">end</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">num</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">strB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">ERANGE</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 判断转换结果是否发生溢出；
</span><span class="c1"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Range error, got: &#34;</span><span class="p">);</span>
    <span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="生成随机数">生成随机数</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt; </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt; </span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt; </span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>  <span class="c1">// 初始化随机数种子；
</span><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">getchar</span><span class="p">()</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> 
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span>  <span class="c1">// 生成并打印 0-9 的随机数；
</span><span class="c1"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="动态内存管理">动态内存管理</h3>
<p>除了 malloc 和 free 函数之外，C 标准库也提供了另外的一些函数</p>
<p><img src="/image/learn_c/16_1.webp" alt="alloc_function"></p>
<h3 id="进程控制">进程控制</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">exitHandler</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getenv</span><span class="p">(</span><span class="s">&#34;PATH&#34;</span><span class="p">));</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atexit</span><span class="p">(</span><span class="n">exitHandler</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="/image/learn_c/16_2.webp" alt="process_control"></p>
<h1 id="第十七讲-断言错误处理和对齐">第十七讲 断言、错误处理和对齐</h1>
<h2 id="断言-1">断言</h2>
<p>断言分为静态断言和动态断言</p>
<p>一般我们在程序运行前使用静态断言，来检查它所需要满足的一系列要求</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">double</span> <span class="nf">sqrt</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 检查函数使用时传入的参数；
</span><span class="c1"></span>  <span class="n">assert</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">);</span>
  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 检查程序的编译要求；
</span><span class="c1"></span>  <span class="n">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">,</span> 
    <span class="s">&#34;Integer should have at least 4 bytes length.&#34;</span><span class="p">);</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>定义 <code>NDEBUG</code> 宏可关闭断言功能</p>
<h2 id="错误处理">错误处理</h2>
<p>在 C 语言中，名为 errno 的预处理宏会被展开为一个 init 类型的可修改全局左值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;tgmath.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>  <span class="c1">// &#34;Numerical argument out of domain&#34;.
</span><span class="c1"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以通过 strerror 函数获取当前 errno 对应的可读文本</p>
<h2 id="对齐">对齐</h2>
<p>可以使用 _Alignas 来根据自身需要为数据指定特殊的对齐要求，stdalign.h 有
对应的宏 alignas</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdalign.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if __alignas_is_defined == 1 &amp;&amp; __alignof_is_defined == 1
</span><span class="cp"></span>  <span class="n">alignas</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;The alignment of n is %zu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">alignof</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>  <span class="c1">// &#34;The alignment of n is 1024&#34;.
</span><span class="c1"></span>  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;The address of n is: %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>  <span class="c1">// &#34;The address of n is: 0x7ffe80658c00&#34;.
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="第十八讲-极致优化上">第十八讲 极致优化（上）</h1>
<h2 id="高速缓存">高速缓存</h2>
<p>CPU 芯片上有 L1、L2、L3 三个不同级别的高速缓存</p>
<p>高速缓存之所以能提升性能，一个重要的前提在于局部性原理</p>
<ul>
<li>时间局部性：被引用过一次的内存位置接下来可能会被再次引用</li>
<li>空间局部性：如果一个内存位置被引用了，那附近的内存也可能会被引用</li>
</ul>
<h2 id="内联">内联</h2>
<p>通过内联关键字 inline ，可以建议编译器，将某个方法的实现内联到它的实际调用处。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Output is: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码对应的汇编代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">.LC0:</span>
        <span class="na">.string</span> <span class="s">&#34;Output is: %d\n&#34;</span>
<span class="nl">main:</span>
        <span class="nf">sub</span>     <span class="no">rsp</span><span class="p">,</span> <span class="mi">8</span>
        <span class="nf">mov</span>     <span class="no">esi</span><span class="p">,</span> <span class="mi">10</span>
        <span class="nf">mov</span>     <span class="no">edi</span><span class="p">,</span> <span class="no">OFFSET</span> <span class="no">FLAT</span><span class="p">:.</span><span class="no">LC0</span>
        <span class="nf">xor</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">eax</span>
        <span class="nf">call</span>    <span class="no">printf</span>
        <span class="nf">xor</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">eax</span>
        <span class="nf">add</span>     <span class="no">rsp</span><span class="p">,</span> <span class="mi">8</span>
        <span class="nf">ret</span>
</code></pre></td></tr></table>
</div>
</div><p>通过内联，程序不再需要使用 call 指令来调用 foo 函数，好处在于节省 call 指令执行时需要进行的函数帧栈创建和销毁过程。坏处是导致可执行二进制文件增大</p>
<h2 id="restrict关键字">restrict关键字</h2>
<p>restrict 关键字用于指针，表明该指针是访问对应数据的唯一方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="kr">restrict</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">x</span> <span class="o">+=</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
  <span class="o">*</span><span class="n">y</span> <span class="o">+=</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
  <span class="n">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d %d %d&#34;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对应的汇编代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">foo:</span>
        <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">DWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdx</span><span class="p">]</span>
        <span class="nf">add</span>     <span class="no">DWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="p">],</span> <span class="no">eax</span>
        <span class="nf">add</span>     <span class="no">DWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rsi</span><span class="p">],</span> <span class="no">eax</span>
        <span class="nf">ret</span>
</code></pre></td></tr></table>
</div>
</div><p>使用restrict 关键字后，在为指针 y 进行 值累加前，编译器不会再重复性地从内存中读取指针 z 对应的值</p>
<h2 id="消除不需要的内存引用">消除不需要的内存引用</h2>
<p>原代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#define LEN 1024
</span><span class="cp"></span><span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">dest</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>优化代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#define LEN 3
</span><span class="cp"></span><span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span> <span class="p">};</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">dest</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">acc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">acc</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>优化代码主要做了两件事情：</p>
<ol>
<li>将用于存放临时积累值的 <code>*dest</code> 替换为局部变量</li>
<li>为局部变量添加 register 关键字，建议编译器将该值存放在寄存器中</li>
</ol>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">PPD</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2022-04-17
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://ppd0705.github.io/tags/c/">C</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/2021_summary/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">2021年终总结</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/noip_expirence/">
            <span class="next-text nav-default">非典型 NOIP 经历</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "ppd0705/ppd0705.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="ppd0705@icloud.com" rel="me noopener" class="iconfont"
      title="email"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://twitter.com/ppd0705" rel="me noopener" class="iconfont"
      title="twitter"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1264 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M1229.8616 18.043658c0 0-117.852626 63.135335-164.151872 67.344358-105.225559-164.151872-505.082682-92.598492-437.738325 223.078185C278.622548 312.675223 89.216542 47.506814 89.216542 47.506814s-117.852626 189.406006 75.762402 345.139833C127.097743 396.85567 55.544363 371.601535 55.544363 371.601535S26.081207 535.753407 253.368414 615.724832c-21.045112 29.463156-113.643603 8.418045-113.643603 8.418045s25.254134 143.10676 231.496229 180.987961c-143.10676 130.479693-387.230056 92.598492-370.393967 105.225559 206.242095 189.406006 1119.599946 231.496229 1128.01799-643.98042C1179.353331 249.539887 1263.533778 123.269217 1263.533778 123.269217s-130.479693 37.881201-138.897738 33.672179C1225.652577 98.015083 1229.8616 18.043658 1229.8616 18.043658"></path>
</svg>

    </a>
  
    <a href="https://github.com/ppd0705" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>
  
    <a href="https://www.douban.com/people/ppd0705/" rel="me noopener" class="iconfont"
      title="douban"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M926.917973 37.80608C959.65184 37.80608 986.19392 64.34816 986.19392 97.082027L986.19392 926.917973C986.19392 959.65184 959.65184 986.19392 926.917973 986.19392L97.082027 986.19392C64.34816 986.19392 37.80608 959.65184 37.80608 926.917973L37.80608 97.082027C37.80608 64.34816 64.34816 37.80608 97.082027 37.80608zM176.653653 176.19968 176.653653 252.678827 825.658027 252.678827 825.658027 176.19968zM217.719467 316.146347 217.719467 628.08064 273.524053 628.08064 341.292373 770.39616 157.259093 770.39616 157.259093 845.417813 842.949973 845.417813 842.949973 770.39616 654.226773 770.39616 722.899627 628.08064 783.67744 628.08064 783.67744 316.146347zM684.885333 392.891733 684.885333 553.987413 312.576 553.987413 312.576 392.891733zM570.770773 770.39616 426.653013 770.39616 359.621973 628.08064 639.443627 628.08064z"></path>
</svg>

    </a>


<a href="https://ppd0705.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2019 -
    2022
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        PPD
        
      </span></span>

  
  
    <span id="busuanzi_container">
      访客数/访问量：<span id="busuanzi_value_site_uv"></span>/<span id="busuanzi_value_site_pv"></span>
    </span>
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>












</body>
</html>
