<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>[笔记]深入C语言和程序运行原理 - PPD&#39;s blog</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="PPD" />
  <meta name="description" content="第零讲 课前热身 数据量单位 位（bit）： 是最小存储单位，每个位可以存一个二进制码值得 0 或 1 字节（byte）： 通常是由八个位组成的一个存储单元，" />

  <meta name="keywords" content="PPD, blog" />






<meta name="generator" content="Hugo 0.108.0" />


<link rel="canonical" href="https://ppd0705.github.io/post/learn_c/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.b3a8813c06e6d785beba22bf8264e174fa2cb3a396b22f9ba24e2c00c18aaf7f.css" integrity="sha256-s6iBPAbm14W&#43;uiK/gmThdPoss6OWsi&#43;bok4sAMGKr38=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="[笔记]深入C语言和程序运行原理" />
<meta property="og:description" content="第零讲 课前热身 数据量单位 位（bit）： 是最小存储单位，每个位可以存一个二进制码值得 0 或 1 字节（byte）： 通常是由八个位组成的一个存储单元，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ppd0705.github.io/post/learn_c/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-01-31T17:04:50+08:00" />
<meta property="article:modified_time" content="2022-05-08T17:45:50+08:00" />
<meta itemprop="name" content="[笔记]深入C语言和程序运行原理">
<meta itemprop="description" content="第零讲 课前热身 数据量单位 位（bit）： 是最小存储单位，每个位可以存一个二进制码值得 0 或 1 字节（byte）： 通常是由八个位组成的一个存储单元，"><meta itemprop="datePublished" content="2022-01-31T17:04:50+08:00" />
<meta itemprop="dateModified" content="2022-05-08T17:45:50+08:00" />
<meta itemprop="wordCount" content="21947">
<meta itemprop="keywords" content="C," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[笔记]深入C语言和程序运行原理"/>
<meta name="twitter:description" content="第零讲 课前热身 数据量单位 位（bit）： 是最小存储单位，每个位可以存一个二进制码值得 0 或 1 字节（byte）： 通常是由八个位组成的一个存储单元，"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">PPD's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/about">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      PPD's blog
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/about">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">[笔记]深入C语言和程序运行原理</h1>
      
      <div class="post-meta">
        <time datetime="2022-01-31" class="post-time">
          2022-01-31
        </time>
        <div class="post-category">
            <a href="https://ppd0705.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"> 计算机 </a>
            
          </div>
        <span class="more-meta"> 21947 words </span>
          <span class="more-meta"> 44 min read </span>

        
        
          <span id="busuanzi_container_page_pv">
            | 阅读 <span id="busuanzi_value_page_pv"></span>
          </span>
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#第零讲-课前热身">第零讲 课前热身</a>
      <ul>
        <li><a href="#数据量单位">数据量单位</a></li>
        <li><a href="#汇编语言">汇编语言</a></li>
        <li><a href="#寄存器">寄存器</a></li>
      </ul>
    </li>
    <li><a href="#第一讲-一个c程序的完整生命周期">第一讲 一个C程序的完整生命周期</a>
      <ul>
        <li><a href="#c核心语法">C核心语法</a>
          <ul>
            <li><a href="#入口函数">入口函数</a></li>
            <li><a href="#数组">数组</a></li>
            <li><a href="#结果体和联合体">结果体和联合体</a></li>
            <li><a href="#控制语句">控制语句</a></li>
            <li><a href="#指针">指针</a></li>
            <li><a href="#宏">宏</a></li>
            <li><a href="#断言">断言</a></li>
            <li><a href="#函数内联">函数内联</a></li>
          </ul>
        </li>
        <li><a href="#c-语言编程范式">C 语言编程范式</a></li>
        <li><a href="#编译和运行">编译和运行</a></li>
      </ul>
    </li>
    <li><a href="#第二讲-数据和量值">第二讲 数据和量值</a>
      <ul>
        <li><a href="#量值">量值</a>
          <ul>
            <li><a href="#变量">变量</a></li>
            <li><a href="#常量">常量</a></li>
          </ul>
        </li>
        <li><a href="#数据的存储形式">数据的存储形式</a>
          <ul>
            <li><a href="#补码">补码</a></li>
            <li><a href="#ieee-754">IEEE-754</a></li>
          </ul>
        </li>
        <li><a href="#数据的存储位置">数据的存储位置</a></li>
      </ul>
    </li>
    <li><a href="#第三讲-运算符">第三讲 运算符</a>
      <ul>
        <li><a href="#运算符分类">运算符分类</a></li>
        <li><a href="#算数关系为赋值运算">算数、关系、为、赋值运算</a></li>
        <li><a href="#逻辑运算符">逻辑运算符</a></li>
        <li><a href="#成员访问运算符">成员访问运算符</a></li>
        <li><a href="#其他运算符">其他运算符</a></li>
      </ul>
    </li>
    <li><a href="#第四讲-控制逻辑">第四讲 控制逻辑</a>
      <ul>
        <li><a href="#表达式">表达式</a></li>
        <li><a href="#语句">语句</a>
          <ul>
            <li><a href="#选择语句">选择语句</a></li>
            <li><a href="#迭代语句">迭代语句</a></li>
            <li><a href="#跳转语句">跳转语句</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第五讲-函数调用上">第五讲 函数调用（上）</a>
      <ul>
        <li><a href="#快速回顾">快速回顾</a></li>
        <li><a href="#c-函数的调用约定">C 函数的调用约定</a></li>
        <li><a href="#参数约定">参数约定</a></li>
        <li><a href="#返回值传递">返回值传递</a></li>
        <li><a href="#寄存器使用">寄存器使用</a></li>
        <li><a href="#堆栈清理">堆栈清理</a></li>
        <li><a href="#其他约定">其他约定</a></li>
        <li><a href="#保存函数调用信息的栈帧">保存函数调用信息的栈帧</a></li>
      </ul>
    </li>
    <li><a href="#第六讲-函数调用下">第六讲 函数调用（下）</a>
      <ul>
        <li><a href="#函数参数求值顺序">函数参数求值顺序</a></li>
        <li><a href="#尾递归调用优化tail-call-optimization">尾递归调用优化（tail-call optimization）</a></li>
        <li><a href="#kr-函数声明">K&amp;R 函数声明</a></li>
      </ul>
    </li>
    <li><a href="#第七讲-枚举结构和联合是如何实现的">第七讲 枚举、结构和联合是如何实现的？</a>
      <ul>
        <li><a href="#枚举-enumeration">枚举 Enumeration</a></li>
        <li><a href="#结构-struct">结构 Struct</a>
          <ul>
            <li><a href="#内存数据对齐">内存数据对齐</a></li>
            <li><a href="#填充字节">填充字节</a></li>
          </ul>
        </li>
        <li><a href="#联合-union">联合 Union</a></li>
      </ul>
    </li>
    <li><a href="#第八讲-指针是如何灵活使用内存的">第八讲 指针是如何灵活使用内存的</a>
      <ul>
        <li><a href="#指针的基本使用">指针的基本使用</a></li>
        <li><a href="#指针和数组">指针和数组</a></li>
        <li><a href="#指针的其他运算">指针的其他运算</a>
          <ul>
            <li><a href="#算术运算">算术运算</a></li>
            <li><a href="#关系运算">关系运算</a></li>
          </ul>
        </li>
        <li><a href="#堆内存指针">堆内存指针</a></li>
      </ul>
    </li>
    <li><a href="#第九讲-预处理器">第九讲 预处理器</a>
      <ul>
        <li><a href="#预处理流程">预处理流程</a></li>
        <li><a href="#宏函数常用技巧">宏函数常用技巧</a>
          <ul>
            <li><a href="#为返回值添加括号">为返回值添加括号</a></li>
            <li><a href="#为参数添加括号">为参数添加括号</a></li>
            <li><a href="#警惕多次副作用">警惕多次副作用</a></li>
            <li><a href="#定义完备的多语句宏函数">定义完备的多语句宏函数</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第十讲-字符字符串与数学计算">第十讲 字符、字符串与数学计算</a>
      <ul>
        <li><a href="#字符和字符串">字符和字符串</a>
          <ul>
            <li><a href="#字符">字符</a></li>
            <li><a href="#字符串">字符串</a></li>
          </ul>
        </li>
        <li><a href="#字符库函数">字符库函数</a>
          <ul>
            <li><a href="#统计字符串长度">统计字符串长度</a></li>
            <li><a href="#拼接字符串">拼接字符串</a></li>
            <li><a href="#拷贝字符串">拷贝字符串</a></li>
            <li><a href="#格式化字符串">格式化字符串</a></li>
            <li><a href="#字符的判断和转换">字符的判断和转换</a></li>
          </ul>
        </li>
        <li><a href="#数学运算库函数">数学运算库函数</a></li>
      </ul>
    </li>
    <li><a href="#第十一讲-io-标准库">第十一讲 IO 标准库</a>
      <ul>
        <li><a href="#基本使用">基本使用</a></li>
        <li><a href="#接口级别">接口级别</a></li>
        <li><a href="#低级-io-背后的系统调用">低级 IO 背后的系统调用</a></li>
      </ul>
    </li>
    <li><a href="#第十二讲-非本地跳转和可变参数实现原理">第十二讲 非本地跳转和可变参数实现原理</a>
      <ul>
        <li><a href="#本地跳转">本地跳转</a></li>
        <li><a href="#setjmp-和-longjmp-函数">setjmp 和 longjmp 函数</a>
          <ul>
            <li><a href="#运作原理">运作原理</a></li>
            <li><a href="#自定义实现">自定义实现</a></li>
          </ul>
        </li>
        <li><a href="#可变参数">可变参数</a>
          <ul>
            <li><a href="#基本使用-1">基本使用</a></li>
            <li><a href="#运作原理-1">运作原理</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第十三讲-c-并发编程">第十三讲 C 并发编程</a>
      <ul>
        <li><a href="#进程-vs-线程">进程 vs 线程</a></li>
        <li><a href="#线程的基本控制">线程的基本控制</a></li>
        <li><a href="#数据竞争">数据竞争</a></li>
        <li><a href="#竞态条件">竞态条件</a></li>
        <li><a href="#指令重排">指令重排</a></li>
      </ul>
    </li>
    <li><a href="#第十四讲-如何协调线程">第十四讲 如何协调线程</a>
      <ul>
        <li><a href="#互斥量">互斥量</a></li>
        <li><a href="#原子操作">原子操作</a></li>
        <li><a href="#条件变量">条件变量</a></li>
        <li><a href="#本地变量">本地变量</a></li>
      </ul>
    </li>
    <li><a href="#第十五讲-信号">第十五讲 信号</a>
      <ul>
        <li><a href="#什么是信号">什么是信号</a></li>
        <li><a href="#信号与软中断">信号与软中断</a></li>
        <li><a href="#c-代码样例">C 代码样例</a></li>
        <li><a href="#可重入函数">可重入函数</a></li>
        <li><a href="#多线程信号处理">多线程信号处理</a></li>
      </ul>
    </li>
    <li><a href="#第十六讲-日期时间与实用函数">第十六讲 日期、时间与实用函数</a>
      <ul>
        <li><a href="#日期与时间">日期与时间</a>
          <ul>
            <li><a href="#日历时间">日历时间</a></li>
            <li><a href="#处理器时间">处理器时间</a></li>
            <li><a href="#字符串到数值的转换">字符串到数值的转换</a></li>
            <li><a href="#生成随机数">生成随机数</a></li>
            <li><a href="#动态内存管理">动态内存管理</a></li>
            <li><a href="#进程控制">进程控制</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第十七讲-断言错误处理和对齐">第十七讲 断言、错误处理和对齐</a>
      <ul>
        <li><a href="#断言-1">断言</a></li>
        <li><a href="#错误处理">错误处理</a></li>
        <li><a href="#对齐">对齐</a></li>
      </ul>
    </li>
    <li><a href="#第十八讲-极致优化上">第十八讲 极致优化（上）</a>
      <ul>
        <li><a href="#高速缓存">高速缓存</a></li>
        <li><a href="#内联">内联</a></li>
        <li><a href="#restrict关键字">restrict关键字</a></li>
        <li><a href="#消除不需要的内存引用">消除不需要的内存引用</a></li>
      </ul>
    </li>
    <li><a href="#第十九讲-极致优化下">第十九讲 极致优化（下）</a>
      <ul>
        <li><a href="#循环展开loop-unrolling">循环展开（Loop Unrolling）</a></li>
        <li><a href="#优先使用条件传送指令">优先使用条件传送指令</a></li>
        <li><a href="#使用更高的编译优化等级">使用更高的编译优化等级</a></li>
        <li><a href="#尾递归优化">尾递归优化</a></li>
      </ul>
    </li>
    <li><a href="#第二十讲-编码规范">第二十讲 编码规范</a>
      <ul>
        <li><a href="#格式">格式</a></li>
        <li><a href="#注释">注释</a></li>
        <li><a href="#语法约定">语法约定</a></li>
        <li><a href="#命名">命名</a></li>
        <li><a href="#国际化">国际化</a></li>
      </ul>
    </li>
    <li><a href="#第二十一讲-自动化测试">第二十一讲 自动化测试</a>
      <ul>
        <li><a href="#单元测试">单元测试</a></li>
        <li><a href="#集成测试">集成测试</a></li>
        <li><a href="#功能测试">功能测试</a></li>
        <li><a href="#性能测试">性能测试</a></li>
      </ul>
    </li>
    <li><a href="#第二十二讲-结构化编译">第二十二讲 结构化编译</a>
      <ul>
        <li><a href="#如何组织代码结构">如何组织代码结构</a></li>
        <li><a href="#如何组织编译流程">如何组织编译流程</a></li>
        <li><a href="#使用-makefile-进行结构化编译">使用 Makefile 进行结构化编译</a></li>
        <li><a href="#使用-cmake-进行跨平台自动化构建">使用 CMake 进行跨平台自动化构建</a></li>
      </ul>
    </li>
    <li><a href="#第二十三讲-高性能-http-server-实战上">第二十三讲 高性能 HTTP Server 实战（上）</a></li>
    <li><a href="#第二十四讲-高性能-http-server-实战下">第二十四讲 高性能 HTTP Server 实战（下）</a>
      <ul>
        <li><a href="#项目基本结构">项目基本结构</a></li>
        <li><a href="#处理用户参数">处理用户参数</a></li>
        <li><a href="#tcp-server">TCP Server</a>
          <ul>
            <li><a href="#监听请求">监听请求</a></li>
          </ul>
        </li>
        <li><a href="#解析请求">解析请求</a></li>
        <li><a href="#计算斐波那契数列">计算斐波那契数列</a></li>
      </ul>
    </li>
    <li><a href="#第二十五讲-可执行二进制文件">第二十五讲 可执行二进制文件</a>
      <ul>
        <li><a href="#elf-文件格式">ELF 文件格式</a></li>
        <li><a href="#elf-头">ELF 头</a></li>
        <li><a href="#section-头">Section 头</a></li>
        <li><a href="#program-头">Program 头</a></li>
        <li><a href="#elf-编程">ELF 编程</a></li>
        <li><a href="#elf-文件类型">ELF 文件类型</a></li>
      </ul>
    </li>
    <li><a href="#第二十六讲-进程如何使用操作系统内存">第二十六讲 进程如何使用操作系统内存</a>
      <ul>
        <li><a href="#计算机内部缓存系统">计算机内部缓存系统</a></li>
        <li><a href="#虚拟内存机制">虚拟内存机制</a></li>
        <li><a href="#vas-数据布局">VAS 数据布局</a></li>
        <li><a href="#页表">页表</a></li>
        <li><a href="#多级页表">多级页表</a></li>
        <li><a href="#tlb">TLB</a></li>
      </ul>
    </li>
    <li><a href="#第二十七讲-静态链接">第二十七讲 静态链接</a>
      <ul>
        <li><a href="#目标文件">目标文件</a></li>
        <li><a href="#符号解析">符号解析</a></li>
        <li><a href="#重定位">重定位</a></li>
      </ul>
    </li>
    <li><a href="#第二十八讲-动态链接">第二十八讲 动态链接</a>
      <ul>
        <li><a href="#共享库">共享库</a></li>
        <li><a href="#使用示例">使用示例</a></li>
        <li><a href="#位置无关代码">位置无关代码</a></li>
        <li><a href="#全局偏移表">全局偏移表</a></li>
        <li><a href="#过程链接表">过程链接表</a></li>
        <li><a href="#加载时链接">加载时链接</a></li>
        <li><a href="#运行时链接">运行时链接</a></li>
      </ul>
    </li>
    <li><a href="#第二十九讲-c-程序入口">第二十九讲 C 程序入口</a>
      <ul>
        <li><a href="#真正的入口函数">真正的入口函数</a>
          <ul>
            <li><a href="#_start">_start</a></li>
            <li><a href="#_start-作用">_start 作用</a></li>
          </ul>
        </li>
        <li><a href="#crt">CRT</a></li>
      </ul>
    </li>
    <li><a href="#第三十讲-abi-和-api">第三十讲 ABI 和 API</a>
      <ul>
        <li><a href="#api">API</a></li>
        <li><a href="#abi">ABI</a></li>
      </ul>
    </li>
    <li><a href="#第三十一讲-程序和操作系统交互">第三十一讲 程序和操作系统交互</a>
      <ul>
        <li><a href="#什么是系统调用">什么是系统调用</a></li>
        <li><a href="#系统调用和用户函数">系统调用和用户函数</a></li>
        <li><a href="#系统调用实现">系统调用实现</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h1 id="第零讲-课前热身">第零讲 课前热身</h1>
<h2 id="数据量单位">数据量单位</h2>
<p>位（bit）： 是最小存储单位，每个位可以存一个二进制码值得 0 或 1
字节（byte）： 通常是由八个位组成的一个存储单元，是计算机最小的可寻址单位
位（word）：是处理器使用的自然数据单位，处理器单个指令可以操作的最大的内存块
一般为一个字节大小</p>
<h2 id="汇编语言">汇编语言</h2>
<p>汇编语言（Assembly Language）是一种低级编程语言，和 CPU 架构相关。</p>
<p>汇编语言使用助记符（Mnemonic）来表示每个低级的机器指令，不同的汇编指令可以使用不同的参数形式，以 mov 指令举例，有如下三种形式：</p>
<ul>
<li>mov r/m, r</li>
<li>mov r, r/m</li>
<li>mov r/m, imm</li>
</ul>
<p>指令参数中，r 表示 寄存器（register），m 表示内存（memory），imm 表示立即数（immediate）。
指令<code>mov ebx 1</code>的含义是将立即数 1 存到寄存器 ebx 中。
在x86指令集中，受限于 CPU 实现的复杂的，不存在将两个内存地址同时作为 src 和 dest 参数的指令。</p>
<p>指令<code>mov ebx 1</code>对应的机器码为 <code>bb 01 00 00 00</code>
机器码由 OpCode 和 Immediata Data 两部分组成，OpCode 占用一个字节，mov 对应的指令是 0xb8，寄存器对应阈值为 0x3， 组合在一起即为 0xbb；由于 mov 传送 32 位数，所以立即数单独占用 4 个字节 （使用小端序）</p>
<h2 id="寄存器">寄存器</h2>
<p>寄存器可以简单理解为 CPU 提供的一组由位于芯片上的高速存储器硬件，拥有最快的数据访问速度和最低的延迟</p>
<p>寄存器通常分为如下几类：</p>
<ul>
<li>统一寄存器：一般存放程序运行过程中产生的临时数据</li>
<li>状态寄存器：一般存放之间执行结果相关的状态信息，如指令是否引起进位等</li>
<li>系统寄存器：一般由操作系统使用，存放中断、CPU模式等信息</li>
</ul>
<p>x86-64 架构中定义了 16 个通用寄存器，每个寄存器可以存放4个指令字（每个指令字16字节）</p>
<p>在汇编代码中，可以使用每个寄存器的不同别名来访问对应的低 8 位，低 16 位，低 32 位，以及完整的 64 位数据</p>
<p><img src="/image/learn_c/0_1.jpg" alt="register_alias"></p>
<p>需要注意的是当重写寄存器的低32位数据时，高32位数据会被置零，可以使用如下代码进行对比。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">register</span> <span class="kt">long</span> <span class="n">num</span> <span class="k">asm</span><span class="p">(</span><span class="s">&#34;rax&#34;</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x100000000</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">asm</span><span class="p">(</span><span class="s">&#34;movl $0x1, %eax&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// asm(&#34;movw $0x1, %ax&#34;);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="第一讲-一个c程序的完整生命周期">第一讲 一个C程序的完整生命周期</h1>
<h2 id="c核心语法">C核心语法</h2>
<p>实例程序如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt; </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define BOOL_TRUE 1  </span><span class="c1">// 定义用到的宏常量与宏函数；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define BOOL_FALSE 0
</span></span></span><span class="line"><span class="cl"><span class="cp">#define typename(x) _Generic((x), \
</span></span></span><span class="line"><span class="cl"><span class="cp">  unsigned short: &#34;unsigned short int&#34;, \
</span></span></span><span class="line"><span class="cl"><span class="cp">  unsigned long: &#34;unsigned long int&#34;, \
</span></span></span><span class="line"><span class="cl"><span class="cp">  default: &#34;unknown&#34;)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">Host</span><span class="p">,</span> <span class="n">IP</span> <span class="p">}</span> <span class="n">IP_ADDR_TYPE</span><span class="p">;</span>  <span class="c1">// 定义枚举类型 IP_ADDR_TYPE，用于表示联合中生效的字段；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>  <span class="c1">// 定义结构 CONN；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">size_t</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">uint16_t</span> <span class="n">port</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">closed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">IP_ADDR_TYPE</span> <span class="n">addr_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">host_name</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">ip</span><span class="p">[</span><span class="mi">24</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">CONN</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">inline</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">findAddr</span><span class="p">(</span><span class="k">const</span> <span class="n">CONN</span><span class="o">*</span> <span class="n">pip</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 定义函数 findAddr，用于打印 CONN 对象的信息；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">assert</span><span class="p">(</span><span class="n">pip</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// 运行时断言，判断传入的 CONN 指针是否有效；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="n">addr_type</span> <span class="o">==</span> <span class="n">Host</span> <span class="o">?</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="nl">host_name</span> <span class="p">:</span> <span class="n">pip</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>  <span class="c1">// 入口函数；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">CONN</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mh">0x400</span><span class="p">,</span> <span class="s">&#34;the size of CONN object exceeds limit.&#34;</span><span class="p">);</span>  <span class="c1">// 静态断言，判断 CONN 对象的大小是否符合要求；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="n">CONN</span> <span class="n">conns</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>  <span class="c1">// 构造一个数组，包含三个 CONN 对象；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="n">BOOL_TRUE</span><span class="p">,</span> <span class="n">IP</span><span class="p">,</span> <span class="p">{</span> <span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="s">&#34;127.0.0.1&#34;</span> <span class="p">}</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8080</span><span class="p">,</span> <span class="n">BOOL_FALSE</span><span class="p">,</span> <span class="n">IP</span><span class="p">,</span> <span class="p">{</span> <span class="p">.</span><span class="n">ip</span> <span class="o">=</span> <span class="s">&#34;192.168.1.1&#34;</span> <span class="p">}</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">8088</span><span class="p">,</span> <span class="n">BOOL_FALSE</span><span class="p">,</span> <span class="n">Host</span><span class="p">,</span> <span class="p">{</span> <span class="p">.</span><span class="n">host_name</span> <span class="o">=</span> <span class="s">&#34;http://localhost/&#34;</span> <span class="p">}</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">conns</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">CONN</span><span class="p">));</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 遍历上述 CONN 数组，并打印其中的内容；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#34;Port: %d</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#34;Host/Addr: %s</span><span class="se">\n</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#34;Internal type of `id` is: %s</span><span class="se">\n\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="n">conns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">port</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nf">findAddr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conns</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
</span></span><span class="line"><span class="cl">      <span class="kr">typename</span><span class="p">(</span><span class="n">conns</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="入口函数">入口函数</h3>
<p>使用 main 函数作为入口函数，返回值为 0 表示成功。</p>
<h3 id="数组">数组</h3>
<p>conns 即为数组</p>
<h3 id="结果体和联合体">结果体和联合体</h3>
<p>结果体中所有定义的字段对应内存连续排列
联合体中同时只有一个字段生效，分配的内存为最大字段占用内存</p>
<h3 id="控制语句">控制语句</h3>
<h3 id="指针">指针</h3>
<h3 id="宏">宏</h3>
<p>宏函数 typename 使用了 C11标准引入的 _Generic 关键字</p>
<h3 id="断言">断言</h3>
<p>断言分为静态断言和动态断言，静态断言在代码编译时进行检查</p>
<h3 id="函数内联">函数内联</h3>
<p>使用 inline 内联关键字，可以建议编译器将该函数的内部逻辑直接替换到函数的
调用位置处，以减少函数调用开销提升性能</p>
<h2 id="c-语言编程范式">C 语言编程范式</h2>
<p>C 语言属于命令式编程（Imperative Programing），这种范式更关注计算机完成任务所执行的具体步骤；与之对的另外一种编程范式为声明式编程（Declararive Programing），这种范式更倾向于表达计算逻辑。区别实例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 命令式
</span></span><span class="line"><span class="cl">#define ARR_LEN 5
</span></span><span class="line"><span class="cl">int main(void) { 
</span></span><span class="line"><span class="cl">  int arr[ARR_LEN] = { 1, 5, 10, 9, 0 };
</span></span><span class="line"><span class="cl">  for (int i = 0; i &lt; ARR_LEN; ++i) {
</span></span><span class="line"><span class="cl">    if (arr[i] &gt; 7) {
</span></span><span class="line"><span class="cl">      // save this element somewhere else.
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">  }
</span></span><span class="line"><span class="cl">  return 0;
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 声明式
</span></span><span class="line"><span class="cl">let arr = [1, 5, 10, 9, 0]
</span></span><span class="line"><span class="cl">let result = arr.filter(n =&gt; n &gt; 7)
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="编译和运行">编译和运行</h2>
<p><img src="/image/learn_c/1_1.webp" alt="compile"></p>
<ol>
<li>代码预处理：编译器会移除所有注释信息、处理宏指令。</li>
<li>编译优化：编译器优化源码，将代码编程成汇编格式。</li>
<li>汇编：编译器将汇编代码编译成操作系统使用的某种对象格式。</li>
<li>链接：编译器将依赖的对象文件进行整合，设置好程序中所有调用函数的正确地址，生成二进制执行文件。</li>
</ol>
<h1 id="第二讲-数据和量值">第二讲 数据和量值</h1>
<h2 id="量值">量值</h2>
<p>量值可以粗略地分为变量（Variable）和常量（constant）</p>
<h3 id="变量">变量</h3>
<p>C 语言变量类型占用的具体字节大小与程序运行所在的硬件体系结构紧密相关</p>
<h3 id="常量">常量</h3>
<p>在 C 语言中，通过内联方式直接写到源码中的字面量值一般被称为常量。</p>
<p>使用 const 关键字修饰的变量更接近于只读变量，不具有”常量表达式“属性，因此无法用来表示定长数组大小或使用在 case 语句中。
常量表达式在编译时被求值，而只读变量在运行时才被确定</p>
<h2 id="数据的存储形式">数据的存储形式</h2>
<p>计算机内部使用 补码（Two&rsquo;s-complement）存放有符号整数，使用对应的二进制来存放无符号整数，使用 IEEE-754 标准来存放浮点数。</p>
<h3 id="补码">补码</h3>
<p>一个补码所表示的实际数值，由负权重位的值（最高位）和正权重为的值求和。
如 1101，是及对应的值为 -3（-8 + 5）。
由此也得出四位补码的最小值为 -8（1000），最大值为 7（0111）。</p>
<h3 id="ieee-754">IEEE-754</h3>
<h2 id="数据的存储位置">数据的存储位置</h2>
<p><img src="/image/learn_c/2_1.webp" alt="data_store_position"></p>
<p>应用程序被正常加载前，需要将应用程序代码机器相关依赖数据映射到内存的某个位置，这段内存称之为进程的VAS（Virtual Address Space 虚拟地址空间）.</p>
<p>初始化的全局变量和静态变量和应用程序具有同样的生命周期，其值通常会被存放到进程VAS内的 .data 中。</p>
<p>局部变量存放于寄存器或者 VAS 的栈中</p>
<p>通过 malloc 创建的内存存放于 VAS 的堆中</p>
<p>未初始化的全局变量和静态变量存放于 VAS 的 .bss 中</p>
<p>常量会按照数据的大小和类型存放于 VAS的 .text （通常存放代码） 或 .rodata （通常存放只读数据） 中</p>
<p><img src="/image/learn_c/2_2.webp" alt="const_data_store_position"></p>
<h1 id="第三讲-运算符">第三讲 运算符</h1>
<p>运算符（operator）、表达式（expression）和语句（statement）是组成 C 语言程序的三个基本的语法结构，且一般依次呈包含关系。</p>
<h2 id="运算符分类">运算符分类</h2>
<p><img src="/image/learn_c/3_2.webp" alt="operator_class"></p>
<h2 id="算数关系为赋值运算">算数、关系、为、赋值运算</h2>
<p>这四类运算符经过编译后，可以直接对应到由目标平台上相应的机器指令组成的简单计算逻辑。</p>
<p>拿下图的 foo 函数举例</p>
<p><img src="/image/learn_c/3_2.webp" alt="foo"></p>
<p><code>DWORD PRT [rbp-8]</code> 指 将寄存器 rbp 的值减去 8 得到的结果作为起始地址，然后操作一个 大小为 DWORD 的空间。intel体系中 WORD 表示 16 位，DWROD 表示 32 位，QWORD 表示 64 位。</p>
<p><code>int arithmetic = x + y;</code>对应的汇编代码中，前两行代码为分别从栈内存中将变量 x 和 y 存入 寄存器 edx 和 eax，接着通过 add 指令计算两者之和，最后通过 mov 指令将寄存器 eax 的值移到 局部变量 arithmetic 对应的栈内存中。</p>
<p>FLAGS 寄存器是一组用于反映程序当前运行状态的标志寄存器，详情如下</p>
<p><img src="/image/learn_c/3_3.webp" alt="flags_register"></p>
<p>cmp 指令会在 CPU 内部对两个操作数进行隐式减法运算，然后设置 FLAGS寄存器状态。</p>
<h2 id="逻辑运算符">逻辑运算符</h2>
<p>以与运算符 &amp;&amp; 举例，示例代码如下</p>
<p><img src="/image/learn_c/3_4.webp" alt="and_operator"></p>
<p>je 指令会判断 ZF 标志位是否为 0， 如果是则跳转到指定地址</p>
<p>与运算的高级编辑优化，编译器会采用 test、setne、movzx来实现，
这种方式减少了对栈内存即条件跳转指令的使用，是的程序减少了
访问内存时产生的延迟，以及由于分支预测失败导致的CPU周期延迟。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-as" data-lang="as"><span class="line"><span class="cl"><span class="nx">test</span>    <span class="nx">edi</span><span class="o">,</span> <span class="nx">edi</span>  <span class="o">;</span> <span class="nx">edi</span> <span class="o">&lt;-</span> <span class="nx">x</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">setne</span>   <span class="nx">al</span>
</span></span><span class="line"><span class="cl"><span class="nx">test</span>    <span class="nx">esi</span><span class="o">,</span> <span class="nx">esi</span>  <span class="o">;</span> <span class="nx">esi</span> <span class="o">&lt;-</span> <span class="nx">y</span><span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="nx">setne</span>   <span class="nx">sil</span>
</span></span><span class="line"><span class="cl"><span class="nx">movzx</span>   <span class="nx">esi</span><span class="o">,</span> <span class="nx">sil</span>
</span></span><span class="line"><span class="cl"><span class="nx">and</span>     <span class="nx">esi</span><span class="o">,</span> <span class="nx">eax</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="成员访问运算符">成员访问运算符</h2>
<p><img src="/image/learn_c/3_5.webp" alt="address_operator"></p>
<p><code>int* n_ptr = &amp;n;</code>对应的汇编指令中首先 lea 指令将寄存器 rbp 中的值减去 16 后，存放到 rax 寄存器，即将n在站上的地址存放到 rax 寄存器；然后将 rax 寄存器的值存到 变量 n_ptr对应的栈内存的存储位置。</p>
<p><code>int m = *n_ptr;</code>对应的汇编指令中首先将 n_ptr的值传送到 寄存器 ra；随后将 rax 的值作为地址，将该地址上的值以 DWORD（即 int）形式传送到 eax 寄存器；最后将 eax 寄存器中的结果只传送到 变量 m 在栈内存的存储位置。</p>
<h2 id="其他运算符">其他运算符</h2>
<p>这里介绍 <code>sizeof</code> 和 <code>(type)</code>，示例如下：</p>
<p><img src="/image/learn_c/3_6.webp" alt="other_operator"></p>
<p><code>size_t n = sizeof(int)</code> 的汇编指令可以看出直接将结果4存到了 n 对应的栈内存。</p>
<p><code>short f = (short) n;</code>的汇编指令首先将变量 n 的值移到 rax 寄存器，然后将其中低 16位的数据（ax）地道 f 所在的内存趋于</p>
<h1 id="第四讲-控制逻辑">第四讲 控制逻辑</h1>
<h2 id="表达式">表达式</h2>
<p>表达式（expression）是由一系列运算符和操作数（operand）组成的一种语法结构。</p>
<p>对表达式的求值过程，实际上就是根据运算符的优先级和结合性，来对表达式和它所包含的子表达式进行递归求值的过程。</p>
<p>可以使用<code>clang -Xclang -ast-dump -fsyntax-only main.c</code> 命令得到 C 程序对应的 AST 结构</p>
<h2 id="语句">语句</h2>
<p>语句（statement）是用来描述程序的基本构建块。</p>
<p>语句可以包含或者不含表达式；语句在执行时不返回任何结果；语句以分号结尾。</p>
<p>语句分为复合语句、表达式语句、选择语句、迭代语句、跳转语句。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 复合语句；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// 表达式语句；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 复合语句；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="n">sum</span> <span class="o">=</span> <span class="o">-</span><span class="n">sum</span><span class="p">;</span>  <span class="c1">// 表达式语句；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"> <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="选择语句">选择语句</h3>
<p><code>if...else</code> 语句示例如下：</p>
<p><img src="/image/learn_c/4_1.webp" alt="if_else_statement"></p>
<p><code>switch...case</code>语句示例如下：</p>
<p><img src="/image/learn_c/4_2.webp" alt="switch_case_statement"></p>
<h3 id="迭代语句">迭代语句</h3>
<p>迭代语句主要包含 <code>do...while</code>、<code>for</code>、<code>while</code> 三种形式，u示例如下：
<img src="/image/learn_c/4_3.webp" alt="do_while_statement"></p>
<h3 id="跳转语句">跳转语句</h3>
<p>跳转语句主要包含 <code>break</code>、<code>continue</code>、<code>return</code>、<code>goto</code> 四种形式</p>
<h1 id="第五讲-函数调用上">第五讲 函数调用（上）</h1>
<h2 id="快速回顾">快速回顾</h2>
<p>借用函数，可以将一个程序的实现过程拆分为多个子步骤，并以结构化的方式来构建程序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;tgmath.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">Point</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">Point</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="n">handler</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nf">handler</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Point</span> <span class="n">p</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">10</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">handler</span><span class="p">));</span>  <span class="c1">// 5.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>函数类型的参数默认以指针传递，可以省略表明指针类型的<code>*</code>符号</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">Point</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="c-函数的调用约定">C 函数的调用约定</h2>
<p>我们将编译器实现函数调用所遵循的一系列规则称之为函数的调用约定（Calling Convention）</p>
<p>调用约定并非 C 语言标准的一部分，不同平台有不同的标准，
Unix系统使用 System V AMD64 ABI （简称 SysV）的调用约定</p>
<p>SysV 函数调用示例如下：</p>
<p><img src="/image/learn_c/5_1.webp" alt="sysv_calling_convention"></p>
<p>函数调用是通过 call 指令来完成，每个函数执行完毕后通过 ret 指令
来退出函数的执行，并转移代码执行流程到之前函数调用指令的下一条指令上</p>
<p><img src="/image/learn_c/5_2.webp" alt="call_and_ret"></p>
<h2 id="参数约定">参数约定</h2>
<p>对于整形和指针类型的实参，需要分别使用寄存器 rdi、rsi、rdx、rcx、r8、r9，按函数定义是参数从左到右的顺序进行传值。如果参数超过 6 个，
则余下参数通过栈内存进行传送，多出来的参数从右到左入栈</p>
<p>对于浮点数，使用 xmm0 到 xmm7 共 8 个寄存器进行存储。
对于更宽的值，也可能使用 ymm 与 zmm 寄存器来代替 xmm 寄存器。</p>
<h2 id="返回值传递">返回值传递</h2>
<p>整数类型返回值，小于 64 位，使用 rax 寄存器（32 位的别名为 eax ），小于 128 位，使用 rax和 rdx 分别返回低 64 位和高 64 位</p>
<p>浮点数会使用 xmm、ymm、zmm 寄存器。</p>
<h2 id="寄存器使用">寄存器使用</h2>
<p>对于 rbx、rbp、rsp 和 r12 ~ r15 寄存器，若函数需要使用它们，
需要使用前暂存，退出前恢复。</p>
<h2 id="堆栈清理">堆栈清理</h2>
<p>每个函数在结束前，需要清理自身的堆栈，可以通过 leave 指令完成</p>
<h2 id="其他约定">其他约定</h2>
<ul>
<li>函数在 call 调用前， 需要保证栈顶地址值 16 字节对齐</li>
<li>从栈顶向上保留128 字节作为 “Red Zone”</li>
<li>系统调用使用寄存器 rdi、rsi、rdx、r10、r8 和 r9 传递参数</li>
</ul>
<p>Red Zone 是位于栈顶向上的一段固定长度的内存段，这块区域可以被调用函数栈中的 “叶子” 函数（即不再调取其他函数的函数）使用，这样在需要额外栈内存时，就能省去调整栈内存大小的过程。</p>
<h2 id="保存函数调用信息的栈帧">保存函数调用信息的栈帧</h2>
<p>我们将栈内存数据块称之为帧栈，帧栈存放有返回地址、实参
局部地址、返回值和暂存的寄存器值。</p>
<p>在进程内存中，栈内存是从高向低增长的，即栈底位于高地址处，栈顶位于
低地址处。</p>
<p>rsp 寄存器又称之为 Stack Pointer，其存放着栈顶地址，即其决定了
栈内存大小，通过减小其存储的值，就能扩大栈内存。</p>
<p><img src="/image/learn_c/5_3.webp" alt="stack_memory"></p>
<p>bar 函数第一行指令 <code>push rbp</code> 会将当前 rbp 寄存器的值存到栈中，
rbp 寄存器 又称为 Frame Pointer， 通常来存储调用前的栈高度，即
rsp的旧值，以便进行帧栈寻址，并在退出前将栈中数据恢复到调用前的状态；
第二行指令<code>mov rbp, rsp</code>便是将 rsp 的值保存到 rbp 中；
第三行指令<code>mov eax, 10</code> 将结果存入 eax 寄存器;
第四行指令<code>pop rbp</code> 恢复 rbp 寄存器的值；
第五行指令<code>ret</code> 将程序的执行转移到函数调用前。</p>
<p>main 函数第 29 行指令<code>sub rsp, 16</code>减小 rsp 的值，将栈空间扩大 16 字节；
第 30、31 行指令分别将 1 和 2 存入 rbp-4 和 rbp-8 的位置；
第 34、35 行指令，借助 push， 将 8 和 7 存入 rbp-12 、 rbp-16的位置。</p>
<p>leave 指令会恢复 rsp的值来“清理”栈数据，并恢复 rbp的值。
等效于: <code>mov rsp, rbp; pop rbp</code>; 与之对应的 enter 指令等效于 <code>push rbp; mov rpb, rsp</code></p>
<p><img src="/image/learn_c/5_4.webp" alt="main_func_memory"></p>
<h1 id="第六讲-函数调用下">第六讲 函数调用（下）</h1>
<h2 id="函数参数求值顺序">函数参数求值顺序</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d %d %d&#34;</span><span class="p">,</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">n</span><span class="o">++</span><span class="p">,</span> <span class="n">n</span><span class="o">++</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上示例程序，C 函数参数的求值顺序并没有被明确规定，有的编译器按从左到右计算，有的从左到右计算。</p>
<p>为了程序健壮性，不要编写需要依赖特定函数参数求值顺序的代码。</p>
<h2 id="尾递归调用优化tail-call-optimization">尾递归调用优化（tail-call optimization）</h2>
<p><img src="/image/learn_c/6_1.webp" alt="factorial_function"></p>
<p>函数调用过程所需数据是以帧栈的形式存到到进程的栈内存中，而栈内存的清理工作是在函数准备ret 返回前，通过 leave指令进行。
对于正常的递归函数，由于函数不断调用自己，产生的帧栈越来越多，可能导致内存溢出；另外函数调用会创建和销毁帧栈，这也是消耗性能的。</p>
<p>尾递归调用优化是指在一定条件下，编译器直接利用跳转指令代替函数调用指令，来模拟函数调用过程，这样便可省去函数调用帧栈的不断创建和销毁，
而且也只使用了有限的栈内存。</p>
<p>尾递归调用优化一个前提条件是：递归语句必须是在函数返回前的最后一条语句。在这种情况下，编译器才能确定函数的返回值没有被上一个帧栈所使用。</p>
<p><img src="/image/learn_c/6_2.webp" alt="factorial_function2"></p>
<p>上面的函数开启最高编译优化等级”-O3“后，会使用尾递归优化，
在执行 ret 前，会判断寄存器 edi 的值是否为0 （ZF=1），来决定调转</p>
<h2 id="kr-函数声明">K&amp;R 函数声明</h2>
<p>K&amp;R 函数声明可能不知道函数的参数列表，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">add</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nf">add</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>  <span class="c1">// ?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样导致参数是一个随机值，不建议使用。</p>
<h1 id="第七讲-枚举结构和联合是如何实现的">第七讲 枚举、结构和联合是如何实现的？</h1>
<h2 id="枚举-enumeration">枚举 Enumeration</h2>
<p><img src="/image/learn_c/7_1.webp" alt="enum"></p>
<p>从汇编代码可以看出自定义枚举类型都是以 int 类型存储的，枚举值 Mon 在底层是由 0 表示。</p>
<p>C 标准直接将枚举值当做整数进行处理，这样导致foo 函数在调用时，实际上允许传入任何可以被隐式转换为 int 类型的值。</p>
<h2 id="结构-struct">结构 Struct</h2>
<p>结构和数组类型，都是使用连续的内存存放数据，不过结构可以存放不同的类型的数据。</p>
<p><img src="/image/learn_c/7_2.webp" alt="struct"></p>
<p>本质上，结构只是对内部所包含的各类数据的一个封装，因此只需要它分装的这些数据放在连续的内存装即可。</p>
<p><img src="/image/learn_c/7_3.webp" alt="struct_stack_memory"></p>
<p>如上图的栈内存所示，字符转指针 p 位于 [rbp-32] 处，占用 8 个字节，字符 c 位于 [rbp-24] 处，占用 1 个字节，长整形 x 位于 [rbp-16]处，占用 8 个字节。</p>
<h3 id="内存数据对齐">内存数据对齐</h3>
<p>自然对齐是指被操作数据所在的地址为该数据大小的整数倍，当内存中的数据
满足自然对齐时，CPU通常能够以最高的效率进行数据操作。</p>
<h3 id="填充字节">填充字节</h3>
<p>某些情况即使结果对象各个数据成员都满足自然对齐的要求，额外的填充字节也会被添加，如下示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>  <span class="c1">// 8 bytes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">char</span> <span class="n">c</span><span class="p">;</span>  <span class="c1">// 1 bytes.
</span></span></span><span class="line"><span class="cl"><span class="c1">// (padding): 7 bytes.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>之所以会这样，因为编译器想保证：当结构体被连续存放时，前一个对象结束的位置正好可以满足后一个对象的起始位置时自然对齐的要求。
这样也就要求结构对象本身的大小必须是内部最大成员大小的整数倍。</p>
<h2 id="联合-union">联合 Union</h2>
<p>联合和结构语法类型，只要把 关键字从 struct 改为 union。
顾名思义，联合就是所有字段共同使用一个内存区域。</p>
<p>联合对象的大小与内部定义最大成员的大小相同。</p>
<p>对一个单独的联合对象来说，哪个字段在生效我们无从得知，所以需要一个标签字段来配合指明正在生效的字段，这样模式叫做“Tagged Union”.</p>
<p><img src="/image/learn_c/7_4.webp" alt="union"></p>
<h1 id="第八讲-指针是如何灵活使用内存的">第八讲 指针是如何灵活使用内存的</h1>
<h2 id="指针的基本使用">指针的基本使用</h2>
<p>通过 类型说明符加 * 符号可以定义一个指向该数据类型的指针。
通过 const 关键字可以限制指针变量的行为</p>
<p><img src="/image/learn_c/8_1.webp" alt="pointer_basic_usage"></p>
<h2 id="指针和数组">指针和数组</h2>
<p><img src="/image/learn_c/8_2.webp" alt="pointer_and_array"></p>
<p>从上图看出，数据中的元素被分配在连续的栈内存中。</p>
<p>当 arr 作为实参传入函数 sum 后，实际传入的是一个指向 int 类型的指针，有关 arr 的大小和类型都全部丢失，这种情况称之为”数组的退化“。</p>
<h2 id="指针的其他运算">指针的其他运算</h2>
<h3 id="算术运算">算术运算</h3>
<p><img src="/image/learn_c/8_3.webp" alt="pointer_math_operation"></p>
<p>当我们对指针进行加减运算时，编译器是以当前指针所指向值对应的某个固定
长度为单位，对指针中存放的地址值进行相应调整的。</p>
<h3 id="关系运算">关系运算</h3>
<p>大多数情况，编译器会使用 cmp 和 setg 等指令来判断关系运算两侧操作数的大小</p>
<h2 id="堆内存指针">堆内存指针</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define N 5
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>  
</span></span><span class="line"><span class="cl">  <span class="c1">// 分配用于存放 N 个整数的堆内存；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 将数组 arr 中的元素复制到分配的堆内存中；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 通过指针遍历堆空间中的数据；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 释放先前分配的堆空间，让操作系统可以回收内存；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 VAS 中，堆内存位于栈内存的下方，堆内存是从低地址向高地址逐渐增长</p>
<p><img src="/image/learn_c/8_4.webp" alt="heap_memory"></p>
<p>堆内存可以动态创建，可以保持和程序相同的生命周期。
另外和全局变量、静态变量这种将值完全暴露给所有程序代码相比，
使用堆内存可以将数据的使用限制在所需的最小范围内，加强了程序对内存的精细化管理程度。</p>
<h1 id="第九讲-预处理器">第九讲 预处理器</h1>
<h2 id="预处理流程">预处理流程</h2>
<p>预处理流程如下：</p>
<ol>
<li>删除代码注释</li>
<li>处理宏定义 #define，进行展开和替换</li>
<li>处理条件预编译 #if、#elif，仅保留符合条件的代码</li>
<li>处理文件包含预编译指令 #include，将被包含的文件内容插入到指令所在位置</li>
<li>处理其他可识别的预处理指令如 #program</li>
<li>添加其他具有辅助性功能的注释信息</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#pragma GCC warning &#34;Just FYI!&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define PI 3.14
</span></span></span><span class="line"><span class="cl"><span class="cp">#define SQUARE(x) (x * x)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if defined PI
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="c1">// Some specific calculations.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">double</span> <span class="n">area</span> <span class="o">=</span> <span class="nf">SQUARE</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">PI</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">bool</span> <span class="n">isAreaGT100</span> <span class="o">=</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="mf">100.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用<code>gcc -O0 -Wall -E exmaple.c -o example.I</code> 得到预处理后的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp"># 1 &#34;macro.c&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp"># 1 &#34;&lt;built-in&gt;&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp"># 1 &#34;&lt;command-line&gt;&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp"># 31 &#34;&lt;command-line&gt;&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp"># 1 &#34;/usr/include</span><span class="cpf">/stdc-predef.h&#34; 1 3 4</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"># 32 &#34;&lt;command-line&gt;&#34; 2
</span></span></span><span class="line"><span class="cl"><span class="cp"># 1 &#34;macro.c&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp"># 1 &#34;/usr/lib/gcc/x86_64-redhat-linux/8/include</span><span class="cpf">/stdbool.h&#34; 1 3 4</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"># 3 &#34;macro.c&#34; 2
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">double</span> <span class="n">area</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mf">3.14</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span>
</span></span><span class="line"><span class="cl"><span class="cp"># 8 &#34;macro.c&#34; 3 4
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>       <span class="n">_Bool</span>
</span></span><span class="line"><span class="cl"><span class="cp"># 8 &#34;macro.c&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>            <span class="n">isAreaGT100</span> <span class="o">=</span> <span class="n">area</span> <span class="o">&gt;</span> <span class="mf">100.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="宏函数常用技巧">宏函数常用技巧</h2>
<h3 id="为返回值添加括号">为返回值添加括号</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// #define FOO(x) 1 + x * x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">define</span> <span class="nf">FOO</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="nf">FOO</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="为参数添加括号">为参数添加括号</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// #define FOO(x) (1 + x * x)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">define</span> <span class="nf">FOO</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="nf">FOO</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="警惕多次副作用">警惕多次副作用</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define FOO(x) (1 + (x) * (x))
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nf">FOO</span><span class="p">(</span><span class="o">++</span><span class="n">i</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="定义完备的多语句宏函数">定义完备的多语句宏函数</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// #define SAY() printf(&#34;Hello, &#34;); printf(&#34;world!&#34;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define SAY() do { printf(&#34;Hello, &#34;); printf(&#34;world!&#34;)} while (0)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">input</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">input</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SAY</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="第十讲-字符字符串与数学计算">第十讲 字符、字符串与数学计算</h1>
<p><img src="/image/learn_c/10_1.webp" alt="c_std_library"></p>
<h2 id="字符和字符串">字符和字符串</h2>
<p>在 C 语言中，字符用单引号表示，字符串用双引号表示</p>
<h3 id="字符">字符</h3>
<p>C 语言保证 char 类型只占用一个字节大小。</p>
<p>大多数情况编译器会选择 char 类型视为有符号整数类型。</p>
<h3 id="字符串">字符串</h3>
<p>字符串可以使用指针或者数组形式表示。</p>
<p>连续出现的字符串之间如果仅有空格分隔，则会将它们视为一个整体。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// read-only string.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">const</span> <span class="kt">char</span> <span class="n">strA</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Hello, geek!&#34;</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">strB</span> <span class="o">=</span> <span class="s">&#34;Hello&#34;</span> <span class="s">&#34;, geek!&#34;</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述字符串在内存的布局如下：</p>
<p><img src="/image/learn_c/10_2.webp" alt="string_memory_layout"></p>
<p>字符串被存放在连续的内存段上，且每个字符串最后都以一个空字符作为终止符。</p>
<p>使用数组和指针形式定义的字符串，其底层的数据引用方式会有所区别。
其中数组方式会将字符串从 .rodata 中拷贝到其他位置（比如栈内存），因此修改这些这些数据不会改变原始的 .rodata 中的副本；而使用指针形式时指针会直接引用位于 .rodata 中的字符串数据，因此通过指针修改字符串的值会影响相同指向的指针字符串。</p>
<h2 id="字符库函数">字符库函数</h2>
<h3 id="统计字符串长度">统计字符串长度</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;Hi&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%zu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>  <span class="c1">// 2.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>strlen 函数不会计入字符串多余的终止符。</p>
<h3 id="拼接字符串">拼接字符串</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define STRLEN 14
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">strA</span><span class="p">[</span><span class="n">STRLEN</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;Hello,&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">strB</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34; world!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">strncat</span><span class="p">(</span><span class="n">strA</span><span class="p">,</span> <span class="n">strB</span><span class="p">,</span> <span class="n">STRLEN</span> <span class="o">-</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">strA</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">strA</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>strncat 可控制被拼接字符串的长度</p>
<h3 id="拷贝字符串">拷贝字符串</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">strA</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;aaaaaa&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">strB</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;bbbbbbb&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">strncpy</span><span class="p">(</span><span class="n">strA</span><span class="p">,</span> <span class="n">strB</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">strA</span><span class="p">)));</span>  <span class="c1">// &#34;bbbbbb&#34;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="格式化字符串">格式化字符串</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define LEN 128
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">dest</span><span class="p">[</span><span class="n">LEN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span> <span class="n">strA</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Hello, &#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">sprintf</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="s">&#34;%sworld!&#34;</span><span class="p">,</span> <span class="n">strA</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>sprintf 会将格式化后的字符串保存到第一个参数传入的数组中</p>
<h3 id="字符的判断和转换">字符的判断和转换</h3>
<p>ctype.h 中包含众多用于字符的函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;ctype.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">isalnum</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>  <span class="c1">// 1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">isalpha</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>  <span class="c1">// 1.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">isblank</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>  <span class="c1">// 0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">isdigit</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>  <span class="c1">// 0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%c</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">toupper</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>  <span class="c1">// &#39;A&#39;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="数学运算库函数">数学运算库函数</h2>
<p>math.h 和 stdlib.h 包含了众多数学运算函数</p>
<p>thmath.h 里面提供了泛型办的数学运算函数，大体思路是通过宏来判断参数类型进而转换到正确类型的底层函数去，详情参考<a href="https://git.musl-libc.org/cgit/musl/tree/include/tgmath.h">实现</a></p>
<h1 id="第十一讲-io-标准库">第十一讲 IO 标准库</h1>
<p>C 语言采用标准库 stdio 的方式，提供对 I/O 相关接口的支持</p>
<h2 id="基本使用">基本使用</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Enter some characters:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="nf">fopen</span><span class="p">(</span><span class="s">&#34;./temp.txt&#34;</span><span class="p">,</span> <span class="s">&#34;w+&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nf">scanf</span><span class="p">(</span><span class="s">&#34;%c&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nf">putc</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;File open failed.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>通过 printf 将指定文本传送到标准输出流 stdout</li>
<li>通过 fopen 打开指定的文件，并将其与一个特定的文件 IO 流关联</li>
<li>通过 perror 将指定错误信息传送到标准错误流 stderr</li>
<li>通过 scanf 从 标准输入流 stdin 读取输入的信息</li>
<li>通过 putc 将 字符写入指定文件</li>
</ul>
<h2 id="接口级别">接口级别</h2>
<p>IO 接口一般分为两个级别：</p>
<ul>
<li>标准 IO：ISO C 标准定义的一些列接口，实现与具体操作系统无关</li>
<li>低级 IO：使用具体操作系统相关的一系列底层接口来提供相应的 IO 能力</li>
</ul>
<p>上面的代码使用低级 IO 接口实现如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Enter some characters:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="s">&#34;./temp.txt&#34;</span><span class="p">,</span> <span class="n">O_RDWR</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nf">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ch</span><span class="p">));</span>    
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span> <span class="n">errMsg</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;File open failed.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">write</span><span class="p">(</span><span class="n">STDERR_FILENO</span><span class="p">,</span> <span class="n">errMsg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">errMsg</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>和低级 IO 相比，标准 IO 会为我们提供带缓冲的输入和输出操作。</p>
<h2 id="低级-io-背后的系统调用">低级 IO 背后的系统调用</h2>
<p>低级 IO 接口通过系统调用来完成相应的 IO 操作，与调用用户函数不同使用 call 指令 不同，在 x86-64 平台，通过 syscall 指令来执行一个系统调用函数。</p>
<p>每个系统调用函数有一个唯一整形 ID, open 函数的 ID 为 2。
SyxV 调用约定使用寄存器 rdi、rsi、rdx、r10、r8、r9 来进行实参的传递，寄存器 rax 用于存放系统调用对应的 ID，并接收系统调用的结果。</p>
<p>上面的代码使用汇编改造如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;fcntl.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Enter some characters:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fileName</span> <span class="o">=</span> <span class="s">&#34;./temp.txt&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Call to `open` starts:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// const int fd = open(&#34;./temp.txt&#34;, O_RDWR | O_CREAT);
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">volatile</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">asm</span><span class="p">(</span><span class="s">&#34;mov $2, %%rax</span><span class="se">\n\t</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#34;mov %0, %%rdi</span><span class="se">\n\t</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#34;mov $66, %%rsi</span><span class="se">\n\t</span><span class="s">&#34;</span>  <span class="c1">// 2 | 64 -&gt; 66;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="s">&#34;syscall</span><span class="se">\n\t</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#34;mov %%rax, %1</span><span class="se">\n\t</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl">       <span class="o">:</span> <span class="s">&#34;=m&#34;</span> <span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="o">:</span> <span class="s">&#34;m&#34;</span> <span class="p">(</span><span class="n">fd</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// Call ended.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nf">read</span><span class="p">(</span><span class="n">STDIN_FILENO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nf">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ch</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span> <span class="n">errMsg</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;File open failed.&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">write</span><span class="p">(</span><span class="n">STDERR_FILENO</span><span class="p">,</span> <span class="n">errMsg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">errMsg</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码中，将 ID 2 存入 寄存器 rax, 将 fileName 首地址存入寄存器
rdi，将 文件操作模式 66 存入寄存器 rsi，调用结果 从 寄存器 rax 存入 局部变量 fd。</p>
<h1 id="第十二讲-非本地跳转和可变参数实现原理">第十二讲 非本地跳转和可变参数实现原理</h1>
<h2 id="本地跳转">本地跳转</h2>
<p><img src="/image/learn_c/12_1.webp" alt="local_jump"></p>
<p>本地跳转一般指由 goto 语句完成的程序执行流的转移过程</p>
<h2 id="setjmp-和-longjmp-函数">setjmp 和 longjmp 函数</h2>
<p><img src="/image/learn_c/12_2.webp" alt="long_jump"></p>
<p>如上图所示，在调用 longjmp 之后，程序会调到 call setjmp 下一条指令，
这种跳转为我们提供了一种可以暂存函数调用状态并在未来某个时刻再恢复的能力。</p>
<h3 id="运作原理">运作原理</h3>
<p>setjmp 函数在执行时，会将程序此刻的调用环境信息存储在由其第一个参数指定的 jmp_buf 类型的对象中，并同时将 0 作为结果返回，后续当程序执行到 longjmp 时，
该函数便回从同一个 jmp_buf 对象中再次恢复之前保存的函数调用上下文，通过这种方式，程序的执行流程得到了重置。</p>
<p>SysV 调用约定，属于 Callee-saved 类型的寄存器信息需要在 call 指令调用时，由被调用函数 caller 负责保存和恢复。</p>
<h3 id="自定义实现">自定义实现</h3>
<p>setjmp 汇编如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="na">.global</span> <span class="no">setjmp</span>  <span class="c1"># 将 setjmp 暴露给链接器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="na">.intel_syntax</span> <span class="no">noprefix</span>  <span class="c1"># 使用汇编语法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nl">setjmp:</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="p">],</span> <span class="no">rbx</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x8</span><span class="p">],</span> <span class="no">rbp</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x10</span><span class="p">],</span> <span class="no">r12</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x18</span><span class="p">],</span> <span class="no">r13</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x20</span><span class="p">],</span> <span class="no">r14</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x28</span><span class="p">],</span> <span class="no">r15</span>
</span></span><span class="line"><span class="cl">  <span class="nf">lea</span>  <span class="no">rdx</span><span class="p">,</span> <span class="p">[</span><span class="no">rsp</span><span class="err">+</span><span class="mi">0x8</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x30</span><span class="p">],</span> <span class="no">rdx</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">rdx</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rsp</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x38</span><span class="p">],</span> <span class="no">rdx</span>
</span></span><span class="line"><span class="cl">  <span class="nf">xor</span>  <span class="no">eax</span><span class="p">,</span> <span class="no">eax</span>
</span></span><span class="line"><span class="cl">  <span class="nf">ret</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由 SysV 规定，寄存器 rdi 接收第一个实参，所以 rdi 保存着
jmp_buf 的首地址， jmp_buf 可以看做是一个具有足够大小的字节数组。</p>
<p>在 4~9 行我们将寄存器 rdx、rbp、r12、r13、r14、r15 的值进行保存，
在 10~11 行我们将 setjmp 调用之前的 rsp 寄存器进行了暂存，
在 12~13 行我们将 setjmp 调用后的地址进行暂存，这个地址将由 longjmp 使用</p>
<p>longjmp 汇编如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="na">.global</span> <span class="no">longjmp</span>
</span></span><span class="line"><span class="cl"><span class="na">.intel_syntax</span> <span class="no">noprefix</span>
</span></span><span class="line"><span class="cl"><span class="nl">longjmp:</span>
</span></span><span class="line"><span class="cl">  <span class="nf">xor</span>  <span class="no">eax</span><span class="p">,</span> <span class="no">eax</span>
</span></span><span class="line"><span class="cl">  <span class="nf">cmp</span>  <span class="no">esi</span><span class="p">,</span> <span class="mi">0x1</span>
</span></span><span class="line"><span class="cl">  <span class="nf">adc</span>  <span class="no">eax</span><span class="p">,</span> <span class="no">esi</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">rbx</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">rbp</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x8</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">r12</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x10</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">r13</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x18</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">r14</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x20</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">r15</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x28</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>  <span class="no">rsp</span><span class="p">,</span> <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x30</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="nf">jmp</span>  <span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="err">+</span><span class="mi">0x38</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 4~5 行我们将对 long_jmp 的第二个参数做处理，如果实参为 0，将其改为 1，这样做是为了能够通过寄存器 rax 中的值区分当前代码是在 setjmp 函数调用后首次执行的，还是 long_jmp 恢复后执行的</p>
<p>将汇编代码编译成对象文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gcc -c setjmp.s -o setjmp.o
</span></span><span class="line"><span class="cl">gcc -c longjmp.s -o longjmp.o
</span></span></code></pre></td></tr></table>
</div>
</div><p>完整代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdnoreturn.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 定义 jmp_buf 类型；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="kt">long</span> <span class="n">jmp_buf</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 提供函数原型；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">setjmp</span><span class="p">(</span><span class="n">jmp_buf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">noreturn</span> <span class="kt">void</span> <span class="nf">longjmp</span><span class="p">(</span><span class="n">jmp_buf</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 原始 C 示例程序代码；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">jmp_buf</span> <span class="n">jb</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">noreturn</span> <span class="kt">void</span> <span class="nf">inspect</span><span class="p">(</span><span class="kt">char</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">putchar</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">longjmp</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">volatile</span> <span class="kt">char</span> <span class="n">count</span> <span class="o">=</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">setjmp</span><span class="p">(</span><span class="n">jb</span><span class="p">)</span> <span class="o">&lt;</span> <span class="sc">&#39;J&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">inspect</span><span class="p">(</span><span class="n">count</span><span class="o">++</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译、测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gcc main.c setjmp.o longjmp.o -o main <span class="o">&amp;&amp;</span> ./main
</span></span></code></pre></td></tr></table>
</div>
</div><p>通常非本地跳转主要用来实现异常处理、协程等功能</p>
<p>使用非本地调整实现的 try &hellip; catch 可以参考<a href="http://groups.di.unipi.it/~nids/docs/longjump_try_trow_catch.html">longjump_try_trow_catch</a></p>
<h2 id="可变参数">可变参数</h2>
<h3 id="基本使用-1">基本使用</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">print_sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">va_list</span> <span class="n">ap</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">sum</span> <span class="o">+=</span> <span class="nf">va_arg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">print_sum</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="运作原理-1">运作原理</h3>
<p><a href="https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf">SysV ABI</a> 规定了可变参数列表的实现要求</p>
<p>首先实参将会按类型按顺序依次存入寄存器，
接着一块名为 Register Save Area 的 栈内存被构建，每个通过寄存器传入的实参值都会按照 rdi、rsi、rdx、rcx、r8、r9、xmm0~15 的寄存器先后顺序拷贝到 RSA 中，
接下来创建 结构体 va_list</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gp_offset</span><span class="p">;</span>  <span class="c1">// 下一个整型数据相较于 RSA 的偏移；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fp_offset</span><span class="p">;</span>  <span class="c1">// 下一个浮点数据相较于 RSA 的偏移；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="o">*</span><span class="n">overflow_arg_area</span><span class="p">;</span>  <span class="c1">// 指向使用栈进行传递的数据；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="o">*</span><span class="n">reg_save_area</span><span class="p">;</span>  <span class="c1">//  指向 RSA 的指针；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">va_list</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>va_start(ap, count)</code> 语句对 ap 进行了初始化，reg_save_area 指向了 RSA 起始位置，gp_offset 设置为 从 RSA 中读整数实参相对 reg_save_area 的偏移</p>
<p><code>va_arg(ap, int)</code> 语句根据 va_list 及提取参数的类型从 RSA 中取出相应的数据值</p>
<p><code>va_end(ap)</code> 释放了 ap</p>
<h1 id="第十三讲-c-并发编程">第十三讲 C 并发编程</h1>
<p>C11 标准加入了 thread.h 和 stdatomic.h 标准库，提供了一套通用的并发编程接口</p>
<h2 id="进程-vs-线程">进程 vs 线程</h2>
<p>默认情况，操作系统会为每一个运行的程序创建一个相应的进程，作为程序的运行实例。
进程中包含一系列运行时信息，比如 VAS、PID、 处理器上下文（如通用寄存器和指令寄存器的值），进程状态分配调度相关资源。这些信息被放在 <code>进程控制块 PCB</code> 数据结构中。</p>
<p>相比进程，线程提供了更细粒度的运行单元，线程在共享程序运行资源的情况下，负责程序某个子任务的具体执行过程。线程的状态信息被放在 <code>线程控制块 TCB</code> 数据结构中</p>
<p><img src="/image/learn_c/13_1.webp" alt="thread1"></p>
<h2 id="线程的基本控制">线程的基本控制</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">thrd_t</span> <span class="n">id</span> <span class="o">=</span> <span class="nf">thrd_current</span><span class="p">();</span>  <span class="c1">// 返回该函数运行所在线程的标识符；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">printf</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">thrd_success</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef __STDC_NO_THREADS__
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="kt">thrd_t</span> <span class="kr">thread</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 创建一个线程；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="s">&#34;Hello C11 thread with id: %lu.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">thrd_join</span><span class="p">(</span><span class="kr">thread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="o">==</span> <span class="n">thrd_success</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 等待其他线程退出；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Thread returns %d at the end.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">  <span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其他线程控制函数如下表：</p>
<p><img src="/image/learn_c/13_2.webp" alt="thread2"></p>
<h2 id="数据竞争">数据竞争</h2>
<p>数据竞争 Data Race 是指在一个多线程的环境中，有两个及以上的线程同一时间对同一块内存的数据进行了非原子操作，示例如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define THREAD_COUNT 20
</span></span></span><span class="line"><span class="cl"><span class="cp">#define THREAD_LOOP 100000000
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">long</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 全局变量，用来记录线程的累加值；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_LOOP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">counter</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// 在线程中递增全局变量的值；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Thread %d terminates.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">thrd_success</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef __STDC_NO_THREADS__
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="kt">int</span> <span class="n">ids</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>  <span class="c1">// 用于存放线程序号的数组；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">thrd_t</span> <span class="n">threads</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">run</span><span class="p">,</span> <span class="n">ids</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>  <span class="c1">// 创建 THREAD_COUNT 个线程；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">thrd_join</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// 让当前线程等待其他线程执行完毕；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Counter value is: %ld.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>  <span class="c1">// 输出 counter 变量最终结果；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>  
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>counter++</code> 语句可能会编译为如下几条机器指令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">mov</span> <span class="no">eax</span><span class="p">,</span> <span class="no">DWORD</span> <span class="no">PTR</span> <span class="no">counter</span><span class="p">[</span><span class="no">rip</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="no">eax</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="no">DWORD</span> <span class="no">PTR</span> <span class="no">counter</span><span class="p">[</span><span class="no">rip</span><span class="p">],</span> <span class="no">eax</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="竞态条件">竞态条件</h2>
<p>竞态条件 Race Condition 是指由于程序中某些事件的发生时机和顺序不一致，从而影响正确性的一种缺陷</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdatomic.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define THREAD_COUNT 10
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">atomic_int</span> <span class="n">accountA</span> <span class="o">=</span> <span class="mi">100000000</span><span class="p">;</span>  <span class="c1">// 转出账户初始金额；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">atomic_int</span> <span class="n">accountB</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 转入账户初始金额；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">_amount</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">v</span><span class="p">);</span>  <span class="c1">// 获得当前线程的转移金额；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 首先判断转出账户金额是否足够，不够则直接退出；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">accountA</span> <span class="o">&lt;</span> <span class="n">_amount</span><span class="p">)</span> <span class="k">return</span> <span class="n">thrd_error</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="nf">atomic_fetch_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">accountB</span><span class="p">,</span> <span class="n">_amount</span><span class="p">);</span>  <span class="c1">// 将金额累加到转入账户；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">atomic_fetch_sub</span><span class="p">(</span><span class="o">&amp;</span><span class="n">accountA</span><span class="p">,</span> <span class="n">_amount</span><span class="p">);</span>  <span class="c1">// 将金额从转出账户中扣除；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if !defined(__STDC_NO_THREADS__) &amp;&amp; !defined(__STDC_NO_ATOMICS__)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="kt">thrd_t</span> <span class="n">threads</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl">  <span class="nf">srand</span><span class="p">(</span><span class="nf">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">amount</span> <span class="o">=</span> <span class="nf">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">50</span><span class="p">;</span>  <span class="c1">// 为每一个线程生成一个随机转移金额；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">run</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">amount</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">thrd_join</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;A: %d</span><span class="se">\n</span><span class="s">B: %d&#34;</span><span class="p">,</span> <span class="n">accountA</span><span class="p">,</span> <span class="n">accountB</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于加钱和减钱的操作是分开的，可能导致错误的结果</p>
<h2 id="指令重排">指令重排</h2>
<p>现代编译器和处理器会采用指令重排来进一步提升程序的运行效率。
这种技术会在不影响程序可观测执行结果的情况下，对生成的机器指令或实际执行顺序进行适当的重排。</p>
<p>对于编译器来说，其表象是源码中的语句出现顺序和汇编代码实现的顺序不一致。</p>
<p>对于处理器来说，则是程序在真正执行时产生副作用的顺序（如变量赋值），与汇编代码指令出现顺序不一致</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdatomic.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#if !defined(__STDC_NO_ATOMICS__)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">atomic_int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>  <span class="c1">// ！变量 y 的值可能被优先更新！
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">observe</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">20</span><span class="p">)</span> <span class="p">;</span>  <span class="c1">// 忙等待；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>  <span class="c1">// 只在 x 被更新后打印；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if !defined(__STDC_NO_THREADS__)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="kt">thrd_t</span> <span class="n">threadA</span><span class="p">,</span> <span class="n">threadB</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">  <span class="nf">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threadA</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threadB</span><span class="p">,</span> <span class="n">observe</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">thrd_join</span><span class="p">(</span><span class="n">threadA</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">thrd_join</span><span class="p">(</span><span class="n">threadB</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="第十四讲-如何协调线程">第十四讲 如何协调线程</h1>
<h2 id="互斥量">互斥量</h2>
<p>互斥量 mtx_t_init 初始化有三种模式</p>
<ul>
<li>mtx_plain: 普通模式</li>
<li>mtx_recursive： 可重入模式</li>
<li>mtx_timed：有超时限制，超过后互斥失效</li>
</ul>
<p>另外两个互斥相关函数</p>
<ul>
<li>mtx_trylock: 加锁或者直接返回</li>
<li>call_once：仅调用一次</li>
</ul>
<h2 id="原子操作">原子操作</h2>
<p>stdaotmic.h 文件中 提供了一些原子操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdatomic.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define THREAD_COUNT 10
</span></span></span><span class="line"><span class="cl"><span class="cp">#define THREAD_LOOP 100000000
</span></span></span><span class="line"><span class="cl"><span class="cp">#if !defined(__STDC_NO_ATOMICS__)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">_Atomic</span> <span class="kt">long</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 定义一个原子类型全局变量，用来记录线程的累加值；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_LOOP</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">atomic_fetch_add_explicit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memory_order_relaxed</span><span class="p">);</span>  <span class="c1">// 使用原子加法操作；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Thread %d terminates.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">thrd_success</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if !defined(__STDC_NO_THREADS__) || !defined(__STDC_NO_ATOMICS__)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="kt">int</span> <span class="n">ids</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="kt">thrd_t</span> <span class="n">threads</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">run</span><span class="p">,</span> <span class="n">ids</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">thrd_join</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Counter value is: %ld.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 <code>_Atomic</code> 声明一个院子类型变量，使用 atomic_fetch_add_explicit 来进行原子变量的加法操作，内存顺序有三种：</p>
<p><img src="/image/learn_c/14_1.webp" alt="memory_order"></p>
<p>更多原子操作相关函数如下：</p>
<p><img src="/image/learn_c/14_2.webp" alt="atomic_functions"></p>
<h2 id="条件变量">条件变量</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">mtx_t</span> <span class="n">mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">cnd_t</span> <span class="n">cond</span><span class="p">;</span>  <span class="c1">// 定义一个条件变量；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mtx_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">cnd_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>  <span class="c1">// 通知等待中的线程；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">mtx_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">thrd_success</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifndef __STDC_NO_THREADS__
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="nf">mtx_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="n">mtx_plain</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="nf">cnd_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>  <span class="c1">// 初始化条件变量；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">thrd_t</span> <span class="kr">thread</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">  <span class="nf">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="p">,</span> <span class="n">run</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mtx_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">done</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">cnd_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>  <span class="c1">// 让当前线程进入等待队列；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mtx_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;The value of done is: %d&#34;</span><span class="p">,</span> <span class="n">done</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mtx_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">cnd_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">);</span>  <span class="c1">// 销毁条件变量；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>条件变量提供了线程间通知能力，某个线程可以在完成了某件事后，通知并唤醒等待线程。</p>
<h2 id="本地变量">本地变量</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdatomic.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define THREAD_COUNT 10
</span></span></span><span class="line"><span class="cl"><span class="cp">#define THREAD_LOOP 10000
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">_Thread_local</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 定义线程本地变量；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">run</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_LOOP</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 更新当前线程所属的 counter 变量值；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">counter</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">thrd_t</span> <span class="n">threads</span><span class="p">[</span><span class="n">THREAD_COUNT</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">run</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_COUNT</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">thrd_join</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">sum</span> <span class="o">+=</span> <span class="n">result</span><span class="p">;</span>  <span class="c1">// 累加每个线程的计算值；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;The value of count is %d.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>线程本地变量的值仅能够在某个线程的生存期内可用，变量的实际存储空间会在线程开始时分配，线程结束时回收。</p>
<p><img src="/image/learn_c/14_3.webp" alt="thread_local_variable"></p>
<h1 id="第十五讲-信号">第十五讲 信号</h1>
<h2 id="什么是信号">什么是信号</h2>
<p>信号实际上是一种可以用来传递特定消息的机制，操作系统将程序运行过程中发生的各类特殊情况转发给程序，并按照其指定的逻辑进行处理。</p>
<p>信号的产生是一个随机的过程，所以程序需要提前”告诉“操作系统，信号到来时，应该如何处理。这就是一种典型的异步事件处理方式。</p>
<h2 id="信号与软中断">信号与软中断</h2>
<p>信号是一种软中断，当特定事件发生时，操作系统会将对应的信号值发送给相关程序，通常情况下，如果对应程序并未设置自定义的信号处理程序，则操作系统会执行默认信号处理程序。整个程序处理过程中，存在着 CPU 从用户态到信号处理程序的执行流程转移。</p>
<h2 id="c-代码样例">C 代码样例</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">sigHandler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Signal %d catched!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">exit</span><span class="p">(</span><span class="n">sig</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">signal</span><span class="p">(</span><span class="n">SIGFPE</span><span class="p">,</span> <span class="n">sigHandler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>C 标准库提供了 6 种不同类型的信号</p>
<p><img src="/image/learn_c/15_1.webp" alt="signal_num"></p>
<p>信号处理函数的原型为 <code>void (*handler) (int)</code>，即接受一个整形的信号值，不返回任何内容。</p>
<p>除零异常的信号交互逻辑如下：</p>
<ol>
<li>CPU 执行触发指令 idiv</li>
<li>发现除零异常，CPU 暂停当前程序运行，并将控制权转交给操作系统</li>
<li>操作系统将信号 SIGFPE 发送给出错的程序</li>
<li>操作系统根据情况执行相应的信号处理程序</li>
<li>信号处理程序执行完毕后，如果程序未退出，则将程序执行恢复到之前的中断点，即 CPU 会重新执行 idiv 指令</li>
</ol>
<h2 id="可重入函数">可重入函数</h2>
<p>当程序在执行函数 A 时收到了某个信号，信号处理函数中也对函数 A 发起了调用，这样可能会影响之前还未完成调用的函数 A 执行状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;signal.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define BUF_SIZE 16  </span><span class="c1">// 全局静态数组大小；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define FORMAT_NUM_(N) &#34; $&#34;#N
</span></span></span><span class="line"><span class="cl"><span class="cp">#define FORMAT_NUM(N) FORMAT_NUM_(N)
</span></span></span><span class="line"><span class="cl"><span class="cp">#define RAISE_EXP_false_ASM()
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 调用 raise 函数向当前程序发送信号；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define RAISE_EXP_true_ASM() \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;movl    $4, %%edi\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;call    raise\n\t&#34;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="c1">// 内联汇编实现；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define INLINE_ASM(ID, HAS_EXP) \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;mov     %0, %%r8\n\t&#34; </span><span class="cm">/* 复制传入的字符串数据到全局静态数组 */</span><span class="cp"> \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;testq   %%rsi, %%rsi\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;je      .L1&#34; #ID &#34;\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;xorl    %%eax, %%eax\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;.L3&#34; #ID &#34;:\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;movzbl  (%%rdi,%%rax), %%ecx\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;movb    %%cl, (%%r8,%%rax)\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;addq    $1, %%rax\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;cmpq    %%rsi, %%rax\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;jne     .L3&#34; #ID &#34;\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;.L1&#34; #ID &#34;:\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  RAISE_EXP_##HAS_EXP##_ASM() </span><span class="cm">/* 选择性调用 raise 函数 */</span><span class="cp"> \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;mov     $1, %%rax\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;mov     $1, %%rdi\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;mov     %0, %%rsi\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;mov&#34; FORMAT_NUM(BUF_SIZE) &#34;, %%rdx\n\t&#34; \
</span></span></span><span class="line"><span class="cl"><span class="cp">  &#34;syscall\n\t&#34;  </span><span class="cm">/* 触发系统调用，打印内容 */</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUF_SIZE</span><span class="p">];</span>  <span class="c1">// 用于保存字符的全局静态数组；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">print_with_exp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 会引起信号中断的版本；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">asm</span><span class="p">(</span><span class="nf">INLINE_ASM</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">::</span> <span class="s">&#34;g&#34;</span> <span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print_normal</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 正常的版本；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">asm</span><span class="p">(</span><span class="nf">INLINE_ASM</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="o">::</span> <span class="s">&#34;g&#34;</span> <span class="p">(</span><span class="n">buf</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">sigHandler</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;Hello&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">print_normal</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">signal</span><span class="p">(</span><span class="n">SIGILL</span><span class="p">,</span> <span class="n">sigHandler</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;, world!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">print_with_exp</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/image/learn_c/15_2.webp" alt="reentrant_function"></p>
<p>不受中断和重新调用影响的函数称之为可重入函数</p>
<h2 id="多线程信号处理">多线程信号处理</h2>
<p>C 语言没有对并发编程的信号处理做规范，所以多线程应用中使用 signal 和 raise 函数会产生未定义的行为</p>
<h1 id="第十六讲-日期时间与实用函数">第十六讲 日期、时间与实用函数</h1>
<h2 id="日期与时间">日期与时间</h2>
<h3 id="日历时间">日历时间</h3>
<p>使用 time_t 类型表示，其代表从 1970-01-01: 00:00:00 到当前时间秒数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">time_t</span> <span class="n">currTime</span> <span class="o">=</span> <span class="nf">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">currTime</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">time_t</span><span class="p">)</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;the current timestamp is: %ld(s)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">currTime</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;local time is: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">asctime</span><span class="p">(</span><span class="nf">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">currTime</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;UTC time is: %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">asctime</span><span class="p">(</span><span class="nf">gmtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">currTime</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="处理器时间">处理器时间</h3>
<p>处理器时间即 CPU 资源被调度以支持程序在某段时间内正常运作所花费的时间。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">clock_t</span> <span class="n">startTime</span> <span class="o">=</span> <span class="nf">clock</span><span class="p">();</span>    
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  <span class="kt">clock_t</span> <span class="n">endTime</span> <span class="o">=</span> <span class="nf">clock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Consumed CPU time is：%fs</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">endTime</span> <span class="o">-</span> <span class="n">startTime</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="字符串到数值的转换">字符串到数值的转换</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 一次性字符串到数值转换；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">strA</span> <span class="o">=</span> <span class="s">&#34;1.0&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">atof</span><span class="p">(</span><span class="n">strA</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 带溢出检查的转换函数，执行后会保存不能被转换部分的地址；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">strB</span> <span class="o">=</span> <span class="s">&#34;200000000000000000000000000000.0&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span><span class="o">*</span> <span class="n">end</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">double</span> <span class="n">num</span> <span class="o">=</span> <span class="nf">strtol</span><span class="p">(</span><span class="n">strB</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">ERANGE</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 判断转换结果是否发生溢出；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Range error, got: &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="生成随机数">生成随机数</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt; </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt; </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt; </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">srand</span><span class="p">(</span><span class="nf">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>  <span class="c1">// 初始化随机数种子；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="nf">getchar</span><span class="p">()</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="nf">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span>  <span class="c1">// 生成并打印 0-9 的随机数；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="动态内存管理">动态内存管理</h3>
<p>除了 malloc 和 free 函数之外，C 标准库也提供了另外的一些函数</p>
<p><img src="/image/learn_c/16_1.webp" alt="alloc_function"></p>
<h3 id="进程控制">进程控制</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">exitHandler</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">getenv</span><span class="p">(</span><span class="s">&#34;PATH&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">atexit</span><span class="p">(</span><span class="n">exitHandler</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/image/learn_c/16_2.webp" alt="process_control"></p>
<h1 id="第十七讲-断言错误处理和对齐">第十七讲 断言、错误处理和对齐</h1>
<h2 id="断言-1">断言</h2>
<p>断言分为静态断言和动态断言</p>
<p>一般我们在程序运行前使用静态断言，来检查它所需要满足的一系列要求</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">double</span> <span class="nf">sqrt</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 检查函数使用时传入的参数；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">assert</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 检查程序的编译要求；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">    <span class="s">&#34;Integer should have at least 4 bytes length.&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>定义 <code>NDEBUG</code> 宏可关闭断言功能</p>
<h2 id="错误处理">错误处理</h2>
<p>在 C 语言中，名为 errno 的预处理宏会被展开为一个 init 类型的可修改全局左值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;tgmath.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nf">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>  <span class="c1">// &#34;Numerical argument out of domain&#34;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以通过 strerror 函数获取当前 errno 对应的可读文本</p>
<h2 id="对齐">对齐</h2>
<p>可以使用 _Alignas 来根据自身需要为数据指定特殊的对齐要求，stdalign.h 有
对应的宏 alignas</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdalign.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if __alignas_is_defined == 1 &amp;&amp; __alignof_is_defined == 1
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="nf">alignas</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;The alignment of n is %zu</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">alignof</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>  <span class="c1">// &#34;The alignment of n is 1024&#34;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;The address of n is: %p</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>  <span class="c1">// &#34;The address of n is: 0x7ffe80658c00&#34;.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="第十八讲-极致优化上">第十八讲 极致优化（上）</h1>
<h2 id="高速缓存">高速缓存</h2>
<p>CPU 芯片上有 L1、L2、L3 三个不同级别的高速缓存</p>
<p>高速缓存之所以能提升性能，一个重要的前提在于局部性原理</p>
<ul>
<li>时间局部性：被引用过一次的内存位置接下来可能会被再次引用</li>
<li>空间局部性：如果一个内存位置被引用了，那附近的内存也可能会被引用</li>
</ul>
<h2 id="内联">内联</h2>
<p>通过内联关键字 inline ，可以建议编译器，将某个方法的实现内联到它的实际调用处。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="nf">foo</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Output is: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码对应的汇编代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">.LC0:</span>
</span></span><span class="line"><span class="cl">        <span class="na">.string</span> <span class="s">&#34;Output is: %d\n&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nl">main:</span>
</span></span><span class="line"><span class="cl">        <span class="nf">sub</span>     <span class="no">rsp</span><span class="p">,</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">        <span class="nf">mov</span>     <span class="no">esi</span><span class="p">,</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">        <span class="nf">mov</span>     <span class="no">edi</span><span class="p">,</span> <span class="no">OFFSET</span> <span class="no">FLAT</span><span class="p">:.</span><span class="no">LC0</span>
</span></span><span class="line"><span class="cl">        <span class="nf">xor</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">eax</span>
</span></span><span class="line"><span class="cl">        <span class="nf">call</span>    <span class="no">printf</span>
</span></span><span class="line"><span class="cl">        <span class="nf">xor</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">eax</span>
</span></span><span class="line"><span class="cl">        <span class="nf">add</span>     <span class="no">rsp</span><span class="p">,</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">        <span class="nf">ret</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过内联，程序不再需要使用 call 指令来调用 foo 函数，好处在于节省 call 指令执行时需要进行的函数帧栈创建和销毁过程。坏处是导致可执行二进制文件增大</p>
<h2 id="restrict关键字">restrict关键字</h2>
<p>restrict 关键字用于指针，表明该指针是访问对应数据的唯一方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="kr">restrict</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">x</span> <span class="o">+=</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">y</span> <span class="o">+=</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">foo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%d %d %d&#34;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对应的汇编代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nl">foo:</span>
</span></span><span class="line"><span class="cl">        <span class="nf">mov</span>     <span class="no">eax</span><span class="p">,</span> <span class="no">DWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdx</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="nf">add</span>     <span class="no">DWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rdi</span><span class="p">],</span> <span class="no">eax</span>
</span></span><span class="line"><span class="cl">        <span class="nf">add</span>     <span class="no">DWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="no">rsi</span><span class="p">],</span> <span class="no">eax</span>
</span></span><span class="line"><span class="cl">        <span class="nf">ret</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用restrict 关键字后，在为指针 y 进行 值累加前，编译器不会再重复性地从内存中读取指针 z 对应的值</p>
<h2 id="消除不需要的内存引用">消除不需要的内存引用</h2>
<p>原代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#define LEN 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">dest</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">dest</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>优化代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#define LEN 3
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">dest</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">register</span> <span class="kt">int</span> <span class="n">acc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">acc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>优化代码主要做了两件事情：</p>
<ol>
<li>将用于存放临时积累值的 <code>*dest</code> 替换为局部变量</li>
<li>为局部变量添加 register 关键字，建议编译器将该值存放在寄存器中</li>
</ol>
<h1 id="第十九讲-极致优化下">第十九讲 极致优化（下）</h1>
<h2 id="循环展开loop-unrolling">循环展开（Loop Unrolling）</h2>
<p>现在 CPU 为了进一步提升指令的执行效率，通常会将单一的机器指令再进行拆分，以达到并行的目的。对于一个基本的五级 RISC 流水线来说， CPU 会将指令的执行细分为指令提取 （IF）、指令译码（ID）、指令执行（EX）、内存访问（MEM）和寄存器写回（WB）。</p>
<p>在第一条机器指令经过了指令提取后，即使该指令没有完全执行完毕，CPU 也可以立即开始处理下一条机器指令。因此从宏观上来看，机器指令的执行由串行变成了并行。
当五个节点全部执行完毕后，CPU 会更新指令指针（PC）</p>
<p><img src="/image/learn_c/19_1.webp" alt="instructions"></p>
<p>示例代码如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp"># 原代码
</span></span></span><span class="line"><span class="cl"><span class="cp">#define LEN 4096
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">acc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LEN</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">acc</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">acc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp"># 展开后的代码
</span></span></span><span class="line"><span class="cl"><span class="cp">#define LEN 4096
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="n">LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">acc0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">acc1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 2x2 loop unrolling.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">acc0</span> <span class="o">=</span> <span class="n">acc0</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">acc1</span> <span class="o">=</span> <span class="n">acc1</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LEN</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Finish any remaining elements.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">acc0</span> <span class="o">=</span> <span class="n">acc0</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">acc0</span> <span class="o">*</span> <span class="n">acc1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们将 循环结果应用了 2 * 2 （步长为2，2个独立累积值变量）循环展开。</p>
<p>不过这样导致代码量增加和可读性下降，大部分情况下我们不需要手动改变代码来做循环展开。</p>
<h2 id="优先使用条件传送指令">优先使用条件传送指令</h2>
<p>CPU 中存在着条件传送指令、条件分支指令等，CPU 执行条件分支指令会对分支进行预测，并提现执行分支指令，如果预测的跳转位置发生错误，就会将状态重置为发生跳转前分支所处的状态，并取出正确方向上的指令，开始重新处理。
条件传送指令没有分支预测，所以没有这部分损失。</p>
<p>示例代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#define LEN 1024
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#define LEN 16
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">?</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">?</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面示例通过增加几次比较和复制操作，来避免分支预测失败代码的惩罚。</p>
<h2 id="使用更高的编译优化等级">使用更高的编译优化等级</h2>
<p>gcc 可以指定更高的优化等级来优化</p>
<p><img src="/image/learn_c/19_2.webp" alt="gcc_options"></p>
<h2 id="尾递归优化">尾递归优化</h2>
<p>尾递归优化通过将函数的递归调用优化为循环结构，减少了 call 指令的调用次数，进而减少了帧栈的创建和销毁过程，提升了程序的执行性能。</p>
<h1 id="第二十讲-编码规范">第二十讲 编码规范</h1>
<p>我们以 GNU 编码规范为基准</p>
<h2 id="格式">格式</h2>
<ul>
<li>每行字符数量保持在79个以内</li>
<li>函数定义是开始花括号“{”位于行首</li>
<li>函数命中位于行首</li>
<li>参数过多时，将超过限制的参数放到函数名下一行，并与第一个参数开头对齐</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="nf">lots_of_args</span> <span class="p">(</span><span class="kt">int</span> <span class="n">an_integer</span><span class="p">,</span> <span class="kt">long</span> <span class="n">a_long</span><span class="p">,</span> <span class="kt">short</span> <span class="n">a_short</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="kt">double</span> <span class="n">a_double</span><span class="p">,</span> <span class="kt">float</span> <span class="n">a_float</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">foo</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">bar</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>更多规范参考 GNU 旗下的格式化工具 indent</p>
<h2 id="注释">注释</h2>
<p>文件层面，main 函数所在文件应以描述程序的基本用途的注释作为开头，而其他源文件应以文件名和描述该源文件基本功能的注释作为开头</p>
<p>函数层面，需要添加用于描述函数基本功能、参数类型、参数用途、参数可能取值和返回值含义等内容注释信息</p>
<h2 id="语法约定">语法约定</h2>
<ul>
<li>显示地为所有使用到的值标注类型，尤其是直接使用在表达式中的数字字面量值</li>
<li>外部函数和后续才会使函数的声明，应该被放置在当前源文件处开头统一的地方，或放到单独的文件中</li>
<li>将同类型的多个变量放在同一行声明</li>
<li>使用嵌套的流程控制语句（如 if 语句）时，总是将内部嵌套的逻辑包裹在大括号中。</li>
<li>尽量避免在 if 语句 条件判断处做赋值操作（while 可以这样做）</li>
</ul>
<h2 id="命名">命名</h2>
<p>变量名一般采用下划线命名法</p>
<p>尽量使用小写字母、下划线和数字来组成变量名，把大写字母留给宏常量和枚举常量。</p>
<h2 id="国际化">国际化</h2>
<p>可以使用 GNU gettext 库，将消息翻译成各种语言</p>
<h1 id="第二十一讲-自动化测试">第二十一讲 自动化测试</h1>
<h2 id="单元测试">单元测试</h2>
<p>单元测试就是对组成程序的基本单元（也可称为模块）进行功能正确性验证，它的目标是
隔离程序的每个部分，并单独验证这些部分能够按照预期正常工作。</p>
<p>对于 C 程序来说，这里的单元通常为函数</p>
<p>通常使用 Cunit 进行单元测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">maxi</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 被测试函数；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">test_maxi</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 测试用例；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">CU_ASSERT</span><span class="p">(</span><span class="nf">maxi</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">CU_ASSERT</span><span class="p">(</span><span class="nf">maxi</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">CU_ASSERT</span><span class="p">(</span><span class="nf">maxi</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="集成测试">集成测试</h2>
<p>检测不同单元或模块整合在一起时，他们是否也可以很好地协同工作，这类测试称之为集成测试 Integration Testing，这类测试通常需要使用数据库，网络连接等真实的外部资源。</p>
<h2 id="功能测试">功能测试</h2>
<p>功能测试 Functional Testing 的目的和集成测试十分类似，但功能测试对测试结果的正确性要求可能会更加严格，需要满足业务需求中的相应规定。</p>
<h2 id="性能测试">性能测试</h2>
<p>通常可以使用运行时间和内存使用率这两个指标来作为程序运行性能的度量单位</p>
<p>可以使用 perf 命令行工具来进行性能测试</p>
<h1 id="第二十二讲-结构化编译">第二十二讲 结构化编译</h1>
<h2 id="如何组织代码结构">如何组织代码结构</h2>
<p>对于小型项目，可以简单地将 .h 文件和 .c文件分别放在 include 目录 和 src 目录，当项目变大时，可以将源文件按功能进行更细分的划分。</p>
<p>两种参考目录结构如下图</p>
<p><img src="/image/learn_c/22_1.webp" alt="project_layouts"></p>
<h2 id="如何组织编译流程">如何组织编译流程</h2>
<p>一个 简单的 C 项目如下图
<img src="/image/learn_c/22_2.webp" alt="project_example"></p>
<p>可以用如下命令进行编译, 使用<code>-I</code>选项指定查找头文件需要搜索的目录，使用<code>-l</code>指定
链接运行时依赖的库</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gcc src/main.c src/mod.c -I./include -lm -o bin/main
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="使用-makefile-进行结构化编译">使用 Makefile 进行结构化编译</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 用于控制编译细节的自定义宏；
</span></span><span class="line"><span class="cl">CC = gcc
</span></span><span class="line"><span class="cl">CFLAGS = -I./include
</span></span><span class="line"><span class="cl">LDFLAGS = -lm
</span></span><span class="line"><span class="cl">TARGET_FILE = bin/main
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 描述各个目标的详细编译步骤；
</span></span><span class="line"><span class="cl">$(TARGET_FILE): $(patsubst src/%.c,src/%.o,$(wildcard src/*.c))
</span></span><span class="line"><span class="cl">  $(CC) $^ $(LDFLAGS) -o $@
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">src/%.o: src/%.c include/%.h
</span></span><span class="line"><span class="cl">  $(CC) $&lt; $(CFLAGS) -c -o $@
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="使用-cmake-进行跨平台自动化构建">使用 CMake 进行跨平台自动化构建</h2>
<p>CMake（Cross-platform Make）会根据所在的平台，生成相应的“平台本地构建项目”，比如在 Unix 系统上，会生成相应的 Makefie 文件，在 Windows 会生成对应的 Visula Studio 工程文件。</p>
<p>CMake 的配置信息存在 CMakeLists.txt 文件中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置项目名称；
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">project</span><span class="p">(</span><span class="s">Test</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置二进制目标文件名称；
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">TARGET_FILE</span> <span class="s2">&#34;main&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 添加源文件目录；
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">aux_source_directory</span><span class="p">(</span><span class="s">./src</span> <span class="s">DIR_SRCS</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置二进制目标文件的依赖；
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">add_executable</span><span class="p">(</span><span class="o">${</span><span class="nv">TARGET_FILE</span><span class="o">}</span> <span class="o">${</span><span class="nv">DIR_SRCS</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置头文件查找目录；
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">target_include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">TARGET_FILE</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s2">&#34;${PROJECT_SOURCE_DIR}/include&#34;</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 设置需要链接的库；
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="o">${</span><span class="nv">TARGET_FILE</span><span class="o">}</span> <span class="s">PUBLIC</span> <span class="s">m</span><span class="p">)</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h1 id="第二十三讲-高性能-http-server-实战上">第二十三讲 高性能 HTTP Server 实战（上）</h1>
<p>我们将会创建一个叫 FivSev 的服务，接收路径 “/?num={pos}”的 GET 请求，返回斐波那契数列对应位置的数值。</p>
<p>大体流程如下图</p>
<p><img src="/image/learn_c/23_1.webp" alt="tcp_server"></p>
<p>部分优化措施</p>
<ul>
<li>使用线程池利用多核CPU</li>
<li>使用尾递归调用优化</li>
<li>使用条件变量避免忙等待</li>
</ul>
<h1 id="第二十四讲-高性能-http-server-实战下">第二十四讲 高性能 HTTP Server 实战（下）</h1>
<h2 id="项目基本结构">项目基本结构</h2>
<p>项目仓库地址: <a href="https://github.com/Becavalier/tiny-http-echo-server/tree/geektime">https://github.com/Becavalier/tiny-http-echo-server/tree/geektime</a></p>
<p><img src="/image/learn_c/24_1.webp" alt="project_layout"></p>
<h2 id="处理用户参数">处理用户参数</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// libs/structs.h#L9-L11
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">threadCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">serverSettings</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// libs/helpers.h#L67-L86
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">setupServerSettings</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">,</span> <span class="n">serverSettings</span><span class="o">*</span> <span class="n">ss</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">argc</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// process key.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">keyHead</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">keyPos</span> <span class="o">=</span> <span class="nf">strchr</span><span class="p">(</span><span class="n">keyHead</span><span class="p">,</span> <span class="sc">&#39;=&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">keyLen</span> <span class="o">=</span> <span class="n">keyPos</span> <span class="o">-</span> <span class="n">keyHead</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">key</span><span class="p">[</span><span class="n">keyLen</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">wrapStrFromPTR</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">keyLen</span><span class="p">,</span> <span class="n">keyHead</span><span class="p">,</span> <span class="n">keyPos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// process value.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">valHead</span> <span class="o">=</span> <span class="n">keyHead</span> <span class="o">+</span> <span class="n">keyLen</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">valPos</span> <span class="o">=</span> <span class="nf">strchr</span><span class="p">(</span><span class="n">valHead</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">valLen</span> <span class="o">=</span> <span class="n">valPos</span> <span class="o">-</span> <span class="n">valHead</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">val</span><span class="p">[</span><span class="n">valLen</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">valHead</span> <span class="o">&lt;=</span> <span class="n">valPos</span><span class="p">;</span> <span class="n">valHead</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">valHead</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s">&#34;thread_count&#34;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">ss</span><span class="o">-&gt;</span><span class="n">threadCount</span> <span class="o">=</span> <span class="nf">atoi</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="tcp-server">TCP Server</h2>
<h3 id="监听请求">监听请求</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// src/main.c#L70-95
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">serverFd</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="n">sockaddr_in</span> <span class="n">address</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">addrLen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// establish a socket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">((</span><span class="n">serverFd</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">bzero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="n">addrLen</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="n">address</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">address</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">INADDR_ANY</span><span class="p">;</span>  <span class="c1">// -&gt; 0.0.0.0.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">address</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="nf">htons</span><span class="p">(</span><span class="n">PORT</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="c1">// assigns specified address to the socket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="nf">bind</span><span class="p">(</span><span class="n">serverFd</span><span class="p">,</span> <span class="p">(</span><span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">address</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// mark the socket as a passive socket.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="nf">listen</span><span class="p">(</span><span class="n">serverFd</span><span class="p">,</span> <span class="n">MAX_LISTEN_CONN</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="解析请求">解析请求</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// libs/helpers.c#L37-L65
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">retrieveGETQueryIntValByKey</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">req</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// extract uri;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">uriHead</span> <span class="o">=</span> <span class="nf">strchr</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">uriTail</span> <span class="o">=</span> <span class="nf">strchr</span><span class="p">(</span><span class="n">uriHead</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="kt">size_t</span> <span class="n">uriLen</span> <span class="o">=</span> <span class="n">uriTail</span> <span class="o">-</span> <span class="n">uriHead</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">strUri</span><span class="p">[</span><span class="n">uriLen</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="nf">wrapStrFromPTR</span><span class="p">(</span><span class="n">strUri</span><span class="p">,</span> <span class="n">uriLen</span><span class="p">,</span> <span class="n">uriHead</span><span class="p">,</span> <span class="n">uriTail</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// parse uri;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">UriUriA</span> <span class="n">uri</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">UriQueryListA</span><span class="o">*</span> <span class="n">queryList</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">itemCount</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">errorPos</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nf">uriParseSingleUriA</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uri</span><span class="p">,</span> <span class="n">strUri</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">errorPos</span><span class="p">)</span> <span class="o">==</span> <span class="n">URI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nf">uriDissectQueryMallocA</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queryList</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">itemCount</span><span class="p">,</span> <span class="n">uri</span><span class="p">.</span><span class="n">query</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">uri</span><span class="p">.</span><span class="n">query</span><span class="p">.</span><span class="n">afterLast</span><span class="p">)</span> <span class="o">==</span> <span class="n">URI_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">while</span> <span class="p">(</span><span class="n">itemCount</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">strcmp</span><span class="p">(</span><span class="n">queryList</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="n">result</span> <span class="o">=</span> <span class="nf">atoi</span><span class="p">(</span><span class="n">queryList</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">          <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">queryList</span> <span class="o">=</span> <span class="n">queryList</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="nf">uriFreeQueryListA</span><span class="p">(</span><span class="n">queryList</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="计算斐波那契数列">计算斐波那契数列</h2>
<p>有递归和尾递归优化版本</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// libs/helpers.c#L8-L20
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">__calcFibTCO</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">__calcFibTCO</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">__calcFibRecursion</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">__calcFibRecursion</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nf">__calcFibRecursion</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">calcFibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// return __calcFibTCO(n, 0, 1);  // TCO version. 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="nf">__calcFibRecursion</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>  <span class="c1">// recursion version.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="第二十五讲-可执行二进制文件">第二十五讲 可执行二进制文件</h1>
<h2 id="elf-文件格式">ELF 文件格式</h2>
<p>Unix 最常使用的是ELF（executabke and linkable format）文件格式</p>
<p>通常可执行文件的组织方式分为3部分：header、section、segment</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// elf.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&#34;Hello, world!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 file 命令查看文件格式信息</p>
<p><img src="/image/learn_c/25_1.webp" alt="file_info"></p>
<h2 id="elf-头">ELF 头</h2>
<p>通过<code>readelf -h</code>可以查看文件头部内容</p>
<p><img src="/image/learn_c/25_2.webp" alt="elf_head"></p>
<h2 id="section-头">Section 头</h2>
<p>Section 用于存放可执行文件中按照功能分类好的数据，各个 Section 相关信息存放在对应的 Section 头部中，众多连续的 Section 头便组成了 Section 头表</p>
<p>通过 ELF 头信息可以得到总共有 30 个 Section 头，第一个头位于文件开始偏移的 15512 字节</p>
<p>通过<code>readelf -S</code> 查看 Section 头部信息</p>
<p><img src="/image/learn_c/25_3.webp" alt="section_head"></p>
<p>.text 主要存放程序对应的机器代码，.rodata 存放只读常量，.data 存放已经初始化的全局变量或者静态变量，.bss 中coffee初始值为 0 的全局或者静态变量。</p>
<p>使用 <code>objdump -s</code> 查看 某个 Section 的完整内容</p>
<p><img src="/image/learn_c/25_4.webp" alt="section_rodata"></p>
<h2 id="program-头">Program 头</h2>
<p>除了由 Section 组成的静态视图外，众多的 Segment 组成了可执行文件的动态图。</p>
<p>Segment 指定了应用程序在实际运行时，应该如何在进程的 VAS 内部组织数据。</p>
<p>使用<code>readelf -l</code> 查看 Segment 情况</p>
<p><img src="/image/learn_c/25_5.webp" alt="section_segment"></p>
<p>Segment 对应的头部称之为 Program 头</p>
<p>其中 “LOAD” 类型的 Segment 会在运行时载入到进程的 VAS 中， 而其余的 Segment 主要用于辅助程序的正常运行（如动态链接）。</p>
<p>通常 Segment 和 Section 之间有一定的对应关系，上图中 第一个 LOAD 类型的 Segment 便包含 .text 和 .rodata 等 Section， 第二个 LOAD Segment 包含 .data Section。这样印证了 两个 LOAD 对应的 FLags 分别 为 RE 和 RW。</p>
<p>另外第一个 LOAD 的 Offset 为 0 ，这意味着执行时会除了将对应的 Sections 加载到内存外，文件 ELF 头也会加载到内存中。</p>
<p><img src="/image/learn_c/25_6.webp" alt="head_view"></p>
<h2 id="elf-编程">ELF 编程</h2>
<p>可以使用 elf.h 库对 ELF 格式的应用编程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;elf.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print_elf_type</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">type_enum</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">switch</span> <span class="p">(</span><span class="n">type_enum</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">ET_REL</span><span class="p">:</span> <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;A relocatable file.&#34;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">ET_DYN</span><span class="p">:</span> <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;A shared object file.&#34;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">ET_NONE</span><span class="p">:</span> <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;An unknown type.&#34;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">ET_EXEC</span><span class="p">:</span> <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;An executable file.&#34;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">ET_CORE</span><span class="p">:</span> <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;A core file.&#34;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">Elf64_Ehdr</span> <span class="n">elf_header</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="nf">fopen</span><span class="p">(</span><span class="s">&#34;./elf&#34;</span><span class="p">,</span> <span class="s">&#34;r&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">fread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elf_header</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Elf64_Ehdr</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">print_elf_type</span><span class="p">(</span><span class="n">elf_header</span><span class="p">.</span><span class="n">e_type</span><span class="p">);</span>  <span class="c1">// &#34;An executable file.&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="elf-文件类型">ELF 文件类型</h2>
<p><img src="/image/learn_c/25_7.webp" alt="elf_file_type"></p>
<h1 id="第二十六讲-进程如何使用操作系统内存">第二十六讲 进程如何使用操作系统内存</h1>
<h2 id="计算机内部缓存系统">计算机内部缓存系统</h2>
<p>缓存由 L1、L2 等高速缓存和内存组成</p>
<h2 id="虚拟内存机制">虚拟内存机制</h2>
<p>虚拟内存 Virtual Memory 是操作系统在物理内存的基础上进行了一层抽象，以帮助运行于其上的应用程序合理分配内存</p>
<p><img src="/image/learn_c/26_1.webp" alt="retrieve_data"></p>
<p>CPU 会借助内存管理单元 MMU 将虚拟地址翻译成物理地址，然后再进行实际数据的获取。</p>
<p>每一个应用进程都有独立的虚拟地址空间 VAS，从进程的角度看，它可以独享整个计算机上的内存。在64 位 Linux 系统中，与应用代码相关的 Segment 会从 VAS 的固定地址 0x400000 处开始加载，而Section 内容将在满足一定对齐要求的条件下按顺序加载到高地址方向的虚拟内存中。</p>
<p>0x0 到 0x400000 (4K) 的虚拟地址不会使用，这样空指针可以触发异常</p>
<p>可以通过<code>cat /proc/&lt;pid&gt;/maps</code> 查看某个运行中的进程的 VAS 布局情况。</p>
<p><img src="/image/learn_c/26_2.webp" alt="vas_map"></p>
<h2 id="vas-数据布局">VAS 数据布局</h2>
<p><img src="/image/learn_c/26_3.webp" alt="vas_detail"></p>
<p>VAS 数据按地址有低到高，可以分为如下几个部分：</p>
<ul>
<li>LOAD Segments: 包括与代码相关的 Text Segment（.text, .rodata） 位于最低地址处，紧接着为包含已初始化和未初始化数据的Data Segment（.data, .bss）</li>
<li>堆: 堆内存，向高地址方向增长</li>
<li>共享库数据：包含各类 .so 共享库相关的数据，程序会在运行时通过动态连接器来完成对它们的加载和处理</li>
<li>栈：栈内存，向低地址方向增长</li>
<li>用于系统调用加速的内核数据：该部分数据主要提供了用户进程可以直接和内核交互的接口，其中 [vvar] 包含只读的内核数据，另外 [vdso] 和 [vsyscall] 则包含用于辅助操作系统加速用户进程执行某些系统调用过程的信息。</li>
<li>其他内核数据</li>
</ul>
<h2 id="页表">页表</h2>
<p>每个进程有一个独立的页表结构来维护 VAS 中的虚拟页在对应物理内存中的映射状态。</p>
<p>页表本身维护在物理内存中，其内部由多个 PTE （Page Table Entry） 组成，每个虚拟页对应一个 PTE 。</p>
<p>CPU、MMU、页表、物理内存和磁盘五者之间的协作关系如下图：</p>
<p><img src="/image/learn_c/26_4.webp" alt="PTE"></p>
<h2 id="多级页表">多级页表</h2>
<p><img src="/image/learn_c/26_5.webp" alt="multi_level_page_table"></p>
<p>多级页表节省空间的最重要的两个因素是：</p>
<ol>
<li>当一级页表某个PTE 没有实际映射时，其对应的二级页表便不会被创建</li>
<li>只有一级页表才需要常驻内存，二级页表仅在需要时创建或者从磁盘调入</li>
</ol>
<h2 id="tlb">TLB</h2>
<p>TLB (Translation Lookaside Buffer) 是 MMU 的一部分，用来加快虚拟地址查 PTE 的过程。可以简单将 TLB 理解为一个具有 N 行 M 列的矩阵，MMU 会从 虚拟地址中提取用于查询表项的索引和标记，这两个值可以定位到具体单元格，如果单元格有值，则可以与虚拟地址中的其他信息一起组成最终的物理地址；否则仍需要通过主机查询页表的方式获取物理地址。</p>
<h1 id="第二十七讲-静态链接">第二十七讲 静态链接</h1>
<p>示例代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// main.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define LEN 2
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">extern</span> <span class="kt">int</span> <span class="n">sharedArr</span><span class="p">[</span><span class="n">LEN</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="n">array</span> <span class="o">=</span> <span class="n">sharedArr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">LEN</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// sum.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define LEN 2
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">int</span> <span class="n">sharedArr</span><span class="p">[</span><span class="n">LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 gcc 将代码分别编译成二进制可执行文件 main 和目标文件 main.o、sum.o</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">gcc main.c sum.c -o main  <span class="c1"># 生成可执行文件 main；</span>
</span></span><span class="line"><span class="cl">gcc -c main.c -o main.o  <span class="c1"># 生成目标文件 main.o；</span>
</span></span><span class="line"><span class="cl">gcc -c sum.c -o sum.o  <span class="c1"># 生成目标文件 sum.o；</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="目标文件">目标文件</h2>
<p>目标文件是一种被称为”可重定位文件“的 ELF 文件类型。但它不包含 与动视图相关的的多种 Segment 和 Program 头部， 因此不同类型的 Section 便成了用于描述它所有特征的基本结构。</p>
<p><img src="/image/learn_c/27_1.webp" alt="object_file"></p>
<p>可以使用<code>nm</code> 命令查看目标文件中的符号表，符号表包含了所有全局变量和函数信息
<img src="/image/learn_c/27_2.webp" alt="nm_result"></p>
<p>nm 会返回三列数据</p>
<ul>
<li>第一列代表符号在对应 Section 中的偏移量</li>
<li>第二列代表符号的类型，D 代表已初始化的全局数据，位于 .data Section; T 代表函数，位于 .text Section; U 代表符号未定义</li>
<li>第三列代表名称</li>
</ul>
<h2 id="符号解析">符号解析</h2>
<p>编译器编译源码时，会为无法在当前编译单元内找到定义的符号生成一个特定符号表条目。
链接器在随后进行符号解析时会在全局符号表中进行搜索。</p>
<p>如果链接器找到了多个同名定义， 会按照一定规则进行解析。符号有强弱之分，通常函数和已初始化的全局变量为强符号，而未初始化的全局变量为弱符号。</p>
<ul>
<li>如果有一个强符号和多个弱符号，选强符号</li>
<li>如果有多个弱符号，任意选一个（通常选择占用空间最大的）</li>
<li>如果有多个强符号，则报错</li>
</ul>
<p>通过为函数显示添加 <strong>attribute((weak))</strong> 标记可以设置其为弱符号。</p>
<h2 id="重定位">重定位</h2>
<p>符号解析之后，链接器开始将多个目标文件相同类型的Section 进行合并，同时为这些 Section 及 符号指定运行时 VAS 地址。</p>
<p>链接器通过重定位步骤来修改 .data 和 .text 两个 Section 中对每个符号的引用信息，使得它们可以指向正确的运行时地址。</p>
<p>重定位依赖特殊的 Section: .rela.data 和 rela.text, 通常这两个 Section 也称之为重定位表。</p>
<p><img src="/image/learn_c/27_3.webp" alt="readelf"></p>
<p>上图中每列数据含义：</p>
<ul>
<li>Offest: 指目标在 Section 中的偏移</li>
<li>Info:</li>
<li>Type: 指重定位类型</li>
<li>Sym. Value: 当前值</li>
<li>Sym. Name + Addend: 符号名称和修正量</li>
</ul>
<p><img src="/image/learn_c/27_4.webp" alt="relocation_type"></p>
<p>重定位类型如上图，计算方式中 S 表示实际地址，A 表示 Addend，P 表示被修改的具体位置，L 表示在 PLT 中该符号的入口地址。</p>
<p>通过 objdump 可以找到重定向目标的位置</p>
<p>以 R_x86_64_pc32 类型 arrary 举例计算， 验证 “S+A-P” 的计算方式</p>
<p>S 实际地址 可以通过<code>nm</code> 查看, 结果为 0x601020</p>
<p><img src="/image/learn_c/27_5.webp" alt="nm"></p>
<p>A 修正量为 -4</p>
<p>P 修改位置可以通过<code>objdump -M inter -d main</code>查看，40053e未改行机器指令起始位置， 在此基础上加 3个字节（操作指令+寄存器占用？）即可得到重定向的修改位置： 4000541</p>
<p><img src="/image/learn_c/27_6.webp" alt="objdump"></p>
<p><code>0x601020 - 0x4 - 0x400541</code> 结果为 0x200adb,对应大端地址即为 <code>db 01 20 00</code></p>
<h1 id="第二十八讲-动态链接">第二十八讲 动态链接</h1>
<h2 id="共享库">共享库</h2>
<p>能够被动态链接加载的库称之为共享库 Shared Library，在 Linux 中这类库文件以 ”.so“ 后缀结尾</p>
<h2 id="使用示例">使用示例</h2>
<p>已上一讲中 sum.c 和 main.c 两个文件为例，将 sum.c 编译成 动态库，并让 main.c 对应的应用程序使用。</p>
<ol>
<li>使用命令<code>gcc sum.c -shared -fPIC -o libsum.o</code> 编译动态库文件</li>
<li>使用命令<code>gcc -o main main.c -lsum -L.</code>编译应用程序</li>
<li>使用命令<code>export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH</code> 来设置动态链接器查找动态库文件的目录</li>
<li>执行<code>./main</code></li>
<li></li>
</ol>
<h2 id="位置无关代码">位置无关代码</h2>
<p>位置无关代码（Position Independent Code, PIC）是一类特殊的机器代码，这些代码在使用时，可以被放置在每个进程 VAS 中任意位置，而无需链接器对它内部引用的地址进行重定位。</p>
<p>通常可以将模块之间的数据引用分为四种方式:</p>
<ul>
<li>模块内部函数调用</li>
<li>模块内部数据访问</li>
<li>模块之间函数调用</li>
<li>模块之间数据访问</li>
</ul>
<p>模块内部函数调用一般以 PC 寄存器寻址方式进行，不依赖 VAS 内的绝对地址。</p>
<p>模块内部数据访问时由于.data 和 .text 是相对固定的，数据访问也可以使用相对稳定的地址进行。</p>
<h2 id="全局偏移表">全局偏移表</h2>
<p>全局偏移表（Global Offset Table， GOT）是位于每个模块 Data Segment起始位置处的一个特殊结构，其内部的每个表项都存放一个地址信息，这些地址对应这被当前
模块引用的外部函数或者变量在 VAS 中的实际地址。</p>
<p>当程序被加载进内存时，动态连接器根据实际情况，通过修正 GOT 中的值，来修正代码对应符号的实际引用地址</p>
<p><img src="/image/learn_c/28_1.webp" alt="GOT"></p>
<h2 id="过程链接表">过程链接表</h2>
<p>过程链接表 （Procedure Linkage Table, PLT） 是位于 Text Segment 中的一个表结构。其中 第一表项 PT[0] 内部存放的代码专门用于调用动态连链接器，而其他表项则依次存放着用于完成用户函数调用过程相关的代码，这些表项的地址将被 call 指令直接使用。</p>
<h2 id="加载时链接">加载时链接</h2>
<p>动态连接器进行的符号重定位发生在程序代码被真正执行之前</p>
<h2 id="运行时链接">运行时链接</h2>
<p>程序可以自动选择想要加载的共享库模块，并在不使用时卸载。动态链接主要使用
dlopen、dlsym、、dlerror、dlclose 四个接口实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;dlfcn.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">typedef</span> <span class="nf">double</span> <span class="p">(</span><span class="o">*</span><span class="kt">cos_t</span><span class="p">)(</span><span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">cos_t</span> <span class="n">cosine</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span><span class="o">*</span> <span class="n">handle</span> <span class="o">=</span> <span class="nf">dlopen</span><span class="p">(</span><span class="s">&#34;libm.so.6&#34;</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">dlerror</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="nf">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">dlerror</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">cosine</span> <span class="o">=</span> <span class="p">(</span><span class="kt">cos_t</span><span class="p">)</span> <span class="nf">dlsym</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="s">&#34;cos&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">error</span> <span class="o">=</span> <span class="nf">dlerror</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%f</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">cosine</span><span class="p">)(</span><span class="mf">2.0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="nf">dlclose</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="第二十九讲-c-程序入口">第二十九讲 C 程序入口</h1>
<h2 id="真正的入口函数">真正的入口函数</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// main.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/image/learn_c/29_1.webp" alt="objdump"></p>
<p>可以从图中看到，程序首先从 _start 开始执行</p>
<h3 id="_start">_start</h3>
<p>_start 是链接器在生成目标可执行文件时，默认使用的一个符号名称。链接器在链接时会在全局符号表中找到该符号，并将虚拟地址拷贝到 ELF 头的 e_entry 字段中。</p>
<p>可以通过命令<code>ld --verbose</code>查看</p>
<p><img src="/image/learn_c/29_2.webp" alt="ld_verbose"></p>
<p>_start 符号具体定义来自 crt1.o 文件</p>
<p>编译时带”-v“ 参数可是看到相关信息</p>
<p><img src="/image/learn_c/29_3.webp" alt="gcc_verbose"></p>
<h3 id="_start-作用">_start 作用</h3>
<p>crt1.o 是 C 运行时库 （C Runtime Library CRT） 提供的一个用于辅助应用程序正常运行的特殊文件，汇编代码见<a href="https://github.com/bminor/glibc/blob/b92a49359f33a461db080a33940d73f47c756126/sysdeps/x86_64/start.S">文件</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="c1">#include &lt;sysdep.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nf">ENTRY</span> <span class="p">(</span><span class="no">_start</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">cfi_undefined</span> <span class="p">(</span><span class="no">rip</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">xorl</span> <span class="nv">%ebp</span><span class="p">,</span> <span class="nv">%ebp</span>  <span class="cm">/* 复位 ebp */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span> <span class="nv">%RDX_LP</span><span class="p">,</span> <span class="nv">%R9_LP</span>   <span class="cm">/* 保存 FINI 函数的地址到 r9 */</span>
</span></span><span class="line"><span class="cl"><span class="c1">#ifdef __ILP32__
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/* 模拟 ILP32 模型下的栈操作，将位于栈顶的 argc 放入 rsi */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span> <span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%esi</span>  
</span></span><span class="line"><span class="cl">  <span class="no">add</span> <span class="no">$4</span><span class="p">,</span> <span class="nv">%esp</span>  <span class="cm">/* 同时让栈顶向高地址移动 4 字节 */</span>
</span></span><span class="line"><span class="cl"><span class="c1">#else
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">popq</span> <span class="nv">%rsi</span>  <span class="cm">/* 将位于栈顶的 argc 放入 rsi */</span>
</span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">mov</span> <span class="nv">%RSP_LP</span><span class="p">,</span> <span class="nv">%RDX_LP</span>  <span class="cm">/* 将 argv 放入 rdx */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">and</span> <span class="no">$</span><span class="err">~</span><span class="mi">15</span><span class="p">,</span> <span class="nv">%RSP_LP</span>  <span class="cm">/* 对齐栈到 16 字节 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">pushq</span> <span class="nv">%rax</span>  <span class="cm">/* 将 rax 的值存入栈中，以用于在函数调用前保持对齐状态 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">pushq</span> <span class="nv">%rsp</span>  <span class="cm">/* 将当前栈顶地址存入栈中 */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">xorl</span> <span class="nv">%r8d</span><span class="p">,</span> <span class="nv">%r8d</span>  <span class="cm">/* 复位 r8 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">xorl</span> <span class="nv">%ecx</span><span class="p">,</span> <span class="nv">%ecx</span>  <span class="cm">/* 复位 ecx */</span>
</span></span><span class="line"><span class="cl"><span class="c1">#ifdef PIC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/* 将 GOT 表项中的 main 函数地址存放到 rdi */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span> <span class="no">main@GOTPCREL</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%RDI_LP</span>  
</span></span><span class="line"><span class="cl"><span class="c1">#else
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">mov</span> <span class="no">$main</span><span class="p">,</span> <span class="nv">%RDI_LP</span>  <span class="cm">/* 将 main 函数的绝对地址存放到 rdi */</span>
</span></span><span class="line"><span class="cl"><span class="c1">#endif
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="cm">/* 调用 __libc_start_main 函数 */</span>
</span></span><span class="line"><span class="cl">  <span class="nf">call</span> <span class="p">*</span><span class="no">__libc_start_main@GOTPCREL</span><span class="p">(</span><span class="nv">%rip</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nf">hlt</span>  
</span></span><span class="line"><span class="cl"><span class="no">END</span> <span class="p">(</span><span class="no">_start</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="na">.data</span>
</span></span><span class="line"><span class="cl">  <span class="na">.globl</span> <span class="no">__data_start</span>
</span></span><span class="line"><span class="cl"><span class="nl">__data_start:</span>
</span></span><span class="line"><span class="cl">  <span class="na">.long</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">  <span class="na">.weak</span> <span class="no">data_start</span>
</span></span><span class="line"><span class="cl">  <span class="nf">data_start</span> <span class="err">=</span> <span class="no">__data_start</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>_libc_start_main 函数原型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">__libc_start_main</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">main</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">                      <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                      <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">init</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">                      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fini</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">                      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">rtld_fini</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">                      <span class="kt">void</span> <span class="o">*</span><span class="n">stack_end</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>_libc_start_main 会为用户代码的执行做一些前期准备工作</p>
<ul>
<li>执行对用户ID的必要安全性检查</li>
<li>初始化线程子系统</li>
<li>注册 rtld_fini 函数，以便在动态共享对象退出是释放资源</li>
<li>注册 fini 处理程序，以便在程序退出时执行</li>
<li>调用初始化函数 init</li>
<li>调用 main 函数</li>
<li>用 main 的返回值调用 exit 函数</li>
</ul>
<h2 id="crt">CRT</h2>
<p>CRT（C Runtime Library CRT） 为应用程序提供了对启动与退出、C 标准库函数、IO、堆、C 语言特殊实现、调试等多方面功能的实现和支持。</p>
<ul>
<li>crt1.o 提供了 _start 符号的具体实现，仅参与可执行文件的编译过程</li>
<li>crti.o 和 crtn.o 两者通过协作，为共享对象提供了可以使用”构造函数“和”析构函数“的能力</li>
<li>crtbegin.o 和 crtend.o 分别提供了 ”构造函数“和”析构函数“的实现</li>
</ul>
<h1 id="第三十讲-abi-和-api">第三十讲 ABI 和 API</h1>
<h2 id="api">API</h2>
<p>API（Application Programming Interface）侧重点在于编程，通过遵循 API  规范，可以在相应的编程语言代码中使用这些接口。
对于 C 语言来说，标准库头文件中的函数原型便是一种 API 的具体表现， glibc 和 musl 是其的具体实现。</p>
<p>API 的重要特征是提供相应功能的同时隐藏实现细节，让使用者可以按照较为统一和稳定的方式来使用系统的能力。</p>
<h2 id="abi">ABI</h2>
<p>ABI（Application Bianry Interface）侧重点在于机器指令层面的具体格式，
ABI 将程序、操作系统、硬件平台之间协作需要遵守的特定规则暴露出来。这些规则指定这个体系运行的二进制应用程序应该如何在机器代码层面进行数据访问或函数调用。</p>
<p>API 规范通常涵盖如下内容：</p>
<ul>
<li>函数调用规范</li>
<li>处理器可以访问的数据类型的大小和对齐方式</li>
<li>进程初始化细节（如栈和寄存器的状态变化）</li>
<li>对象文件（如 .o）的基本结构</li>
<li>程序载入和动态链接的细节</li>
</ul>
<h1 id="第三十一讲-程序和操作系统交互">第三十一讲 程序和操作系统交互</h1>
<h2 id="什么是系统调用">什么是系统调用</h2>
<p>系统调用是由操作系统内核封装过的一些可供上层应用程序使用的接口</p>
<p>以 getpid 函数具体</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;syscall.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="kt">pid_t</span> <span class="nf">getpid</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nf">__syscall</span><span class="p">(</span><span class="n">SYS_getpid</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>__syscall 对应的汇编实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="na">.global</span> <span class="no">__syscall</span>
</span></span><span class="line"><span class="cl"><span class="na">.type</span> <span class="no">__syscall</span><span class="p">,</span><span class="na">@function</span>
</span></span><span class="line"><span class="cl"><span class="nl">__syscall:</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="nv">%rdi</span><span class="p">,</span> <span class="nv">%rax</span>  <span class="c1">// 将函数对应的ID 存放到 rax 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">movq</span> <span class="nv">%rsi</span><span class="p">,</span> <span class="nv">%rdi</span>  <span class="c1">// 将函数参数存放对寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">movq</span> <span class="nv">%rdx</span><span class="p">,</span> <span class="nv">%rsi</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="nv">%rcx</span><span class="p">,</span> <span class="nv">%rdx</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="nv">%r8</span><span class="p">,</span> <span class="nv">%r10</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="nv">%r9</span><span class="p">,</span> <span class="nv">%r8</span>
</span></span><span class="line"><span class="cl">  <span class="nf">movq</span> <span class="mi">8</span><span class="p">(</span><span class="nv">%rsp</span><span class="p">),</span> <span class="nv">%r9</span>
</span></span><span class="line"><span class="cl">  <span class="nf">syscall</span>  <span class="c1">// 执行指令
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">ret</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="系统调用和用户函数">系统调用和用户函数</h2>
<p>两者最大区在在于 系统调用执行的代码位于操作系统底层的内核环境中，而用户代码则位于内核之上的应用环境中。</p>
<p>在 x86 架构中， 特权级别分为四个层次</p>
<p><img src="/image/learn_c/31_1.webp" alt="protection_rings"></p>
<p>不同特权级别，CPU 能被允许执行的机器指令和使用的起存器不同</p>
<h2 id="系统调用实现">系统调用实现</h2>
<p>可以使用 int 实现系统调用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl"><span class="nf">extern</span> <span class="no">sub</span>
</span></span><span class="line"><span class="cl"><span class="nf">global</span> <span class="no">_start</span>
</span></span><span class="line"><span class="cl"><span class="nf">section</span> <span class="no">.text</span>
</span></span><span class="line"><span class="cl"><span class="nl">_start:</span>
</span></span><span class="line"><span class="cl">  <span class="nf">and</span>   <span class="no">rsp</span><span class="p">,</span><span class="mi">0xfffffffffffffff0</span>  <span class="c1">// 16位对齐
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">mov</span>   <span class="no">esi</span><span class="p">,</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">  <span class="nf">mov</span>   <span class="no">edi</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="nf">call</span>  <span class="no">sub</span>
</span></span><span class="line"><span class="cl">  <span class="c1"># use &#34;int&#34; to invoke a system call.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nf">mov</span>   <span class="no">ebx</span><span class="p">,</span> <span class="no">eax</span>  
</span></span><span class="line"><span class="cl">  <span class="no">mov</span>   <span class="no">eax</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">  <span class="nf">int</span>   <span class="mi">0x80</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码执行过程如图</p>
<p><img src="/image/learn_c/31_2.webp" alt="syscall"></p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">PPD</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2022-05-08
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://ppd0705.github.io/tags/c/">C</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/2021_summary/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">2021年终总结</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/noip_expirence/">
            <span class="next-text nav-default">非典型 NOIP 经历</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  
    <div class="post bg-white">
  <script
    src="https://giscus.app/client.js"
    data-repo="ppd0705/ppd0705.github.io"
    data-repo-id="MDEwOlJlcG9zaXRvcnkxOTQzMDc0OTg="
    data-category="Announcements"
    data-category-id="DIC_kwDOC5Tlqs4CTCC0"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="light"
    data-lang="en"
    
    crossorigin="anonymous"
    async
  ></script>
</div>

  

  
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:ppd0705@icloud.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://twitter.com/ppd0705" rel="me noopener" class="iconfont"
      title="twitter"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1264 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M1229.8616 18.043658c0 0-117.852626 63.135335-164.151872 67.344358-105.225559-164.151872-505.082682-92.598492-437.738325 223.078185C278.622548 312.675223 89.216542 47.506814 89.216542 47.506814s-117.852626 189.406006 75.762402 345.139833C127.097743 396.85567 55.544363 371.601535 55.544363 371.601535S26.081207 535.753407 253.368414 615.724832c-21.045112 29.463156-113.643603 8.418045-113.643603 8.418045s25.254134 143.10676 231.496229 180.987961c-143.10676 130.479693-387.230056 92.598492-370.393967 105.225559 206.242095 189.406006 1119.599946 231.496229 1128.01799-643.98042C1179.353331 249.539887 1263.533778 123.269217 1263.533778 123.269217s-130.479693 37.881201-138.897738 33.672179C1225.652577 98.015083 1229.8616 18.043658 1229.8616 18.043658"></path>
</svg>

    </a>
  
    <a href="https://www.linkedin.com/in/ppd0705" rel="me noopener" class="iconfont"
      title="linkedin"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="33" height="33">
  <path d="M872.405333 872.618667h-151.637333v-237.610667c0-56.661333-1.152-129.578667-79.018667-129.578667-79.061333 0-91.136 61.653333-91.136 125.397334v241.792H398.976V384h145.664v66.602667h1.962667c20.352-38.4 69.845333-78.933333 143.786666-78.933334 153.642667 0 182.058667 101.12 182.058667 232.746667v268.202667zM227.712 317.141333a87.978667 87.978667 0 0 1-88.021333-88.106666 88.064 88.064 0 1 1 88.021333 88.106666z m76.032 555.477334H151.68V384h152.064v488.618667zM948.266667 0H75.562667C33.792 0 0 33.024 0 73.770667v876.458666C0 991.018667 33.792 1024 75.562667 1024h872.576C989.866667 1024 1024 991.018667 1024 950.229333V73.770667C1024 33.024 989.866667 0 948.138667 0h0.128z"></path>
</svg>

    </a>
  
    <a href="https://github.com/ppd0705" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>
  
    <a href="https://www.douban.com/people/ppd0705/" rel="me noopener" class="iconfont"
      title="douban"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M926.917973 37.80608C959.65184 37.80608 986.19392 64.34816 986.19392 97.082027L986.19392 926.917973C986.19392 959.65184 959.65184 986.19392 926.917973 986.19392L97.082027 986.19392C64.34816 986.19392 37.80608 959.65184 37.80608 926.917973L37.80608 97.082027C37.80608 64.34816 64.34816 37.80608 97.082027 37.80608zM176.653653 176.19968 176.653653 252.678827 825.658027 252.678827 825.658027 176.19968zM217.719467 316.146347 217.719467 628.08064 273.524053 628.08064 341.292373 770.39616 157.259093 770.39616 157.259093 845.417813 842.949973 845.417813 842.949973 770.39616 654.226773 770.39616 722.899627 628.08064 783.67744 628.08064 783.67744 316.146347zM684.885333 392.891733 684.885333 553.987413 312.576 553.987413 312.576 392.891733zM570.770773 770.39616 426.653013 770.39616 359.621973 628.08064 639.443627 628.08064z"></path>
</svg>

    </a>


<a href="https://ppd0705.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2019 -
    2025
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        PPD
        
      </span></span>

  
  
    <span id="busuanzi_container">
      访客数/访问量：<span id="busuanzi_value_site_uv"></span>/<span id="busuanzi_value_site_pv"></span>
    </span>
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>












</body>
</html>
