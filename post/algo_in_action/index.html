<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>[笔记]业务开发算法 50 讲 - PPD&#39;s blog</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="PPD" />
  <meta name="description" content="第零讲 git diff 文本差分算法 定义 git diff 内置了多种算法 ，这里介绍的是其默认算法 Myers 差分算法。 An edit script for A and B is a set of insertion and deletion commands that transform A into B. 文本差分算法可以定义" />

  <meta name="keywords" content="PPD, blog" />






<meta name="generator" content="Hugo 0.108.0" />


<link rel="canonical" href="https://ppd0705.github.io/post/algo_in_action/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.b3a8813c06e6d785beba22bf8264e174fa2cb3a396b22f9ba24e2c00c18aaf7f.css" integrity="sha256-s6iBPAbm14W&#43;uiK/gmThdPoss6OWsi&#43;bok4sAMGKr38=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="[笔记]业务开发算法 50 讲" />
<meta property="og:description" content="第零讲 git diff 文本差分算法 定义 git diff 内置了多种算法 ，这里介绍的是其默认算法 Myers 差分算法。 An edit script for A and B is a set of insertion and deletion commands that transform A into B. 文本差分算法可以定义" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ppd0705.github.io/post/algo_in_action/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-14T08:36:33+08:00" />
<meta property="article:modified_time" content="2022-08-20T16:51:33+08:00" />
<meta itemprop="name" content="[笔记]业务开发算法 50 讲">
<meta itemprop="description" content="第零讲 git diff 文本差分算法 定义 git diff 内置了多种算法 ，这里介绍的是其默认算法 Myers 差分算法。 An edit script for A and B is a set of insertion and deletion commands that transform A into B. 文本差分算法可以定义"><meta itemprop="datePublished" content="2022-03-14T08:36:33+08:00" />
<meta itemprop="dateModified" content="2022-08-20T16:51:33+08:00" />
<meta itemprop="wordCount" content="11524">
<meta itemprop="keywords" content="算法," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[笔记]业务开发算法 50 讲"/>
<meta name="twitter:description" content="第零讲 git diff 文本差分算法 定义 git diff 内置了多种算法 ，这里介绍的是其默认算法 Myers 差分算法。 An edit script for A and B is a set of insertion and deletion commands that transform A into B. 文本差分算法可以定义"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">PPD's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/about">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      PPD's blog
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/about">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">[笔记]业务开发算法 50 讲</h1>
      
      <div class="post-meta">
        <time datetime="2022-03-14" class="post-time">
          2022-03-14
        </time>
        <div class="post-category">
            <a href="https://ppd0705.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"> 计算机 </a>
            
          </div>
        <span class="more-meta"> 11524 words </span>
          <span class="more-meta"> 24 min read </span>

        
        
          <span id="busuanzi_container_page_pv">
            | 阅读 <span id="busuanzi_value_page_pv"></span>
          </span>
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#第零讲-git-diff-文本差分算法">第零讲 git diff 文本差分算法</a>
      <ul>
        <li><a href="#定义">定义</a></li>
        <li><a href="#评价指标">评价指标</a>
          <ul>
            <li><a href="#编辑脚本长度">编辑脚本长度</a></li>
            <li><a href="#可读性">可读性</a></li>
          </ul>
        </li>
        <li><a href="#模型抽象">模型抽象</a>
          <ul>
            <li><a href="#转化成图搜索问题">转化成图搜索问题</a></li>
            <li><a href="#如何解决图搜索">如何解决图搜索</a></li>
          </ul>
        </li>
        <li><a href="#代码实现">代码实现</a></li>
      </ul>
    </li>
    <li><a href="#第一讲-动态数组-vector">第一讲 动态数组 vector</a>
      <ul>
        <li><a href="#数组与内存">数组与内存</a></li>
        <li><a href="#动态数组">动态数组</a>
          <ul>
            <li><a href="#vector-源码分析">Vector 源码分析</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第二讲-双向链表-list">第二讲 双向链表 list</a>
      <ul>
        <li><a href="#链表简介">链表简介</a></li>
        <li><a href="#链表种类">链表种类</a></li>
        <li><a href="#stl-list-实现">STL list 实现</a>
          <ul>
            <li><a href="#节点实现">节点实现</a></li>
            <li><a href="#迭代器实现">迭代器实现</a></li>
            <li><a href="#数据结构实现">数据结构实现</a></li>
            <li><a href="#基本操作实现">基本操作实现</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第三讲-双端队列">第三讲 双端队列</a>
      <ul>
        <li><a href="#队列">队列</a></li>
        <li><a href="#双端队列">双端队列</a></li>
        <li><a href="#deque-实现">Deque 实现</a>
          <ul>
            <li><a href="#内存布局">内存布局</a></li>
            <li><a href="#迭代器">迭代器</a></li>
            <li><a href="#基础操作">基础操作</a>
              <ul>
                <li><a href="#push-操作">push 操作</a></li>
                <li><a href="#pop--操作">pop  操作</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第四讲-栈">第四讲 栈</a>
      <ul>
        <li><a href="#特性-lifo">特性： LIFO</a></li>
        <li><a href="#stl-实现">STL 实现</a>
          <ul>
            <li><a href="#数据结构定义">数据结构定义</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第五讲-hashmap">第五讲 HashMap</a>
      <ul>
        <li><a href="#散列">散列</a></li>
        <li><a href="#jdk-实现">JDK 实现</a>
          <ul>
            <li><a href="#hash-方法">hash 方法</a></li>
            <li><a href="#-h--16">^ h &raquo;&gt; 16</a></li>
            <li><a href="#table-实现">table 实现</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第六讲-红黑树">第六讲 红黑树</a>
      <ul>
        <li><a href="#二分查找树">二分查找树</a></li>
        <li><a href="#平衡二分查找树">平衡二分查找树</a></li>
        <li><a href="#2-3-树">2-3 树</a></li>
        <li><a href="#红黑树">红黑树</a>
          <ul>
            <li><a href="#旋转操作">旋转操作</a></li>
            <li><a href="#2-节点插入">2 节点插入</a></li>
            <li><a href="#3-节点插入">3 节点插入</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第七讲-堆">第七讲 堆</a>
      <ul>
        <li><a href="#优先队列">优先队列</a></li>
        <li><a href="#二叉堆">二叉堆</a></li>
        <li><a href="#priorityqueue-实现">PriorityQueue 实现</a>
          <ul>
            <li><a href="#堆的操作">堆的操作</a>
              <ul>
                <li><a href="#插入">插入</a></li>
                <li><a href="#删除">删除</a></li>
                <li><a href="#扩容">扩容</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第八讲-外部排序">第八讲 外部排序</a>
      <ul>
        <li><a href="#常见排序算法">常见排序算法</a></li>
        <li><a href="#外部排序">外部排序</a></li>
        <li><a href="#运行时间">运行时间</a></li>
        <li><a href="#败者树">败者树</a></li>
      </ul>
    </li>
    <li><a href="#第九讲-二分法">第九讲 二分法</a>
      <ul>
        <li><a href="#二分查找">二分查找</a></li>
        <li><a href="#kafka">Kafka</a>
          <ul>
            <li><a href="#消息查找">消息查找</a></li>
            <li><a href="#源码实现">源码实现</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第十讲-暴力搜索算法">第十讲 暴力搜索算法</a></li>
    <li><a href="#第十一讲-字符串匹配">第十一讲 字符串匹配</a>
      <ul>
        <li><a href="#brute-force-算法">Brute-Force 算法</a></li>
        <li><a href="#boyer-moore-算法">Boyer-Moore 算法</a>
          <ul>
            <li><a href="#坏字符规则">坏字符规则</a></li>
            <li><a href="#好后缀规则">好后缀规则</a></li>
          </ul>
        </li>
        <li><a href="#bm-算法具体实现">BM 算法具体实现</a>
          <ul>
            <li><a href="#坏字符最右位置计算">坏字符最右位置计算</a></li>
            <li><a href="#好后缀计算">好后缀计算</a></li>
          </ul>
        </li>
        <li><a href="#匹配">匹配</a></li>
      </ul>
    </li>
    <li><a href="#第十二讲-拓扑排序">第十二讲 拓扑排序</a>
      <ul>
        <li><a href="#khan-算法">khan 算法</a></li>
        <li><a href="#dfs">DFS</a></li>
      </ul>
    </li>
    <li><a href="#第十三讲-哈夫曼树">第十三讲 哈夫曼树</a>
      <ul>
        <li><a href="#静态表">静态表</a></li>
        <li><a href="#动态表">动态表</a></li>
        <li><a href="#哈夫曼编码">哈夫曼编码</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h1 id="第零讲-git-diff-文本差分算法">第零讲 git diff 文本差分算法</h1>
<h2 id="定义">定义</h2>
<p>git diff 内置了多种算法 ，这里介绍的是其默认算法 Myers 差分算法。</p>
<blockquote>
<p>An edit script  for A and B is a set of insertion and deletion commands that transform
A into B.</p>
</blockquote>
<p>文本差分算法可以定义为用于求输入源文本到目标文本之间的编辑脚本算法。</p>
<p>编辑脚本是其中一系列插入和删除操作的序列</p>
<h2 id="评价指标">评价指标</h2>
<p>有两个指标可以评价编辑脚本的优劣，分别是编辑脚本的长度、可读性</p>
<h3 id="编辑脚本长度">编辑脚本长度</h3>
<p>编辑脚本较短时，尽可能的保留了更多原序列中的元素。</p>
<p>最短编辑脚本（SES Shortest Edit Script）和 最长公共子序列问题其实是对偶问题</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">源序列 
</span></span><span class="line"><span class="cl">S = ABCABBA length m = 7
</span></span><span class="line"><span class="cl">目标序列
</span></span><span class="line"><span class="cl">T = CBABAC  length n = 6
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">最长公共子序列(不唯一)
</span></span><span class="line"><span class="cl">C = CBBA    length LC = 4 
</span></span></code></pre></td></tr></table>
</div>
</div><p>从上面的例子可以看出 SES 的长度等于 <code>m + n - 2 * LC</code></p>
<h3 id="可读性">可读性</h3>
<p>可读性可以总结为两点：</p>
<ol>
<li>尽可能保留整段文本，尽可能连续删除和插入，而不是彼此交叉</li>
<li>大部分人习惯先看到原文本删除，再看到目标文本的插入</li>
</ol>
<p>所以总结算法逻辑就是：在最短的编辑脚本里，尽量找到删除在增加前面，且尽可能多的连续删除更多行的方式。</p>
<h2 id="模型抽象">模型抽象</h2>
<p>从源序列 S 到目标序列 T，有删除和插入两种操作，我们需要找到一种对这两个操作和相应变换状态的抽象方式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">源序列 
</span></span><span class="line"><span class="cl">S = ABCABBA length m = 7
</span></span><span class="line"><span class="cl">目标序列
</span></span><span class="line"><span class="cl">T = CBABAC  length n = 6
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="转化成图搜索问题">转化成图搜索问题</h3>
<p><img src="/image/algo_in_action/0_1.webp" alt="graph_search"></p>
<p>Myers 将问题转化为图搜索问题 ，其中横轴代表源序列，纵轴代表目标序列，
坐标 (0, 0) 代表初始状态，(m, n) 则对应了最终完整的从 S 到 T 的 编辑脚本 。
横向移动代表删除操作，纵向移动代表插入操作。</p>
<p><img src="/image/algo_in_action/0_2.webp" alt="graph_search2"></p>
<p>如上图所示，从 (0, 0) 到 (3，4) 的路径表示字符串 ABC &ndash;&gt; CBAB 的一种编辑方式，
我们先插入 CB，然后删除 AB，再插入 AB，最后删除 C。</p>
<p>这样文本差分问题就转化成了如何在这样的网格中找到仅允许向下和向右移动的一个从
(0, 0) 到 (m, n) 的路径，路径的长度就代表了总共需要的操作数。</p>
<p>对于源序列和目标序列字符相等的坐标，如 (2, 0) 和 (3, 1)、(0, 2) 和 (2，4) 等，
这种斜线路径不耗费任何操作数。如下图为一条最短路径的例子：</p>
<p><img src="/image/algo_in_action/0_3.webp" alt="graph_search3"></p>
<h3 id="如何解决图搜索">如何解决图搜索</h3>
<p><img src="/image/algo_in_action/0_4.webp" alt="graph_search4"></p>
<p>Myers 论文中有几个重要的概念</p>
<ul>
<li>D-path: 需要 D 步操作的路径称之为 D-Path</li>
<li>snake: 一个横线或竖线之后紧跟着 n 条斜线所形成的的路径为 snake，snake 操作数为 1，且 snake 结尾坐标后继不能为斜线。</li>
<li>line: 从左上到右下的 45 度的斜线，可以用 k = x - y 表示， 在 m * n 的网格中，k 的取值范围为 [-n, m]。</li>
</ul>
<p>Myers 论文中原图对上面的几个概念示意：</p>
<p><img src="/image/algo_in_action/0_5.webp" alt="graph_search5"></p>
<p>这样我们求解最短编辑脚本的目标就可以定义为找最短到达 (m, n) 的 D-path。</p>
<p>所有的 D-path 都是 (D-1)-path 加一条 snake 构成，这样我们可以从 1-path 出发，
去搜索所有 2-path 最远能走到哪，然后一直递推到 D-path，第一次遇到终点时，就找到最短路径了。</p>
<p>当有多条 D-path 时，我们如何选可读性最好的路径呢？
基于先看到删除再看到插入的原则，在考虑 D-path时，会从多条 (D-1)-path 中选出横坐标更大的路径。</p>
<h2 id="代码实现">代码实现</h2>
<p>我们使用一个二维数组 dp 来记录图上的搜索状态</p>
<ul>
<li>dp 第一个维度代表操作数，最大操作范围是我们最短编辑脚本的长度 m + n - 2 * LC</li>
<li>dp 第二个维度代表 k-line 的行号，在 操作数为 d 时， 其取值范围是 [-d, d]</li>
<li>dp 的值代表对应的 x 坐标 （相应可以推算出 y 坐标）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">     |      0     1     2     3     4     5
</span></span><span class="line"><span class="cl">----+--------------------------------------
</span></span><span class="line"><span class="cl">    |
</span></span><span class="line"><span class="cl"> 4  |                             7,3
</span></span><span class="line"><span class="cl">    |                           /
</span></span><span class="line"><span class="cl"> 3  |                       5,2
</span></span><span class="line"><span class="cl">    |                     /
</span></span><span class="line"><span class="cl"> 2  |                 [3,1]       [7,5]
</span></span><span class="line"><span class="cl">    |               /     \     /     \
</span></span><span class="line"><span class="cl"> 1  |           [1,0]       [5,4]      [7,6]
</span></span><span class="line"><span class="cl">    |         /     \           \
</span></span><span class="line"><span class="cl"> 0  |     [0,0]       2,2         5,5
</span></span><span class="line"><span class="cl">    |         \                       \
</span></span><span class="line"><span class="cl">-1  |           0,1         4,5         5,6
</span></span><span class="line"><span class="cl">    |               \     /     \
</span></span><span class="line"><span class="cl">-2  |                 2,4         4,6
</span></span><span class="line"><span class="cl">    |                     \
</span></span><span class="line"><span class="cl">-3  |                       3,6
</span></span></code></pre></td></tr></table>
</div>
</div><p>操作数为 d，行号为 k 的状态只能从相邻的两行 k-1 横线过来（x+1）或者 k+1 竖线过来（x不变）。</p>
<p>因为整个数的结构是二叉的 ，奇数步数时必然处于奇数行号，偶数步数时必然处于偶数行号，
这是因为每进行一步 snake 时，只会有一次删除或插入操作，所以 k 的遍历步长是 2 。</p>
<p>状态转移方程就是 dp[d][k] = max(dp[d-1][k-1]+1, dp[d-1][k+1])，即多个路径状选横坐标 x 最大的。</p>
<p>由于操作数 d 的状态计算只依赖 d-1 的状态数组，所以可以压缩一下空间使用一维数组记录即可。</p>
<p>伪代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">V[1]←0 
</span></span><span class="line"><span class="cl">For D ← 0 to MAX Do
</span></span><span class="line"><span class="cl">  For k ← −D to D in steps of 2 
</span></span><span class="line"><span class="cl">    Do If k=−D or k≠D and V[k−1] &lt; V[k+1] Then
</span></span><span class="line"><span class="cl">      x ← V[k+1] 
</span></span><span class="line"><span class="cl">    Else
</span></span><span class="line"><span class="cl">      x ← V[k−1]+1 y ← x−k
</span></span><span class="line"><span class="cl">    While x &lt; N and y &lt; M and a[x+1] = b[y+1] Do 
</span></span><span class="line"><span class="cl">      (x,y) ← (x+1,y+1) 
</span></span><span class="line"><span class="cl">      V[k] ← x
</span></span><span class="line"><span class="cl">  If x ≥ N and y ≥ M Then
</span></span><span class="line"><span class="cl">    Length of an SES is D
</span></span><span class="line"><span class="cl">    Stop
</span></span></code></pre></td></tr></table>
</div>
</div><p>python 版代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">git_diff</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="s2">&#34; &#34;</span> <span class="o">+</span> <span class="n">a</span>
</span></span><span class="line"><span class="cl">    <span class="n">b</span> <span class="o">=</span> <span class="s2">&#34; &#34;</span> <span class="o">+</span> <span class="n">b</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="n">break_out</span> <span class="o">=</span> <span class="kc">False</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="o">-</span><span class="n">d</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="n">d</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">k</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">a</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="n">y</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="n">v</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">break_out</span> <span class="o">=</span> <span class="kc">True</span>
</span></span><span class="line"><span class="cl">                <span class="k">break</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">d</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">break_out</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">d</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="第一讲-动态数组-vector">第一讲 动态数组 vector</h1>
<h2 id="数组与内存">数组与内存</h2>
<p>静态数组是由相同类型的元素线性排列的数据结构，在计算机上会分配一段连续的内存，
对元素进行顺序存储。</p>
<p><img src="/image/algo_in_action/1_1.webp" alt="static_array"></p>
<p>静态数组的插入和 删除的平均复杂度是 O(N)</p>
<p><img src="/image/algo_in_action/1_2.webp" alt="array_insert"></p>
<p>静态数组的元素个数是事先确定的</p>
<h2 id="动态数组">动态数组</h2>
<p>动态数组将扩容的逻辑分装起来，方便用户使用</p>
<h3 id="vector-源码分析">Vector 源码分析</h3>
<p>vector 中有三个关键指针</p>
<ul>
<li>_start: 指向 vector 第一个元素</li>
<li>_finish: 指向 vector 最后一个元素</li>
<li>_end: 指向 vector 预留容量的边界</li>
</ul>
<p><img src="/image/algo_in_action/1_3.webp" alt="vector_pointers"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Alloc</span> <span class="o">=</span> <span class="n">__STL_DEFAULT_ALLOCATOR</span><span class="p">(</span><span class="n">_Tp</span><span class="p">)</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">vector</span> <span class="o">:</span> <span class="k">protected</span> <span class="n">_Vector_base</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Alloc</span><span class="o">&gt;</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">       <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">_Tp</span><span class="o">*</span> <span class="n">_M_start</span><span class="p">;</span> <span class="c1">//表示目前使用空间的头
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_Tp</span><span class="o">*</span> <span class="n">_M_finish</span><span class="p">;</span> <span class="c1">//表示目前使用空间的尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_Tp</span><span class="o">*</span> <span class="n">_M_end_of_storage</span><span class="p">;</span> <span class="c1">//表示目前可用空间的尾  
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>扩容实现源码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="p">{</span><span class="c1">//在最尾端插入元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">_M_finish</span> <span class="o">!=</span> <span class="n">_M_end_of_storage</span><span class="p">)</span> <span class="p">{</span><span class="c1">//若有可用的内存空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">construct</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">,</span> <span class="n">__x</span><span class="p">);</span><span class="c1">//构造对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="o">++</span><span class="n">_M_finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span><span class="c1">//若没有可用的内存空间,调用以下函数，把x插入到指定位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">_M_insert_aux</span><span class="p">(</span><span class="n">end</span><span class="p">(),</span> <span class="n">__x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Alloc</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> 
</span></span><span class="line"><span class="cl">  <span class="n">vector</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Alloc</span><span class="o">&gt;::</span><span class="n">_M_insert_aux</span><span class="p">(</span><span class="n">iterator</span> <span class="n">__position</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">_M_finish</span> <span class="o">!=</span> <span class="n">_M_end_of_storage</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">construct</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">_M_finish</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">      <span class="o">++</span><span class="n">_M_finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">_Tp</span> <span class="n">__x_copy</span> <span class="o">=</span> <span class="n">__x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">copy_backward</span><span class="p">(</span><span class="n">__position</span><span class="p">,</span> <span class="n">_M_finish</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_M_finish</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="o">*</span><span class="n">__position</span> <span class="o">=</span> <span class="n">__x_copy</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">size_type</span> <span class="n">__old_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="k">const</span> <span class="n">size_type</span> <span class="n">__len</span> <span class="o">=</span> <span class="n">__old_size</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">*</span> <span class="nl">__old_size</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">iterator</span> <span class="n">__new_start</span> <span class="o">=</span> <span class="n">_M_allocate</span><span class="p">(</span><span class="n">__len</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">iterator</span> <span class="n">__new_finish</span> <span class="o">=</span> <span class="n">__new_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">__STL_TRY</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">__new_finish</span> <span class="o">=</span> <span class="n">uninitialized_copy</span><span class="p">(</span><span class="n">_M_start</span><span class="p">,</span> <span class="n">__position</span><span class="p">,</span> <span class="n">__new_start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">construct</span><span class="p">(</span><span class="n">__new_finish</span><span class="p">,</span> <span class="n">__x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">__new_finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">__new_finish</span> <span class="o">=</span> <span class="n">uninitialized_copy</span><span class="p">(</span><span class="n">__position</span><span class="p">,</span> <span class="n">_M_finish</span><span class="p">,</span> <span class="n">__new_finish</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="n">__STL_UNWIND</span><span class="p">((</span><span class="n">destroy</span><span class="p">(</span><span class="n">__new_start</span><span class="p">,</span><span class="n">__new_finish</span><span class="p">),</span> 
</span></span><span class="line"><span class="cl">                    <span class="n">_M_deallocate</span><span class="p">(</span><span class="n">__new_start</span><span class="p">,</span><span class="n">__len</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">      <span class="n">destroy</span><span class="p">(</span><span class="n">begin</span><span class="p">(),</span> <span class="n">end</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="n">_M_deallocate</span><span class="p">(</span><span class="n">_M_start</span><span class="p">,</span> <span class="n">_M_end_of_storage</span> <span class="o">-</span> <span class="n">_M_start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">_M_start</span> <span class="o">=</span> <span class="n">__new_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">_M_finish</span> <span class="o">=</span> <span class="n">__new_finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">_M_end_of_storage</span> <span class="o">=</span> <span class="n">__new_start</span> <span class="o">+</span> <span class="n">__len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>22-25 行，主要做的事情就是读取原有的 vector 大小 old_size，再从内存里申请一段新的空间，大小为 2*old_size，创建新的首尾指针并指向新的空间。</li>
<li>26-31 行，将老空间里的数据逐一搬到新的空间里，并在最后添加新的元素。这样就完成了扩容的主要目的，这是一个 O(n) 复杂度的操作，因为你需要对原数组进行逐一的深拷贝。</li>
<li>最后，在 32-38 行，我们需要做一些清理和收尾工作，释放掉老的数组空间和指针，将容器的首尾及容量指针都更新到对应的位置。</li>
</ul>
<p>假设插入 N 次， 那么总拷贝次数就是 1 加到 2 x 次方， x 是 logn x向上取整</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1 + 2 + 4 + 8 + … + 2 ** x = 2 ** (x+1) − 1
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样插入 N 次的复杂度为 O(N), 平均每次插入操作复杂度为 O(1).</p>
<h1 id="第二讲-双向链表-list">第二讲 双向链表 list</h1>
<h2 id="链表简介">链表简介</h2>
<p>链表同样是一种序列式结构，但无需连续内存，使用通过指针相连的节点来存储。
每个节点分为两个部分，一个是数据域 data field，另外一个是 引用域 reference field。</p>
<p><img src="/image/algo_in_action/2_1.webp" alt="linked_list"></p>
<p>因为通过 指针串联 ，所以在任何位置插入或者删除节点，只需要 O(1) 的复杂度。</p>
<h2 id="链表种类">链表种类</h2>
<p>链表通常有三种形式：单向链表、双向链表、循环链表</p>
<h2 id="stl-list-实现">STL list 实现</h2>
<p>list 是 STL 中的链表容器，实现了双向循环链表</p>
<h3 id="节点实现">节点实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__list_node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__list_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">next</span><span class="p">;</span>  <span class="c1">// 前驱节点指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">__list_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">prev</span><span class="p">;</span> <span class="c1">// 后继节点指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">T</span> <span class="n">data</span><span class="p">;</span> <span class="c1">//存储数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="迭代器实现">迭代器实现</h3>
<p>迭代器提供用于遍历的最重要的接口，支持的操作就是自增和增减</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">__list_iterator</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">__list_iterator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>   <span class="n">self</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="n">__list_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span>      <span class="n">link_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">link_type</span> <span class="n">ptr</span><span class="p">;</span> <span class="c1">//成员
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">__list_iterator</span><span class="p">(</span><span class="n">link_type</span> <span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">)</span><span class="o">:</span><span class="n">ptr</span><span class="p">(</span><span class="n">p</span><span class="p">){}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span> <span class="o">*</span><span class="p">(){</span><span class="k">return</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;}</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span><span class="o">*</span> <span class="k">operator</span> <span class="o">-&gt;</span><span class="p">(){</span><span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="k">operator</span><span class="o">*</span><span class="p">());}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 类似 ++x 返回next节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">self</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 类似 x++ 返回当前节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">self</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">self</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">++*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 类似 --x 返回prev节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">self</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 类似 x-- 返回当前节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">self</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">self</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">--*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">__list_iterator</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ptr</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">__list_iterator</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="o">==</span><span class="n">rhs</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="数据结构实现">数据结构实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">list</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">typedef</span> <span class="n">__list_node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">list_node</span><span class="p">;</span> <span class="c1">// 显示定义list_node类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">typedef</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">list_node</span><span class="o">&gt;</span> <span class="n">nodeAllocator</span><span class="p">;</span> <span class="c1">// 定义allocator类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">typedef</span> <span class="n">T</span>                  <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">typedef</span> <span class="n">T</span><span class="o">&amp;</span>                 <span class="n">reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">typedef</span> <span class="n">value_type</span><span class="o">*</span>        <span class="n">pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">typedef</span> <span class="n">list_node</span><span class="o">*</span>         <span class="n">link_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">typedef</span> <span class="k">const</span> <span class="n">value_type</span><span class="o">*</span>  <span class="n">const_pointer</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">typedef</span> <span class="n">size_t</span>             <span class="n">size_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">typedef</span> <span class="n">__list_iterator</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">iterator</span><span class="p">;</span> <span class="c1">// 迭代器类型重写
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">private</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">link_type</span> <span class="n">node</span><span class="p">;</span> <span class="c1">// 只要一个指针，便可表示整个环状双向链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// ......
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个链表，都会有一个虚拟节点，用于标记整个循环链表的首尾连接处，它是链表的开始，也是链表的结尾，</p>
<p><img src="/image/algo_in_action/2_2.webp" alt="linked_list2"></p>
<p>迭代示例代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span><span class="o">=</span><span class="n">mylist</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span><span class="o">!=</span> <span class="n">mylist</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="基本操作实现">基本操作实现</h3>
<p>初始化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">empty_initialize</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">node</span> <span class="o">=</span> <span class="n">get_node</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span> <span class="c1">// next 指针指向自身
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span> <span class="c1">// prev 指针指向自身
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">link_type</span> <span class="nf">get_node</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nl">list_node_allocator</span><span class="p">:</span><span class="n">allocate</span><span class="p">();</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>插入</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">lik_type</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">create_node</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// 创建一个临时节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">position</span><span class="p">.</span><span class="n">node</span><span class="p">;</span> <span class="c1">// 将该节点的后继指针指向当前位置的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">position</span><span class="p">.</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span> <span class="c1">// 将该节点的前驱指针指向当前位置的前驱节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">(</span><span class="n">link_type</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span> <span class="c1">// 将前驱节点本来指向当前节点的后继指针改为指向该临时节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">position</span><span class="p">.</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span> <span class="c1">// 同样，当前位置的前驱指针也要修改为指向该临时节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>删除</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">link_type</span> <span class="n">next_node</span> <span class="o">=</span> <span class="n">link_type</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">link_type</span> <span class="n">prev_node</span> <span class="o">=</span> <span class="n">link_type</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">prev_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">next_node</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">prev_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">destroy_node</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">iterator</span><span class="p">(</span><span class="n">next_node</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>push / pop</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">pop_front</span><span class="p">()</span> <span class="p">{</span> <span class="n">erase</span><span class="p">(</span><span class="n">begin</span><span class="p">())</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">pop_back</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">iterator</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">end</span><span class="p">();</span> 
</span></span><span class="line"><span class="cl">  <span class="n">erase</span><span class="p">(</span><span class="o">--</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">insert</span><span class="p">(</span><span class="n">end</span><span class="p">(),</span> <span class="n">x</span><span class="p">);</span> <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="第三讲-双端队列">第三讲 双端队列</h1>
<h2 id="队列">队列</h2>
<p>队列是一种先进先出的序列式数据结构</p>
<p><img src="/image/algo_in_action/3_1.webp" alt="queue"></p>
<h2 id="双端队列">双端队列</h2>
<p>双端队列可以在队列的两端都可以进行出队和入队操作</p>
<h2 id="deque-实现">Deque 实现</h2>
<h3 id="内存布局">内存布局</h3>
<p>deque 的内存布局是由一段段连续的空间，
用另一个类似数组的东西将这些空间的地址信息拼接在一起组成的。
在首尾插入和删除数据的复杂度都是 O(1)</p>
<p>deque 既不像 vector 那样每次扩容都需要付出复制和拷贝的高昂代价，
也不会像 list 那样每次插入一个新节点都需要申请一次内存。</p>
<p>deque 使用 map 变量来管理真正用于存储队列元素的一段段连续线性空间</p>
<p><img src="/image/algo_in_action/3_2.webp" alt="deque"></p>
<p>可以认为 map 是一个数组，每个元素指向了一段缓冲区地址，而缓冲区对应了一段指定大小的连续内存空间，默认大小为 512 bytes</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Alloc</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">_Deque_base</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">  <span class="n">_Tp</span><span class="o">**</span> <span class="n">_M_map</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">_M_map_size</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">  <span class="n">iterator</span> <span class="n">_M_start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">iterator</span> <span class="n">_M_finish</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="迭代器">迭代器</h3>
<p>因为 deque 底层实质是分段连续空间，迭代器需要找到相邻的缓冲区以及当前所处位置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ref</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ptr</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">_Deque_iterator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Deque_iterator</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">_Tp</span><span class="o">*&gt;</span>             <span class="n">iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Deque_iterator</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Tp</span><span class="o">*&gt;</span> <span class="n">const_iterator</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">static</span> <span class="n">size_t</span> <span class="nf">_S_buffer_size</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">__deque_buf_size</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">_Tp</span><span class="p">));</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="k">typedef</span> <span class="n">_Tp</span><span class="o">**</span> <span class="n">_Map_pointer</span><span class="p">;</span> <span class="c1">// 缓冲区指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span> 
</span></span><span class="line"><span class="cl">  <span class="n">_Tp</span><span class="o">*</span> <span class="n">_M_cur</span><span class="p">;</span> <span class="c1">// 当前缓冲区的位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_Tp</span><span class="o">*</span> <span class="n">_M_first</span><span class="p">;</span> <span class="c1">// 缓冲区的左边界线
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_Tp</span><span class="o">*</span> <span class="n">_M_last</span><span class="p">;</span> <span class="c1">// 缓冲区的右边界
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">_Map_pointer</span> <span class="n">_M_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">_Deque_iterator</span><span class="p">(</span><span class="n">_Tp</span><span class="o">*</span> <span class="n">__x</span><span class="p">,</span> <span class="n">_Map_pointer</span> <span class="n">__y</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="o">:</span> <span class="n">_M_cur</span><span class="p">(</span><span class="n">__x</span><span class="p">),</span> <span class="n">_M_first</span><span class="p">(</span><span class="o">*</span><span class="n">__y</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">      <span class="n">_M_last</span><span class="p">(</span><span class="o">*</span><span class="n">__y</span> <span class="o">+</span> <span class="n">_S_buffer_size</span><span class="p">()),</span> <span class="n">_M_node</span><span class="p">(</span><span class="n">__y</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">_Self</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">_M_cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">_M_cur</span> <span class="o">==</span> <span class="n">_M_last</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">_M_set_node</span><span class="p">(</span><span class="n">_M_node</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">_M_cur</span> <span class="o">=</span> <span class="n">_M_first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"> <span class="p">}</span>  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"> <span class="kt">void</span> <span class="nf">_M_set_node</span><span class="p">(</span><span class="n">_Map_pointer</span> <span class="n">__new_node</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="n">_M_node</span> <span class="o">=</span> <span class="n">__new_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">_M_first</span> <span class="o">=</span> <span class="o">*</span><span class="n">__new_node</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="n">_M_last</span> <span class="o">=</span> <span class="n">_M_first</span> <span class="o">+</span> <span class="n">difference_type</span><span class="p">(</span><span class="n">_S_buffer_size</span><span class="p">());</span>
</span></span><span class="line"><span class="cl"> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl"><span class="n">_Self</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">_M_cur</span> <span class="o">==</span> <span class="n">_M_first</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">_M_set_node</span><span class="p">(</span><span class="n">_M_node</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="n">_M_cur</span> <span class="o">=</span> <span class="n">_M_last</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">--</span><span class="n">_M_cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="基础操作">基础操作</h3>
<h4 id="push-操作">push 操作</h4>
<ol>
<li>如果当前缓冲区有空间，直接插入</li>
<li>如果 map 有空间，则新建一个缓冲区存入map</li>
<li>如果 map 空间不足，则分为两种情况
<ul>
<li>map 使用率过半，就申请更大的空间，将老的 map 数据拷贝到新区域，map 指向的缓冲区不变</li>
<li>map 使用率小于一半，将数据重新调整到 map 中间的位置</li>
</ul>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span> <span class="o">!=</span> <span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">construct</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span><span class="p">,</span> <span class="n">__t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="o">++</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">      <span class="n">_M_push_back_aux</span><span class="p">(</span><span class="n">__t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Tp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Alloc</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">deque</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="p">,</span><span class="n">_Alloc</span><span class="o">&gt;::</span><span class="n">_M_push_back_aux</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">_M_reserve_map_at_back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_node</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">_M_allocate_node</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">__STL_TRY</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">construct</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_set_node</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_node</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_cur</span> <span class="o">=</span> <span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_first</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">__STL_UNWIND</span><span class="p">(</span><span class="n">_M_deallocate_node</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">_M_finish</span><span class="p">.</span><span class="n">_M_node</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="pop--操作">pop  操作</h4>
<p>如果迭代器和缓冲区的首位置相同，则除了释放当前的内存，还需要释放掉整段缓冲区的内存。</p>
<h1 id="第四讲-栈">第四讲 栈</h1>
<p>栈区是有结构和固定大小的，区块按照次序存放，每个线程独占一个栈区，总大小也是事先确定的。</p>
<h2 id="特性-lifo">特性： LIFO</h2>
<p>栈只能从栈顶删除或者插入元素，所以保证了后进先出的特性</p>
<p><img src="/image/algo_in_action/4_1.webp" alt="stack"></p>
<h2 id="stl-实现">STL 实现</h2>
<p>STL 中使用了 deque 来实现 stack ，这种封装模式称为适配器模式，stack 也被看做是一种
container adapter</p>
<h3 id="数据结构定义">数据结构定义</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">_Tp</span><span class="p">,</span> <span class="k">typename</span> <span class="n">_Sequence</span> <span class="o">=</span> <span class="n">deque</span><span class="o">&lt;</span><span class="n">_Tp</span><span class="o">&gt;</span> <span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">stack</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Sequence</span><span class="o">::</span><span class="n">value_type</span>                <span class="n">value_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Sequence</span><span class="o">::</span><span class="n">reference</span>                 <span class="n">reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Sequence</span><span class="o">::</span><span class="n">const_reference</span>           <span class="n">const_reference</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">_Sequence</span><span class="o">::</span><span class="n">size_type</span>                 <span class="n">size_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">typedef</span>          <span class="n">_Sequence</span>                            <span class="n">container_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">_Sequence</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// stack 底层容器； 默认为 deque
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">     <span class="n">reference</span>
</span></span><span class="line"><span class="cl">      <span class="n">top</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">__glibcxx_requires_nonempty</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">__x</span><span class="p">)</span> <span class="p">{</span> <span class="n">c</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">__x</span><span class="p">);</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span><span class="n">c</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();}</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="第五讲-hashmap">第五讲 HashMap</h1>
<h2 id="散列">散列</h2>
<p>散列函数的本质是将一个更大且可能不连续空间，映射到一个空间有限的数组里，
从而借用数组基于下标 O(1) 快速随机访问数组元素的能力。</p>
<p>但设置一个合理的散列函数是个非常有挑战的事情，比如 26 进制的散列函数就有一个巨大的缺陷，
就是它所需的数组空间太大了，三位长度的元素就需要开一个接近 20000 （26^3）大小的计数数组。</p>
<p><img src="/image/algo_in_action/5_1.webp" alt="hashmap1"></p>
<p>这时我们需要对哈希值进行 取模运算，但取模之后会遇到一个新问题：哈希碰撞。</p>
<h2 id="jdk-实现">JDK 实现</h2>
<h3 id="hash-方法">hash 方法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">hash</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">h</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">hashCode</span><span class="o">())</span> <span class="o">^</span> <span class="o">(</span><span class="n">h</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">16</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>String 类型的 hashCode 方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hash</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hashIsZero</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">h</span> <span class="o">=</span> <span class="n">isLatin1</span><span class="o">()</span> <span class="o">?</span> <span class="n">StringLatin1</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                       <span class="o">:</span> <span class="n">StringUTF16</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">hashIsZero</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">hash</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>StringUTF16 hashCode 实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">h</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">*</span> <span class="n">h</span> <span class="o">+</span> <span class="n">getChar</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// like s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在哈希计算时倾向于用奇素数进行乘法运算，因为使用偶数时相当于进行移位运算，部分位的信息丢失可能增加哈希冲突概率。</p>
<p>使用 31 是因为 31 * i 编译器可以自动转换成 (i &laquo; 5) - i</p>
<h3 id="-h--16">^ h &raquo;&gt; 16</h3>
<p><code>^ h &gt;&gt;&gt; 16</code> 把 高 16位的 信息叠加到低16位，这样在取模的时候就可以用到高位信息，
减少冲突概率。</p>
<h3 id="table-实现">table 实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">transient</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">table</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">V</span> <span class="nf">putVal</span><span class="o">(</span><span class="kt">int</span> <span class="n">hash</span><span class="o">,</span> <span class="n">K</span> <span class="n">key</span><span class="o">,</span> <span class="n">V</span> <span class="n">value</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">onlyIfAbsent</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">               <span class="kt">boolean</span> <span class="n">evict</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">tab</span><span class="o">;</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">;</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="n">i</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//在tab尚未初始化、或者对应槽位链表未初始化时，进行相应的初始化操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">((</span><span class="n">tab</span> <span class="o">=</span> <span class="n">table</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">(</span><span class="n">n</span> <span class="o">=</span> <span class="n">tab</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">=</span> <span class="o">(</span><span class="n">tab</span> <span class="o">=</span> <span class="n">resize</span><span class="o">()).</span><span class="na">length</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">tab</span><span class="o">[</span><span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">hash</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">tab</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span> <span class="n">K</span> <span class="n">k</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 查找 key 对应的节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
</span></span><span class="line"><span class="cl">            <span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">e</span> <span class="o">=</span> <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">p</span><span class="o">).</span><span class="na">putTreeVal</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 遍历所有节点 依次查找
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">binCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">;</span> <span class="o">++</span><span class="n">binCount</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">next</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">(</span><span class="n">hash</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="o">(</span><span class="n">binCount</span> <span class="o">&gt;=</span> <span class="n">TREEIFY_THRESHOLD</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// -1 for 1st
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="n">treeifyBin</span><span class="o">(</span><span class="n">tab</span><span class="o">,</span> <span class="n">hash</span><span class="o">);</span>  <span class="c1">// 链表转化成红黑树
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">==</span> <span class="n">hash</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                    <span class="o">((</span><span class="n">k</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="n">key</span> <span class="o">||</span> <span class="o">(</span><span class="n">key</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">k</span><span class="o">))))</span>
</span></span><span class="line"><span class="cl">                    <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">p</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// existing mapping for key
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">V</span> <span class="n">oldValue</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">(!</span><span class="n">onlyIfAbsent</span> <span class="o">||</span> <span class="n">oldValue</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">e</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">afterNodeAccess</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">oldValue</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">modCount</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(++</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">resize</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">afterNodeInsertion</span><span class="o">(</span><span class="n">evict</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>table 是经过散列之后映射到的内部连续数组，通过 hash 函数的计算，我们可以
基于数组的下标快速访问到 key 对应的元素， 元素存储的是 Node 类型。
Node 的具体实现可以是链表或者红黑树，当链表足够长时，会将链表转化成红黑树。</p>
<p>当table 中元素数量达到阈值时，会触发扩容逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="nf">resize</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">oldTab</span> <span class="o">=</span> <span class="n">table</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">oldCap</span> <span class="o">=</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">oldTab</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">oldThr</span> <span class="o">=</span> <span class="n">threshold</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">newCap</span><span class="o">,</span> <span class="n">newThr</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">MAXIMUM_CAPACITY</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">threshold</span> <span class="o">=</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">oldTab</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="o">((</span><span class="n">newCap</span> <span class="o">=</span> <span class="n">oldCap</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">                 <span class="n">oldCap</span> <span class="o">&gt;=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">newThr</span> <span class="o">=</span> <span class="n">oldThr</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// 翻倍扩容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">oldThr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// 初始化的时候 capacity 设置为初始化阈值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">newCap</span> <span class="o">=</span> <span class="n">oldThr</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="o">{</span>               <span class="c1">// 没有初始化 采用默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">newCap</span> <span class="o">=</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">DEFAULT_LOAD_FACTOR</span> <span class="o">*</span> <span class="n">DEFAULT_INITIAL_CAPACITY</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">newThr</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">ft</span> <span class="o">=</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">newCap</span> <span class="o">*</span> <span class="n">loadFactor</span><span class="o">;</span> <span class="c1">// 用容量乘负载因子表示扩容阈值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">newThr</span> <span class="o">=</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">&lt;</span> <span class="n">MAXIMUM_CAPACITY</span> <span class="o">&amp;&amp;</span> <span class="n">ft</span> <span class="o">&lt;</span> <span class="o">(</span><span class="kt">float</span><span class="o">)</span><span class="n">MAXIMUM_CAPACITY</span> <span class="o">?</span>
</span></span><span class="line"><span class="cl">                  <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">ft</span> <span class="o">:</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">threshold</span> <span class="o">=</span> <span class="n">newThr</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@SuppressWarnings</span><span class="o">({</span><span class="s">&#34;rawtypes&#34;</span><span class="o">,</span><span class="s">&#34;unchecked&#34;</span><span class="o">})</span>
</span></span><span class="line"><span class="cl">    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[]</span> <span class="n">newTab</span> <span class="o">=</span> <span class="o">(</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;[])</span><span class="k">new</span> <span class="n">Node</span><span class="o">[</span><span class="n">newCap</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">table</span> <span class="o">=</span> <span class="n">newTab</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">oldTab</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">oldCap</span><span class="o">;</span> <span class="o">++</span><span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">oldTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">next</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                    <span class="n">newTab</span><span class="o">[</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="o">(</span><span class="n">newCap</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="k">instanceof</span> <span class="n">TreeNode</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                    <span class="o">((</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;)</span><span class="n">e</span><span class="o">).</span><span class="na">split</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">newTab</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">oldCap</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 新扩容部分，标识为hi，原来的部分标识为lo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// JDK 1.8 之后引入用于解决多线程死循环问题 可参考：https://stackoverflow.com/questions/35534906/java-hashmap-getobject-infinite-loop
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">loHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">loTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">hiHead</span> <span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="n">hiTail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="n">Node</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="c1">// 整体操作就是将j所对应的链表拆成两个部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="c1">// 分别放到 j 和 j + oldCap 的槽位
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                    <span class="k">do</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                        <span class="k">if</span> <span class="o">((</span><span class="n">e</span><span class="o">.</span><span class="na">hash</span> <span class="o">&amp;</span> <span class="n">oldCap</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                            <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                                <span class="n">loHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                                <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                            <span class="n">loTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                        <span class="o">}</span>
</span></span><span class="line"><span class="cl">                        <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                            <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                                <span class="n">hiHead</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                                <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                            <span class="n">hiTail</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                        <span class="o">}</span>
</span></span><span class="line"><span class="cl">                    <span class="o">}</span> <span class="k">while</span> <span class="o">((</span><span class="n">e</span> <span class="o">=</span> <span class="n">next</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="o">(</span><span class="n">loTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">loTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">newTab</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">loHead</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="o">}</span>
</span></span><span class="line"><span class="cl">                    <span class="k">if</span> <span class="o">(</span><span class="n">hiTail</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">                        <span class="n">hiTail</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">newTab</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">oldCap</span><span class="o">]</span> <span class="o">=</span> <span class="n">hiHead</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">                    <span class="o">}</span>
</span></span><span class="line"><span class="cl">                <span class="o">}</span>
</span></span><span class="line"><span class="cl">            <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">newTab</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="第六讲-红黑树">第六讲 红黑树</h1>
<h2 id="二分查找树">二分查找树</h2>
<p>每个节点的左节点，要么为空，要么比当前节点小；右节点要么为空，要么比当前节点大。</p>
<p>当树的高度为 h 时，查找的时间复杂度为 O(h)</p>
<h2 id="平衡二分查找树">平衡二分查找树</h2>
<p>在一些情况下，二分查找树可能会退化成链表</p>
<p><img src="/image/algo_in_action/6_1.webp" alt="binary_search_tree"></p>
<p>平衡二分查找树的叶子节点高度差不超过 1</p>
<h2 id="2-3-树">2-3 树</h2>
<p>2-3 树是一种平衡查找树的实现，除了普通的 2 节点外，引入了 3 节点，这为自平衡增加了很大的灵活性。</p>
<p><img src="/image/algo_in_action/6_2.webp" alt="2_3_tree"></p>
<p>3 节点在 2 节点的基础上增加了一个键，构成了一个有两个键和三条链的结构</p>
<p><img src="/image/algo_in_action/6_3.webp" alt="2_3_tree"></p>
<p>在插入过程中，如果遇到 2 节点，直接加个键将该节点升级为 3 节点就好。</p>
<p>遇到 3 节点时，首先将元素放入该节点，使之成为 4 节点，然后将四节点的中间键提升到上层，</p>
<p><img src="/image/algo_in_action/6_4.webp" alt="2_3_tree"></p>
<h2 id="红黑树">红黑树</h2>
<p>红黑树是采用标准的二叉查找树节点并附着颜色信息来表示 2-3 树的实现，每个
红色节点都和它的父节点一起构成了一个 3 节点。</p>
<p>红黑树有如下几个约束：</p>
<ol>
<li>根节点为黑色</li>
<li>相邻节点不能同时为红色</li>
<li>每个节点到各个子节点的黑色节点数量相等</li>
<li>红节点只能作为左节点存在（这是左偏红黑树的要求）</li>
</ol>
<p><img src="/image/algo_in_action/6_5.webp" alt="2_3_tree"></p>
<p>一个 3 节点有两个键、三条链，那我们完全可以把一个以红节点为左子节点的黑节点和子节点一起看做一个 3 节点</p>
<p><img src="/image/algo_in_action/6_6.webp" alt="2_3_tree"></p>
<p>因为红节点只是 3 节点的一部分，那么对应到红黑树上，显然不会出现两个连续的红色节点。</p>
<p>2-3 树上，每个节点到叶子节点的数量一定是一样的，且每个节点只包含一个黑色节点，那么
红黑树到叶子节点路径中的黑色节点数量也必然是一样的。</p>
<h3 id="旋转操作">旋转操作</h3>
<p>旋转的作用在于处理插入和删除时产生的右偏红节点或者两个连续的红节点。</p>
<p>以左旋为例，本质就是将某个 3 节点从较小的键为根转移为较大的键为根</p>
<p><img src="/image/algo_in_action/6_7.webp" alt="left_rotation"></p>
<h3 id="2-节点插入">2 节点插入</h3>
<p><img src="/image/algo_in_action/6_8.webp" alt="insert"></p>
<p>当插入左边时，直接将 2 节点升为 3 节点即可</p>
<p>当插入右边时，将 2 节点提升为不符合规则的 3 节点，然后进行一次左旋即可。</p>
<h3 id="3-节点插入">3 节点插入</h3>
<p>当插入右键的右侧时，将中间节点提升一层，并将左右节点变成黑色</p>
<p><img src="/image/algo_in_action/6_9.webp" alt="insert"></p>
<p>当插入中间或者左侧时，需要进行一到两次的旋转</p>
<p><img src="/image/algo_in_action/6_10.webp" alt="insert"></p>
<p>将三节点的左右节点变成黑色后，需要将中间键变成红色，这样当前子树到各个子节点路径的
黑色节点数量就不会变化了</p>
<p><img src="/image/algo_in_action/6_11.webp" alt="insert"></p>
<h1 id="第七讲-堆">第七讲 堆</h1>
<h2 id="优先队列">优先队列</h2>
<p>优先队列中的每一个元素，我们会赋予它一个优先级，优先级相同的元素遵循先进选出的原则
，另有优先级高可以优先出队。</p>
<p>优先队列可以有多种实现方式，如链表、红黑树，但对于出队时找到优先级最高的元素需求，
二叉堆是更好的选择。</p>
<h2 id="二叉堆">二叉堆</h2>
<p>二叉堆 binary heap 是建立在二叉树之上的，它有两个约束：</p>
<ul>
<li>二叉堆是一颗满二叉树</li>
<li>二叉堆的每个节点和其子节点有偏序关系，大顶堆要求所有节点的值一定大于其左右子树的任何一个节点的值，小顶堆同理。</li>
</ul>
<h2 id="priorityqueue-实现">PriorityQueue 实现</h2>
<p>以 JDK 14 的 PriorityQueue （简称 PQ）为例，分析基于堆的具体实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="n">AbstractQueue</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">implements</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">       * Priority queue represented as a balanced binary heap: the two
</span></span></span><span class="line"><span class="cl"><span class="cm">       * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The
</span></span></span><span class="line"><span class="cl"><span class="cm">       * priority queue is ordered by comparator, or by the elements&#39;
</span></span></span><span class="line"><span class="cl"><span class="cm">       * natural ordering, if comparator is null: For each node n in the
</span></span></span><span class="line"><span class="cl"><span class="cm">       * heap and each descendant d of n, n &lt;= d.  The element with the
</span></span></span><span class="line"><span class="cl"><span class="cm">       * lowest value is in queue[0], assuming the queue is nonempty.
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">      <span class="kd">transient</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">queue</span><span class="o">;</span> <span class="c1">// non-private to simplify nested class access
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      
</span></span><span class="line"><span class="cl">      <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">       * The number of elements in the priority queue.
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">       * Inserts the specified element into this priority queue.
</span></span></span><span class="line"><span class="cl"><span class="cm">       *
</span></span></span><span class="line"><span class="cl"><span class="cm">       * @return {@code true} (as specified by {@link Queue#offer})
</span></span></span><span class="line"><span class="cl"><span class="cm">       * @throws ClassCastException if the specified element cannot be
</span></span></span><span class="line"><span class="cl"><span class="cm">       *         compared with elements currently in this priority queue
</span></span></span><span class="line"><span class="cl"><span class="cm">       *         according to the priority queue&#39;s ordering
</span></span></span><span class="line"><span class="cl"><span class="cm">       * @throws NullPointerException if the specified element is null
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">      <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">       * Increases the capacity of the array.
</span></span></span><span class="line"><span class="cl"><span class="cm">       *
</span></span></span><span class="line"><span class="cl"><span class="cm">       * @param minCapacity the desired minimum capacity
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">      <span class="kd">private</span> <span class="kt">void</span> <span class="nf">grow</span><span class="o">(</span><span class="kt">int</span> <span class="n">minCapacity</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      <span class="kd">public</span> <span class="n">E</span> <span class="nf">peek</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="o">(</span><span class="n">E</span><span class="o">)</span> <span class="n">queue</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">       * Inserts item x at position k, maintaining heap invariant by
</span></span></span><span class="line"><span class="cl"><span class="cm">       * promoting x up the tree until it is greater than or equal to
</span></span></span><span class="line"><span class="cl"><span class="cm">       * its parent, or is the root.
</span></span></span><span class="line"><span class="cl"><span class="cm">       *
</span></span></span><span class="line"><span class="cl"><span class="cm">       * To simplify and speed up coercions and comparisons, the
</span></span></span><span class="line"><span class="cl"><span class="cm">       * Comparable and Comparator versions are separated into different
</span></span></span><span class="line"><span class="cl"><span class="cm">       * methods that are otherwise identical. (Similarly for siftDown.)
</span></span></span><span class="line"><span class="cl"><span class="cm">       *
</span></span></span><span class="line"><span class="cl"><span class="cm">       * @param k the position to fill
</span></span></span><span class="line"><span class="cl"><span class="cm">       * @param x the item to insert
</span></span></span><span class="line"><span class="cl"><span class="cm">       */</span>
</span></span><span class="line"><span class="cl">      <span class="kd">private</span> <span class="kt">void</span> <span class="nf">siftUp</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="n">E</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">      
</span></span><span class="line"><span class="cl">      <span class="kd">public</span> <span class="n">E</span> <span class="nf">poll</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到使用 queue 数组来存放元素，节点 queue[k] 对应的左右节点分别为
queue[2k+1]、queue[2k+2]。</p>
<p><img src="/image/algo_in_action/7_1.webp" alt="binary_heap"></p>
<h3 id="堆的操作">堆的操作</h3>
<h4 id="插入">插入</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Inserts the specified element into this priority queue.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return {@code true} (as specified by {@link Queue#offer})
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @throws ClassCastException if the specified element cannot be
</span></span></span><span class="line"><span class="cl"><span class="cm"> *         compared with elements currently in this priority queue
</span></span></span><span class="line"><span class="cl"><span class="cm"> *         according to the priority queue&#39;s ordering
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @throws NullPointerException if the specified element is null
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="n">NullPointerException</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">modCount</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">queue</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">grow</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">siftUp</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">size</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>真正的插入操作是在 siftUp 函数中实现的。
首先把元素放在数组尾部，然后依次向上与父节点比较，如果满足条件则位置互换。</p>
<p><img src="/image/algo_in_action/7_2.webp" alt="sift_up"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">siftUp</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="n">E</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="o">(</span><span class="n">comparator</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">siftUpUsingComparator</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">queue</span><span class="o">,</span> <span class="n">comparator</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">        <span class="n">siftUpComparable</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">queue</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">siftUpComparable</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="n">T</span> <span class="n">x</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">es</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="n">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;)</span> <span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 计算父节点的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">parent</span> <span class="o">=</span> <span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">Object</span> <span class="n">e</span> <span class="o">=</span> <span class="n">es</span><span class="o">[</span><span class="n">parent</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 比较当前节点和父节点的关系 如果当前节点优先级更高，我们可以直接结束比较
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">((</span><span class="n">T</span><span class="o">)</span> <span class="n">e</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 交换节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">es</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">k</span> <span class="o">=</span> <span class="n">parent</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">es</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="删除">删除</h4>
<p>删除操作是将返回并删除堆顶元素</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">E</span> <span class="nf">poll</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">es</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">final</span> <span class="n">E</span> <span class="n">result</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 取出堆顶元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="o">((</span><span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">E</span><span class="o">)</span> <span class="o">((</span><span class="n">es</span> <span class="o">=</span> <span class="n">queue</span><span class="o">)[</span><span class="mi">0</span><span class="o">]))</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">modCount</span><span class="o">++;</span>
</span></span><span class="line"><span class="cl">        <span class="kd">final</span> <span class="kt">int</span> <span class="n">n</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 其实就是要将最后一个元素放到顶部
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kd">final</span> <span class="n">E</span> <span class="n">x</span> <span class="o">=</span> <span class="o">(</span><span class="n">E</span><span class="o">)</span> <span class="n">es</span><span class="o">[(</span><span class="n">n</span> <span class="o">=</span> <span class="o">--</span><span class="n">size</span><span class="o">)];</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将最后一个元素置空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">es</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 进行siftdown操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="kd">final</span> <span class="n">Comparator</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">cmp</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="o">((</span><span class="n">cmp</span> <span class="o">=</span> <span class="n">comparator</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="n">siftDownComparable</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">es</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span>
</span></span><span class="line"><span class="cl">                <span class="n">siftDownUsingComparator</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">es</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">cmp</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/image/algo_in_action/7_3.webp" alt="sift_down"></p>
<p>将根节点删除后，我们将尾部的节点提到根节点，然后依次下沉比较交互</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">siftDownComparable</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="n">T</span> <span class="n">x</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">es</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// assert n &gt; 0;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">key</span> <span class="o">=</span> <span class="o">(</span><span class="n">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;)</span><span class="n">x</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">half</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>           <span class="c1">// loop while a non-leaf
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">half</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">child</span> <span class="o">=</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// assume left child is least
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Object</span> <span class="n">c</span> <span class="o">=</span> <span class="n">es</span><span class="o">[</span><span class="n">child</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">child</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="o">((</span><span class="n">Comparable</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">T</span><span class="o">&gt;)</span> <span class="n">c</span><span class="o">).</span><span class="na">compareTo</span><span class="o">((</span><span class="n">T</span><span class="o">)</span> <span class="n">es</span><span class="o">[</span><span class="n">right</span><span class="o">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">c</span> <span class="o">=</span> <span class="n">es</span><span class="o">[</span><span class="n">child</span> <span class="o">=</span> <span class="n">right</span><span class="o">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">((</span><span class="n">T</span><span class="o">)</span> <span class="n">c</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">es</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">k</span> <span class="o">=</span> <span class="n">child</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">es</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="扩容">扩容</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * Increases the capacity of the array.
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param minCapacity the desired minimum capacity
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">grow</span><span class="o">(</span><span class="kt">int</span> <span class="n">minCapacity</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">oldCapacity</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Double size if small; else grow by 50%
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">newCapacity</span> <span class="o">=</span> <span class="n">ArraysSupport</span><span class="o">.</span><span class="na">newLength</span><span class="o">(</span><span class="n">oldCapacity</span><span class="o">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">minCapacity</span> <span class="o">-</span> <span class="n">oldCapacity</span><span class="o">,</span> <span class="cm">/* minimum growth */</span>
</span></span><span class="line"><span class="cl">            <span class="n">oldCapacity</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="o">?</span> <span class="n">oldCapacity</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">oldCapacity</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                                       <span class="cm">/* preferred growth */</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">queue</span> <span class="o">=</span> <span class="n">Arrays</span><span class="o">.</span><span class="na">copyOf</span><span class="o">(</span><span class="n">queue</span><span class="o">,</span> <span class="n">newCapacity</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>和 vector 扩容思想类似，当原容量小于 64 时，扩容到 2 倍 +2 ，否则 1.5 倍。</p>
<h1 id="第八讲-外部排序">第八讲 外部排序</h1>
<h2 id="常见排序算法">常见排序算法</h2>
<p><img src="/image/algo_in_action/8_1.webp" alt="sort_algo"></p>
<h2 id="外部排序">外部排序</h2>
<p>外部排序是指借助外部存储来排序，相比内存，外部排序有更大的IO消耗。
常用的外部排序为归并排序。</p>
<p><img src="/image/algo_in_action/8_2.webp" alt="merge_sort"></p>
<h2 id="运行时间">运行时间</h2>
<p>每一层我们读取外层的数据总量是一样的，我们要做的是让归并的层次越低越好</p>
<p>假设数据段为 n, 归并路数为 k，那么层数为 logk(n)。
但增加 k 的大小也会导致 从 k 个元素中选择 最小 的元素的代价变高。</p>
<h2 id="败者树">败者树</h2>
<p><img src="/image/algo_in_action/8_3.webp" alt="tournament_tree">
<img src="/image/algo_in_action/8_4.webp" alt="tournament_tree"></p>
<p>败者树的思想是使用叶子节点存储待比较的元素，两两比较，在父节点存储失败者，然后
对获胜的元素两两比较，得到更上层的失败者。</p>
<p>根节点之上有一个最终获胜者</p>
<p>对于取出胜者并添加新元素的操作，只需要将新元素置于胜者的位置 ，再依次向上比较即可。</p>
<p>败者树相比堆，Pop时只需要和上层的败者比较即可，不像堆一定要和左右子树比较两次。</p>
<p><img src="/image/algo_in_action/8_5.webp" alt="tournament_tree"></p>
<p>相关算法题 - <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/solution/xcdytv-by-ppd-2-sspr/">合并K个有序链表</a></p>
<h1 id="第九讲-二分法">第九讲 二分法</h1>
<h2 id="二分查找">二分查找</h2>
<p>二分查找的核心是查找元素和比较有序排列</p>
<h2 id="kafka">Kafka</h2>
<p>Kafka 中所有的消息都是以&quot;日志&quot;的形式存储，消息按写入时间顺序，依次追加在许多日志文件中。
文件中每条消息会相对第一条消息有一个偏移量(类似自增ID)。</p>
<p>Kafka 每个 topic 会有多个 partition，每个 partition下 的日志按照顺序分成一个个有序日志段。</p>
<p><img src="/image/algo_in_action/9_1.webp" alt="kafka_log"></p>
<h3 id="消息查找">消息查找</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">00000000000000000000.log
</span></span><span class="line"><span class="cl">00000000000000000000.index
</span></span><span class="line"><span class="cl">00000000000000000000.timeindex
</span></span><span class="line"><span class="cl">00000000000000000035.log
</span></span><span class="line"><span class="cl">00000000000000000035.index
</span></span><span class="line"><span class="cl">00000000000000000035.timeindex
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面为一个典型的日志文件存储情况：</p>
<ul>
<li>.log 文件存储的就是消息本身的日志文件</li>
<li>.index 文件是索引文件</li>
<li>.timeindex 文件是基于时间戳的索引文件</li>
</ul>
<p>.index 文件内容示例如下图</p>
<p><img src="/image/algo_in_action/9_2.webp" alt="kafka_log2"></p>
<p>kafka为了使用更小的内存空间，采用了稀疏索引。</p>
<h3 id="源码实现">源码实现</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-scala" data-lang="scala"><span class="line"><span class="cl">      <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Lookup lower and upper bounds for the given target.
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span> <span class="k">def</span> <span class="n">indexSlotRangeFor</span><span class="o">(</span><span class="n">idx</span><span class="k">:</span> <span class="kt">ByteBuffer</span><span class="o">,</span> <span class="n">target</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">searchEntity</span><span class="k">:</span> <span class="kt">IndexSearchEntity</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 检查index是否为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span><span class="o">(</span><span class="nc">_entries</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">(-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">        <span class="c1">// 二分搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">def</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">begin</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">end</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">var</span> <span class="n">lo</span> <span class="k">=</span> <span class="n">begin</span>
</span></span><span class="line"><span class="cl">        <span class="k">var</span> <span class="n">hi</span> <span class="k">=</span> <span class="n">end</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="o">(</span><span class="n">lo</span> <span class="o">&lt;</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">val</span> <span class="n">mid</span> <span class="k">=</span> <span class="n">ceil</span><span class="o">(</span><span class="n">hi</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">lo</span><span class="o">/</span><span class="mf">2.0</span><span class="o">).</span><span class="n">toInt</span>
</span></span><span class="line"><span class="cl">          <span class="k">val</span> <span class="n">found</span> <span class="k">=</span> <span class="n">parseEntry</span><span class="o">(</span><span class="n">idx</span><span class="o">,</span> <span class="n">mid</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">          <span class="k">val</span> <span class="n">compareResult</span> <span class="k">=</span> <span class="n">compareIndexEntry</span><span class="o">(</span><span class="n">found</span><span class="o">,</span> <span class="n">target</span><span class="o">,</span> <span class="n">searchEntity</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">          <span class="k">if</span><span class="o">(</span><span class="n">compareResult</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">hi</span> <span class="k">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">          <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">compareResult</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">lo</span> <span class="k">=</span> <span class="n">mid</span>
</span></span><span class="line"><span class="cl">          <span class="k">else</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="o">(</span><span class="n">mid</span><span class="o">,</span> <span class="n">mid</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">(</span><span class="n">lo</span><span class="o">,</span> <span class="k">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">==</span> <span class="nc">_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">lo</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">      <span class="k">val</span> <span class="n">firstHotEntry</span> <span class="k">=</span> <span class="nc">Math</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nc">_entries</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nc">_warmEntries</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 查询的目标offset是否在热区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span><span class="o">(</span><span class="n">compareIndexEntry</span><span class="o">(</span><span class="n">parseEntry</span><span class="o">(</span><span class="n">idx</span><span class="o">,</span> <span class="n">firstHotEntry</span><span class="o">),</span> <span class="n">target</span><span class="o">,</span> <span class="n">searchEntity</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">firstHotEntry</span><span class="o">,</span> <span class="nc">_entries</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">      <span class="o">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">      <span class="c1">// 查询的目标offset是否小于最小的offset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span><span class="o">(</span><span class="n">compareIndexEntry</span><span class="o">(</span><span class="n">parseEntry</span><span class="o">(</span><span class="n">idx</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="n">target</span><span class="o">,</span> <span class="n">searchEntity</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">(-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="n">binarySearch</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">firstHotEntry</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Kafka 使用了 mmap 将磁盘文件和内存进行映射， 消息队列的特性决定了
大部分索引查询其实都是在日志比较靠近尾部的区域，将索引中最后 8KB
认为热区，查询是优先查热区，没有命中再查冷区，这样就可以减少缺页中断的次数。</p>
<p>kafka 采用冷热二分查询的改进见这个<a href="https://issues.apache.org/jira/browse/KAFKA-6432">issue</a></p>
<h1 id="第十讲-暴力搜索算法">第十讲 暴力搜索算法</h1>
<p>BFS 和 DFS 是两种常见的搜索算法</p>
<h1 id="第十一讲-字符串匹配">第十一讲 字符串匹配</h1>
<h2 id="brute-force-算法">Brute-Force 算法</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * s: 主串
</span></span></span><span class="line"><span class="cl"><span class="cm"> * p：模式串
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">match</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span> <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="boyer-moore-算法">Boyer-Moore 算法</h2>
<h3 id="坏字符规则">坏字符规则</h3>
<p>BM 算法采用从后向前匹配的方式</p>
<p><img src="/image/algo_in_action/11_1.webp" alt="1"></p>
<p>如上图， 位置 6 匹配，那这里的 &ldquo;S&rdquo; 就是是个坏字符，遇到坏字符时，
如果在模式串中没有出现，则说明没有重叠，可以直接跳过这段。</p>
<p><img src="/image/algo_in_action/11_2.webp" alt="2"></p>
<p>下一步匹配时，发现坏字符&quot;P&quot;，但 &ldquo;P&rdquo; 在模式串有出现，可以将模式串最后一次出现 &ldquo;P&quot;的位置对齐</p>
<p><img src="/image/algo_in_action/11_3.webp" alt="3"></p>
<p>每次发现坏字符时，我们需要向右移动移动 （失配位置 - 失配字符最右出现的下标）位，其中如果失配字符没有在模式串出现，则下标为 -1，</p>
<h3 id="好后缀规则">好后缀规则</h3>
<p><img src="/image/algo_in_action/11_4.webp" alt="4"></p>
<p>在 SIMPLE 和 EXAMPLE 的匹配中，我们发&quot;MPLE&quot;都匹配得上，那&quot;MPLE&quot;就称之为好后缀，
同样&quot;PLE&rdquo;、&ldquo;LE&rdquo;、&ldquo;E&rdquo; 都是好后缀。</p>
<p>如果用坏字符规则，则应该将模式串移动(2 - (-1)) = 3 位，因为&quot;I&quot; 在模式串不存在。</p>
<p>我们使用好后缀的规则： 找到好后缀在模式串中最右的匹配位置，总计向后移动（模式串字符串长度 - 1 - 好后缀在模式串上次出现的位置）位。
上图好后缀&quot;E&quot; 的计算值为 6 （7-1-0）位</p>
<h2 id="bm-算法具体实现">BM 算法具体实现</h2>
<h3 id="坏字符最右位置计算">坏字符最右位置计算</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_bc</span><span class="p">(</span><span class="n">pattern</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">bc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span> <span class="c1"># 记录每个badchar最右出现的位置</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="n">char</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">bc</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">bc</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们用 dict 来记录每个字符最右侧位置。工业级的实现会用 [0, 256] 的数组替代来提高性能。</p>
<h3 id="好后缀计算">好后缀计算</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">get_gs</span><span class="p">(</span><span class="n">pattern</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="n">gs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="n">gs</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1"># suf_len 用于标记后缀长度</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">suf_len</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">        <span class="n">suffix</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">-</span> <span class="n">suf_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># j 用于标记可用于匹配的位置</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">-</span> <span class="n">suf_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">substr</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span> <span class="o">+</span> <span class="n">suf_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">suffix</span> <span class="o">==</span> <span class="n">substr</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">gs</span><span class="p">[</span><span class="n">suffix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="n">suf_len</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">suf_len</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">        <span class="n">suffix</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">-</span> <span class="n">suf_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="n">gs</span><span class="p">:</span> <span class="k">continue</span>
</span></span><span class="line"><span class="cl">        <span class="n">gs</span><span class="p">[</span><span class="n">suffix</span><span class="p">]</span> <span class="o">=</span> <span class="n">gs</span><span class="p">[</span><span class="n">suffix</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">gs</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">gs</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="匹配">匹配</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">bm</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">gs</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># i 用于标记当前模式串和主串哪个位置左对齐。</span>
</span></span><span class="line"><span class="cl">    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> 
</span></span><span class="line"><span class="cl">    <span class="c1"># j 用于标记当前模式串匹配到哪个位置；从右往左遍历匹配。</span>
</span></span><span class="line"><span class="cl">    <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 从右往左匹配每个位置</span>
</span></span><span class="line"><span class="cl">            <span class="n">a</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">b</span> <span class="o">=</span> <span class="n">pattern</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span> <span class="c1"># 匹配的上，继续匹配前一位</span>
</span></span><span class="line"><span class="cl">                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span> <span class="c1"># 匹配不上，根据两个规则的预处理结果进行快速移动</span>
</span></span><span class="line"><span class="cl">                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">gs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">pattern</span><span class="p">[</span><span class="n">j</span><span class="p">:],</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)),</span> <span class="n">j</span> <span class="o">-</span> <span class="n">bc</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">                <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># 匹配成功返回匹配位置</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">i</span>
</span></span><span class="line"><span class="cl">    <span class="c1"># 匹配失败返回 None</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="o">=</span> <span class="s1">&#39;here is a simple example &#39;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;example&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">bc</span> <span class="o">=</span> <span class="n">get_bc</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>  <span class="c1"># 坏字符表</span>
</span></span><span class="line"><span class="cl">    <span class="n">gs</span> <span class="o">=</span> <span class="n">get_gs</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>  <span class="c1"># 好后缀表</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="n">bm</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">gs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="第十二讲-拓扑排序">第十二讲 拓扑排序</h1>
<p><img src="/image/algo_in_action/12_1.webp" alt="1"></p>
<p>如上图的课表，部分课程学习有一些前置课程，用图的方式表示如下：</p>
<p><img src="/image/algo_in_action/12_2.webp" alt="2"></p>
<p>如果我们给出一个序列使得每个节点只出现一次，且保证如果存在路径 P 从 A 到 B，
那么 A 在序列中一定出现在 B 之前，满足这个条件的序列就被可认为满拓扑排序。</p>
<p>拓扑排序是建立在有向无环图（DAG）的基础之上的.</p>
<h2 id="khan-算法">khan 算法</h2>
<p>khan 算法是一种基于贪心和广度优先思想的拓扑排序实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findOrder</span><span class="p">(</span><span class="kt">int</span> <span class="n">numCourses</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">prerequisites</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 邻接表数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">next</span><span class="p">(</span><span class="n">numCourses</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 入度表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pre</span><span class="p">(</span><span class="n">numCourses</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 标记是否遍历过
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">numCourses</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 记录最终修读顺序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 构图
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">edge</span><span class="p">:</span> <span class="n">prerequisites</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">next</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">pre</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 所有没有先修课程的课程入队
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// BFS搜索
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="n">visited</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 遍历所有以队首课程为先修课程的课程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">n</span><span class="p">:</span> <span class="n">next</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 由于队首课程已经被修读，所以当前课程入度-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">pre</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// 如果该课程所有先修课程已经修完；将该课程入队
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">pre</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">n</span><span class="p">);}</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// 环路检测： 如果仍有课程没有修读；说明环路存在
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numCourses</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">return</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="dfs">DFS</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-javascript" data-lang="javascript"><span class="line"><span class="cl"><span class="c1">// https://github.com/marcelklehr/toposort
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">   * Topological sorting function
</span></span></span><span class="line"><span class="cl"><span class="cm">   *
</span></span></span><span class="line"><span class="cl"><span class="cm">   * @param {Array} edges
</span></span></span><span class="line"><span class="cl"><span class="cm">   * @returns {Array}
</span></span></span><span class="line"><span class="cl"><span class="cm">   */</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">edges</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">toposort</span><span class="p">(</span><span class="nx">uniqueNodes</span><span class="p">(</span><span class="nx">edges</span><span class="p">),</span> <span class="nx">edges</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span><span class="p">.</span><span class="nx">array</span> <span class="o">=</span> <span class="nx">toposort</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="kd">function</span> <span class="nx">toposort</span><span class="p">(</span><span class="nx">nodes</span><span class="p">,</span> <span class="nx">edges</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">cursor</span> <span class="o">=</span> <span class="nx">nodes</span><span class="p">.</span><span class="nx">length</span>
</span></span><span class="line"><span class="cl">      <span class="p">,</span> <span class="nx">sorted</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">cursor</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">,</span> <span class="nx">visited</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">      <span class="p">,</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">cursor</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// Better data structures make algorithm much faster.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="p">,</span> <span class="nx">outgoingEdges</span> <span class="o">=</span> <span class="nx">makeOutgoingEdges</span><span class="p">(</span><span class="nx">edges</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">,</span> <span class="nx">nodesHash</span> <span class="o">=</span> <span class="nx">makeNodesHash</span><span class="p">(</span><span class="nx">nodes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="c1">// check for unknown nodes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">edges</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">edge</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">nodesHash</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">||</span> <span class="o">!</span><span class="nx">nodesHash</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Unknown node. There is an unknown node in the supplied edges.&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="nx">visit</span><span class="p">(</span><span class="nx">nodes</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">i</span><span class="p">,</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">sorted</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="kd">function</span> <span class="nx">visit</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">predecessors</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span><span class="p">(</span><span class="nx">predecessors</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nx">nodeRep</span>
</span></span><span class="line"><span class="cl">        <span class="k">try</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">nodeRep</span> <span class="o">=</span> <span class="s2">&#34;, node was:&#34;</span> <span class="o">+</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nx">nodeRep</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Cyclic dependency&#39;</span> <span class="o">+</span> <span class="nx">nodeRep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">nodesHash</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Found unknown node. Make sure to provided all involved nodes. Unknown node: &#39;</span><span class="o">+</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="nx">visited</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">      <span class="kd">var</span> <span class="nx">outgoing</span> <span class="o">=</span> <span class="nx">outgoingEdges</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="o">||</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="nx">outgoing</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">outgoing</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="nx">outgoing</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">predecessors</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="kd">var</span> <span class="nx">child</span> <span class="o">=</span> <span class="nx">outgoing</span><span class="p">[</span><span class="o">--</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">          <span class="nx">visit</span><span class="p">(</span><span class="nx">child</span><span class="p">,</span> <span class="nx">nodesHash</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">child</span><span class="p">),</span> <span class="nx">predecessors</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">predecessors</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">      <span class="nx">sorted</span><span class="p">[</span><span class="o">--</span><span class="nx">cursor</span><span class="p">]</span> <span class="o">=</span> <span class="nx">node</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="kd">function</span> <span class="nx">uniqueNodes</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kd">var</span> <span class="nx">edge</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="nx">res</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">      <span class="nx">res</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="kd">function</span> <span class="nx">makeOutgoingEdges</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">edges</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kd">var</span> <span class="nx">edge</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">edges</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="nx">edges</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">edges</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="nx">edges</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">      <span class="nx">edges</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]).</span><span class="nx">add</span><span class="p">(</span><span class="nx">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">edges</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="kd">function</span> <span class="nx">makeNodesHash</span><span class="p">(</span><span class="nx">arr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">res</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">res</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">res</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="第十三讲-哈夫曼树">第十三讲 哈夫曼树</h1>
<p>HTTP2 使用 HPACK 压缩协议来了压缩 Header， 其主要包括三个部分</p>
<ul>
<li>静态表</li>
<li>动态表</li>
<li>哈夫曼编码</li>
</ul>
<p><img src="/image/algo_in_action/13_1.webp" alt="1"></p>
<h2 id="静态表">静态表</h2>
<p>有 61 个 常用 字段（部分包含值）编码到了 1~61 的<a href="https://www.rfc-editor.org/rfc/rfc7541#appendix-A">索引表</a>里</p>
<h2 id="动态表">动态表</h2>
<p>静态表字段有限，允许通过通信的方式，在客户端和服务端之间维护一张动态的字典，用索引来代表值</p>
<h2 id="哈夫曼编码">哈夫曼编码</h2>
<p>限于静态表和动态表的大小，我们并不能压缩任意数据，于是引入哈夫曼编码来进一步提高压缩能力 。</p>
<p>哈夫曼编码的主要思想就是让出现概率高的字符用短编码，概率低的用长编码；
同时为了避免变长编码产生歧义，所以不同的字符键不能成为对方的前缀。</p>
<p>算法实现采用了贪心思想，用一颗二叉树来标记每个字符的编码方式，左分支代表 0， 右分支代表 1；
所有需要编码的字符对应一个叶子节点，根节点到该叶子节点的路径代表该字符的编码方式。</p>
<p>编码示例，假设有 a、b、c、d、e、f 六个字符，分别出现的频率是 5、9、12、13、16、45。依次选取两个频率最小的节点合成一颗子树，用两个频率只和代表父节点的频率。</p>
<p><img src="/image/algo_in_action/13_2.webp" alt="2"></p>
<p><img src="/image/algo_in_action/13_3.webp" alt="3"></p>
<p>最终对应编码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">f          0
</span></span><span class="line"><span class="cl">c          100
</span></span><span class="line"><span class="cl">d          101
</span></span><span class="line"><span class="cl">a          1100
</span></span><span class="line"><span class="cl">b          1101
</span></span><span class="line"><span class="cl">e          111
</span></span></code></pre></td></tr></table>
</div>
</div><p>代码实现可借助小顶堆</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">buildHuffmanTree</span><span class="p">(</span><span class="n">string</span> <span class="n">text</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 利用hashmap对字符串进行频率计数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">freq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">ch</span><span class="p">:</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">freq</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="c1">// 用堆去动态维护所有树中最小的两颗
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span><span class="p">,</span> <span class="n">comp</span><span class="o">&gt;</span> <span class="n">pq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="c1">// 将所有的字符都初始化成为哈夫曼树的一个叶子节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// 并推入优先队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">pair</span><span class="p">:</span> <span class="n">freq</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">getNode</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="c1">// 每次取出最小的两个合并 直至优先队列只剩一个节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">pq</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 最小的两个节点出队
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">Node</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="n">Node</span> <span class="o">*</span><span class="n">right</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>  <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">      <span class="c1">// 建立一个内部节点，以这两个最小的树为左右节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">freq</span> <span class="o">+</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">freq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">getNode</span><span class="p">(</span><span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="c1">// 优先队列中最后一个元素为整棵树的根节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">Node</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div>
    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">PPD</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2022-08-20
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://ppd0705.github.io/tags/%E7%AE%97%E6%B3%95/">算法</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/learn_supervisor/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">supervisor 源码解读</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/2021_summary/">
            <span class="next-text nav-default">2021年终总结</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "ppd0705/ppd0705.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:ppd0705@icloud.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://twitter.com/ppd0705" rel="me noopener" class="iconfont"
      title="twitter"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1264 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M1229.8616 18.043658c0 0-117.852626 63.135335-164.151872 67.344358-105.225559-164.151872-505.082682-92.598492-437.738325 223.078185C278.622548 312.675223 89.216542 47.506814 89.216542 47.506814s-117.852626 189.406006 75.762402 345.139833C127.097743 396.85567 55.544363 371.601535 55.544363 371.601535S26.081207 535.753407 253.368414 615.724832c-21.045112 29.463156-113.643603 8.418045-113.643603 8.418045s25.254134 143.10676 231.496229 180.987961c-143.10676 130.479693-387.230056 92.598492-370.393967 105.225559 206.242095 189.406006 1119.599946 231.496229 1128.01799-643.98042C1179.353331 249.539887 1263.533778 123.269217 1263.533778 123.269217s-130.479693 37.881201-138.897738 33.672179C1225.652577 98.015083 1229.8616 18.043658 1229.8616 18.043658"></path>
</svg>

    </a>
  
    <a href="https://www.linkedin.com/in/ppd0705" rel="me noopener" class="iconfont"
      title="linkedin"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="33" height="33">
  <path d="M872.405333 872.618667h-151.637333v-237.610667c0-56.661333-1.152-129.578667-79.018667-129.578667-79.061333 0-91.136 61.653333-91.136 125.397334v241.792H398.976V384h145.664v66.602667h1.962667c20.352-38.4 69.845333-78.933333 143.786666-78.933334 153.642667 0 182.058667 101.12 182.058667 232.746667v268.202667zM227.712 317.141333a87.978667 87.978667 0 0 1-88.021333-88.106666 88.064 88.064 0 1 1 88.021333 88.106666z m76.032 555.477334H151.68V384h152.064v488.618667zM948.266667 0H75.562667C33.792 0 0 33.024 0 73.770667v876.458666C0 991.018667 33.792 1024 75.562667 1024h872.576C989.866667 1024 1024 991.018667 1024 950.229333V73.770667C1024 33.024 989.866667 0 948.138667 0h0.128z"></path>
</svg>

    </a>
  
    <a href="https://github.com/ppd0705" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>
  
    <a href="https://www.douban.com/people/ppd0705/" rel="me noopener" class="iconfont"
      title="douban"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M926.917973 37.80608C959.65184 37.80608 986.19392 64.34816 986.19392 97.082027L986.19392 926.917973C986.19392 959.65184 959.65184 986.19392 926.917973 986.19392L97.082027 986.19392C64.34816 986.19392 37.80608 959.65184 37.80608 926.917973L37.80608 97.082027C37.80608 64.34816 64.34816 37.80608 97.082027 37.80608zM176.653653 176.19968 176.653653 252.678827 825.658027 252.678827 825.658027 176.19968zM217.719467 316.146347 217.719467 628.08064 273.524053 628.08064 341.292373 770.39616 157.259093 770.39616 157.259093 845.417813 842.949973 845.417813 842.949973 770.39616 654.226773 770.39616 722.899627 628.08064 783.67744 628.08064 783.67744 316.146347zM684.885333 392.891733 684.885333 553.987413 312.576 553.987413 312.576 392.891733zM570.770773 770.39616 426.653013 770.39616 359.621973 628.08064 639.443627 628.08064z"></path>
</svg>

    </a>


<a href="https://ppd0705.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2019 -
    2024
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        PPD
        
      </span></span>

  
  
    <span id="busuanzi_container">
      访客数/访问量：<span id="busuanzi_value_site_uv"></span>/<span id="busuanzi_value_site_pv"></span>
    </span>
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>












</body>
</html>
