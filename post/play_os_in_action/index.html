<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>[笔记]操作系统实战（更新中） - PPD&#39;s blog</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="PPD" />
  <meta name="description" content="第一讲: 程序的运行过程 程序的编译过程 预处理：加入头文件，替换宏 gcc HelloWorld.c -o HelloWorld.i 编译：包含预处理，将C程序转成成汇编程序 gcc HelloWorld.c -S -c Helloworld.s 汇编：包含预处理和汇" />

  <meta name="keywords" content="PPD, blog" />






<meta name="generator" content="Hugo 0.86.0-DEV" />


<link rel="canonical" href="https://ppd0705.github.io/post/play_os_in_action/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.b3a8813c06e6d785beba22bf8264e174fa2cb3a396b22f9ba24e2c00c18aaf7f.css" integrity="sha256-s6iBPAbm14W&#43;uiK/gmThdPoss6OWsi&#43;bok4sAMGKr38=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="[笔记]操作系统实战（更新中）" />
<meta property="og:description" content="第一讲: 程序的运行过程 程序的编译过程 预处理：加入头文件，替换宏 gcc HelloWorld.c -o HelloWorld.i 编译：包含预处理，将C程序转成成汇编程序 gcc HelloWorld.c -S -c Helloworld.s 汇编：包含预处理和汇" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ppd0705.github.io/post/play_os_in_action/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-07-30T08:06:33+08:00" />
<meta property="article:modified_time" content="2021-07-30T08:06:33+08:00" />

<meta itemprop="name" content="[笔记]操作系统实战（更新中）">
<meta itemprop="description" content="第一讲: 程序的运行过程 程序的编译过程 预处理：加入头文件，替换宏 gcc HelloWorld.c -o HelloWorld.i 编译：包含预处理，将C程序转成成汇编程序 gcc HelloWorld.c -S -c Helloworld.s 汇编：包含预处理和汇"><meta itemprop="datePublished" content="2021-07-30T08:06:33+08:00" />
<meta itemprop="dateModified" content="2021-07-30T08:06:33+08:00" />
<meta itemprop="wordCount" content="18172">
<meta itemprop="keywords" content="C,操作系统," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[笔记]操作系统实战（更新中）"/>
<meta name="twitter:description" content="第一讲: 程序的运行过程 程序的编译过程 预处理：加入头文件，替换宏 gcc HelloWorld.c -o HelloWorld.i 编译：包含预处理，将C程序转成成汇编程序 gcc HelloWorld.c -S -c Helloworld.s 汇编：包含预处理和汇"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">PPD's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/about">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      PPD's blog
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/about">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">[笔记]操作系统实战（更新中）</h1>
      
      <div class="post-meta">
        <time datetime="2021-07-30" class="post-time">
          2021-07-30
        </time>
        <div class="post-category">
            <a href="https://ppd0705.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"> 计算机 </a>
            
          </div>
        <span class="more-meta"> 18172 words </span>
          <span class="more-meta"> 37 min read </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#第一讲-程序的运行过程">第一讲: 程序的运行过程</a>
      <ul>
        <li><a href="#程序的编译过程">程序的编译过程</a></li>
        <li><a href="#程序装载执行">程序装载执行</a>
          <ul>
            <li><a href="#冯诺依曼体系结构五大组件">冯诺依曼体系结构五大组件</a></li>
            <li><a href="#helloworld汇编代码解释">HelloWorld汇编代码解释</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第二讲实现一个最小内核">第二讲：实现一个最小内核</a>
      <ul>
        <li><a href="#os引导流程">OS引导流程</a></li>
        <li><a href="#引导汇编代码">引导汇编代码</a></li>
        <li><a href="#主函数">主函数</a></li>
        <li><a href="#控制计算机屏幕">控制计算机屏幕</a></li>
        <li><a href="#编译和安装">编译和安装</a>
          <ul>
            <li><a href="#编译">编译</a></li>
            <li><a href="#安装">安装</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第三讲内核结构设计">第三讲：内核结构设计</a>
      <ul>
        <li><a href="#内核功能">内核功能</a></li>
        <li><a href="#宏内核结构">宏内核结构</a></li>
        <li><a href="#微内核结构">微内核结构</a></li>
        <li><a href="#我们的选择">我们的选择</a>
          <ul>
            <li><a href="#内核接口层">内核接口层</a></li>
            <li><a href="#内核功能层">内核功能层</a></li>
            <li><a href="#内核硬件层">内核硬件层</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第四讲业界成熟内核架构">第四讲：业界成熟内核架构</a>
      <ul>
        <li><a href="#linux">Linux</a></li>
        <li><a href="#darwin">Darwin</a></li>
        <li><a href="#windows-nt">Windows NT</a></li>
        <li><a href="#评论区拾遗">评论区拾遗</a></li>
      </ul>
    </li>
    <li><a href="#第五讲执行程序的三种模式">第五讲：执行程序的三种模式</a>
      <ul>
        <li><a href="#实模式">实模式</a>
          <ul>
            <li><a href="#寄存器">寄存器</a></li>
            <li><a href="#内存">内存</a></li>
            <li><a href="#中断">中断</a></li>
          </ul>
        </li>
        <li><a href="#保护模式">保护模式</a>
          <ul>
            <li><a href="#特权级">特权级</a></li>
            <li><a href="#段描述符">段描述符</a></li>
            <li><a href="#平坦模型">平坦模型</a></li>
            <li><a href="#中断-1">中断</a></li>
            <li><a href="#切换">切换</a></li>
          </ul>
        </li>
        <li><a href="#长模式">长模式</a>
          <ul>
            <li><a href="#寄存器-1">寄存器</a></li>
            <li><a href="#段描述符-1">段描述符</a></li>
            <li><a href="#中断-2">中断</a></li>
            <li><a href="#切换-1">切换</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第六讲地址转换">第六讲：地址转换</a>
      <ul>
        <li><a href="#虚拟地址">虚拟地址</a></li>
        <li><a href="#物理地址">物理地址</a></li>
        <li><a href="#虚实转换">虚实转换</a></li>
        <li><a href="#mmu">MMU</a>
          <ul>
            <li><a href="#页表">页表</a></li>
            <li><a href="#保护模式下的分页">保护模式下的分页</a>
              <ul>
                <li><a href="#4kb页">4KB页</a></li>
                <li><a href="#4mb页">4MB页</a></li>
              </ul>
            </li>
            <li><a href="#长模式下的分页">长模式下的分页</a>
              <ul>
                <li><a href="#4kb页-1">4KB页</a></li>
                <li><a href="#2mb页">2MB页</a></li>
              </ul>
            </li>
            <li><a href="#开启mmu">开启MMU</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第七讲cache与内存">第七讲：Cache与内存</a>
      <ul>
        <li><a href="#内存-1">内存</a></li>
        <li><a href="#cache">Cache</a></li>
        <li><a href="#cache引入的问题">Cache引入的问题</a></li>
        <li><a href="#cache的mesi协议">Cache的MESI协议</a></li>
      </ul>
    </li>
    <li><a href="#第八讲锁-并发操作中如何让数据同步">第八讲：锁-并发操作中如何让数据同步</a>
      <ul>
        <li><a href="#方法一-原子操作-拿下单体变量">方法一： 原子操作， 拿下单体变量</a></li>
        <li><a href="#方法二-中断控制搞定复杂变量">方法二： 中断控制，搞定复杂变量</a></li>
        <li><a href="#方法三-自旋锁协调多核心cpu">方法三： 自旋锁，协调多核心CPU</a></li>
        <li><a href="#方法四-信号量时间管理大师">方法四： 信号量，时间管理大师</a>
          <ul>
            <li><a href="#获取信号量">获取信号量</a></li>
            <li><a href="#释放信号量">释放信号量</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第九讲-linux的并发实现">第九讲 Linux的并发实现</a>
      <ul>
        <li><a href="#原子变量">原子变量</a></li>
        <li><a href="#中断控制">中断控制</a></li>
        <li><a href="#自旋锁">自旋锁</a>
          <ul>
            <li><a href="#原始自旋锁">原始自旋锁</a></li>
            <li><a href="#排队自旋锁">排队自旋锁</a></li>
          </ul>
        </li>
        <li><a href="#信号量">信号量</a></li>
        <li><a href="#读写锁">读写锁</a></li>
      </ul>
    </li>
    <li><a href="#第十讲设置工作模式和环境">第十讲：设置工作模式和环境</a>
      <ul>
        <li><a href="#内核映像文件">内核映像文件</a></li>
        <li><a href="#准备环境">准备环境</a>
          <ul>
            <li><a href="#安装虚拟机">安装虚拟机</a></li>
            <li><a href="#准备硬盘">准备硬盘</a>
              <ul>
                <li><a href="#生成纯二进制文件">生成纯二进制文件</a></li>
                <li><a href="#格式化建立文件系统">格式化（建立文件系统）</a></li>
              </ul>
            </li>
            <li><a href="#安装grub">安装GRUB</a>
              <ul>
                <li><a href="#转成硬盘格式">转成硬盘格式</a></li>
              </ul>
            </li>
            <li><a href="#安装虚拟硬盘">安装虚拟硬盘</a></li>
            <li><a href="#启动">启动</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第十一讲建造二级引导器">第十一讲：建造二级引导器</a>
      <ul>
        <li><a href="#二级引导器作用">二级引导器作用</a></li>
        <li><a href="#存储结构">存储结构</a></li>
        <li><a href="#模块规划">模块规划</a></li>
        <li><a href="#实现grub头">实现GRUB头</a>
          <ul>
            <li><a href="#imginitheadasm">imginithead.asm</a></li>
          </ul>
        </li>
        <li><a href="#进入二级引导器">进入二级引导器</a></li>
        <li><a href="#调用bios中断">调用BIOS中断</a></li>
        <li><a href="#引导器主函数">引导器主函数</a></li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h1 id="第一讲-程序的运行过程">第一讲: 程序的运行过程</h1>
<h2 id="程序的编译过程">程序的编译过程</h2>
<p><img src="/image/play_os_in_action/1_1.webp" alt="compile_process"></p>
<ol>
<li>预处理：加入头文件，替换宏
<code>gcc HelloWorld.c -o HelloWorld.i</code></li>
<li>编译：包含预处理，将C程序转成成汇编程序
<code>gcc HelloWorld.c -S -c Helloworld.s</code></li>
<li>汇编：包含预处理和汇编，将汇编程序转换成可链接的二进制程序
<code>gcc HelloWorld.c -c HelloWorld.o</code></li>
<li>链接：将可链接的二进制程序和其他的库链接在一起，形成可执行的程序文件
<code>gcc HelloWorld.c -o HelloWorld</code></li>
</ol>
<h2 id="程序装载执行">程序装载执行</h2>
<h3 id="冯诺依曼体系结构五大组件">冯诺依曼体系结构五大组件</h3>
<ul>
<li>装载数据和程序的输入设备</li>
<li>记住程序和数据的存储器</li>
<li>完成数据加工的运算器</li>
<li>控制程序执行的控制器</li>
<li>显示处理结果的输出设备</li>
</ul>
<h3 id="helloworld汇编代码解释">HelloWorld汇编代码解释</h3>
<p><code> objdump -d hello_world.o</code>
<img src="/image/play_os_in_action/1_2.webp" alt="compile_code"></p>
<p>上图分为四列：</p>
<ul>
<li>第一列为地址</li>
<li>第二列为数据</li>
<li>第三列为汇编命令</li>
<li>第四列为注释</li>
</ul>
<p>将上图中代码装入计算机中，状态如下图：</p>
<p><img src="/image/play_os_in_action/1_3.webp" alt="compile_code_status"></p>
<h1 id="第二讲实现一个最小内核">第二讲：实现一个最小内核</h1>
<h2 id="os引导流程">OS引导流程</h2>
<p><img src="/image/play_os_in_action/2_1.webp" alt="os_load"></p>
<p>BIOS固件负责检测和初始化CPU、内存及主办平台，然后加载引导设备（如磁盘）的第一个扇区地址的数据
到0x7c00地址开始的内存空间，街道跳转到0x7c00处执行指令，即GRUB指导程序</p>
<h2 id="引导汇编代码">引导汇编代码</h2>
<p>C作为通用的高级语言不能直接操作特定的硬件，而且C语言的函数调用、传参都 需要栈
所以需要汇编代码来出席这些C语言的工作环境</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">;彭东 @ 2021.01.09
MBT_HDR_FLAGS EQU 0x00010003
MBT_HDR_MAGIC EQU 0x1BADB002 ;多引导协议头魔数
MBT_HDR2_MAGIC EQU 0xe85250d6 ;第二版多引导协议头魔数
global _start ;导出_start符号
extern main ;导入外部的main函数符号
[section .start.text] ;定义.start.text代码节
[bits 32] ;汇编成32位代码
_start:
jmp _entry
ALIGN 8
mbt_hdr:
dd MBT_HDR_MAGIC
dd MBT_HDR_FLAGS
dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)
dd mbt_hdr
dd _start
dd 0
dd 0
dd _entry
;以上是GRUB所需要的头
ALIGN 8
mbt2_hdr:
DD MBT_HDR2_MAGIC
DD 0
DD mbt2_hdr_end - mbt2_hdr
DD -(MBT_HDR2_MAGIC + 0 + (mbt2_hdr_end - mbt2_hdr))
DW 2, 0
DD 24
DD mbt2_hdr
DD _start
DD 0
DD 0
DW 3, 0
DD 12
DD _entry
DD 0
DW 0, 0
DD 8
mbt2_hdr_end:
;以上是GRUB2所需要的头
;包含两个头是为了同时兼容GRUB、GRUB2
ALIGN 8
_entry:
;关中断
cli
;关不可屏蔽中断
in al, 0x70
or al, 0x80
out 0x70,al
;重新加载GDT
lgdt [GDT_PTR]
jmp dword 0x8 :_32bits_mode
_32bits_mode:
;下面初始化C语言可能会用到的寄存器
mov ax, 0x10
mov ds, ax
mov ss, ax
mov es, ax
mov fs, ax
mov gs, ax
xor eax,eax
xor ebx,ebx
xor ecx,ecx
xor edx,edx
xor edi,edi
xor esi,esi
xor ebp,ebp
xor esp,esp
;初始化栈，C语言需要栈才能工作
mov esp,0x9000
;调用C语言函数main
call main
;让CPU停止执行指令
halt_step:
halt
jmp halt_step
GDT_START:
knull_dsc: dq 0
kcode_dsc: dq 0x00cf9e000000ffff
kdata_dsc: dq 0x00cf92000000ffff
k16cd_dsc: dq 0x00009e000000ffff
k16da_dsc: dq 0x000092000000ffff
GDT_END:
GDT_PTR:
GDTLEN dw GDT_END-GDT_START-1
GDTBASE dd GDT_START
</code></pre></td></tr></table>
</div>
</div><ul>
<li>1~40行：GRUB多引导协议头</li>
<li>44~52行：关掉中断，设定CPU的工作模式</li>
<li>54~73行：初始化CPU的寄存器和C语言的运行环境</li>
<li>78~87行：设置CPU工作模式所需要的数据</li>
</ul>
<h2 id="主函数">主函数</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//main.c
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;vgastr.h&#34;</span><span class="cp">
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Hello OS!&#34;</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><h2 id="控制计算机屏幕">控制计算机屏幕</h2>
<p>显卡有多种形式</p>
<ul>
<li>集显：集成在主办</li>
<li>核显：CPU芯片内</li>
<li>独显：独立存在，同时PCIE接口连接</li>
</ul>
<p>显卡的字符模式将屏幕分成24行，每行80个字符，把字符映射到以0xb8000开始的内存中
一个字符对应两个字节，一个字节是字符的ASCII码，另外一个字节为字符的颜色值</p>
<p><img src="/image/play_os_in_action/2_2.webp" alt="byte_mode"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">// vgsstr.c
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">_strwrite</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">string</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">p_string</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">oxb8000</span><span class="p">);</span> <span class="c1">//显存开始的地址
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="o">*</span><span class="n">p_string</span> <span class="o">=</span> <span class="o">*</span><span class="n">string</span><span class="o">++</span><span class="p">;</span>
        <span class="n">p_string</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">printf</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span> 
<span class="p">{</span>
    <span class="n">_strwrite</span><span class="p">(</span><span class="n">fmt</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="编译和安装">编译和安装</h2>
<h3 id="编译">编译</h3>
<p><img src="/image/play_os_in_action/2_2.webp" alt="compile_process"></p>
<h3 id="安装">安装</h3>
<p>上述编译流程会得到HelloOS.bin文件，但序言GRUB能够找到它
具体配置在grub.cfg的文件中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">menuentry &#39;HelloOS&#39; {
     insmod part_msdos #GRUB加载分区模块识别分区
     insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统
     set root=&#39;hd0,msdos4&#39; #注意boot目录挂载的分区(df /boot 查看)
     multiboot2 /boot/HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin
     boot #GRUB启动HelloOS.bin
}
</code></pre></td></tr></table>
</div>
</div><p>重启系统长按shit键然后选择HelloOS即可</p>
<h1 id="第三讲内核结构设计">第三讲：内核结构设计</h1>
<h2 id="内核功能">内核功能</h2>
<ul>
<li>管理CPU：CPU是执行程序的，而内核吧运行时的程序抽象成 进程，所以称之为进程管理</li>
<li>管理内存</li>
<li>管理硬盘</li>
<li>管理显卡</li>
<li>管理各种I/O设备</li>
</ul>
<h2 id="宏内核结构">宏内核结构</h2>
<p>宏内核就是所有诸如管理进程等功能的代码进过编译链接形成一个大的可执行程序</p>
<p>这个大程序里有实现这个功能的所有代码，向应用软件提供一些接口（即系统API）
<img src="/image/play_os_in_action/3_1.webp" alt="macro-core"></p>
<p>宏内核的优点是组件都在内核中合一相互调用性能极高；但缺点也很明显，高度耦合，没有模块化</p>
<h2 id="微内核结构">微内核结构</h2>
<p>微内核仅仅只有进程调度、处理中断、内存空间映射和进程间通信等功能</p>
<p>实际功能如进程管理、内存管理、文件管理等做成一个个服务进程</p>
<p>微内核与应用进程和服务进程通过消息通信</p>
<p>应用程序要请求相关服务，就向微内核发送一条与此服务对应的消息，微内核再把这条消息转发给相关的服务进程，接着服务进程会完成相关的服务。</p>
<h2 id="我们的选择">我们的选择</h2>
<p>大致将内核分为三个大层</p>
<ul>
<li>内核接口层</li>
<li>内核功能层</li>
<li>内核硬件层</li>
</ul>
<p><img src="/image/play_os_in_action/3_2.webp" alt="core-structure"></p>
<h3 id="内核接口层">内核接口层</h3>
<ol>
<li>定义了一套UNIX接口的子集</li>
<li>检查参数的合法性</li>
</ol>
<h3 id="内核功能层">内核功能层</h3>
<p>主要完成各种事件功能</p>
<ol>
<li>进程管理：实现进程的创建、销毁、调度</li>
<li>内存管理：内存池分为页面内存池和任意大小的内存池</li>
<li>中断管理：把中断回调函数安插在相关的数据结构中，发生相关的中断就会调用回调函数</li>
<li>设备管理：把驱动程序模块、驱动程序本身和驱动程序创建的设备组织在一起</li>
</ol>
<h3 id="内核硬件层">内核硬件层</h3>
<ol>
<li>初始化：初始化少量的设备、CPU、内存、中断的控制，内核用户管理的数据结构</li>
<li>CPU控制：提供CPU模式设定、开关中断、读写CPU特定寄存器等功能</li>
<li>中断处理：保存上下文、调用中断回调函数、操作中断控制器</li>
<li>物理内存管理：分配和释放大块内存、内存空间映射、操作MMU和Cache</li>
<li>平台其他相关功能</li>
</ol>
<h1 id="第四讲业界成熟内核架构">第四讲：业界成熟内核架构</h1>
<h2 id="linux">Linux</h2>
<p><img src="/image/play_os_in_action/4_1.webp" alt="linux-core"></p>
<p>Linux使用的宏内核架构，模块之间的通信主要是函数调用</p>
<h2 id="darwin">Darwin</h2>
<p><img src="/image/play_os_in_action/4_2.jpg" alt="macos-core"></p>
<p>Darwin有两个内核层</p>
<ul>
<li>Mach层：微内核，然提供十分简单的进程、线程、IPC 通信、虚拟内存设备驱动相关的功能服务</li>
<li>BSD层：提供强大的安全特性，完善的网络服务，各种文件系统的支持，同时对 Mach 的进程、线程、IPC、虚拟内核组件进行细化、扩展延伸</li>
</ul>
<h2 id="windows-nt">Windows NT</h2>
<p><img src="/image/play_os_in_action/4_3.jpg" alt="windows-core"></p>
<p>每个执行体互相独立，只对外提供相应的接口，其它执行体要通过内核模式可调用接口和其它执行体通信或者请求其完成相应的功能服务</p>
<h2 id="评论区拾遗">评论区拾遗</h2>
<p>内核相当于所有的功能都耦合在一起，放在内核内
微内核是把大多数功能解耦出来，放在用户态，使用IPC在用户态调用服务进程
混合结构其实与微内核相似，只不过解耦出来的这些功能依然放在内核里，动态加载和卸载</p>
<h1 id="第五讲执行程序的三种模式">第五讲：执行程序的三种模式</h1>
<p>CPU的工作模式有三种</p>
<ul>
<li>实模式</li>
<li>保护模式</li>
<li>长模式</li>
</ul>
<h2 id="实模式">实模式</h2>
<p>实模式又称实地址模式，一方面是运行真实的指令，另一方面内存地址是真实的</p>
<h3 id="寄存器">寄存器</h3>
<p>通常情况下指令的操作数就是寄存器，下图为x86 实模式下的寄存器</p>
<p><img src="/image/play_os_in_action/5_1.webp" alt="physical_register"></p>
<h3 id="内存">内存</h3>
<p>指令和数据都放在内存中，内存的地址值计算过程如下图</p>
<p><img src="/image/play_os_in_action/5_2.webp" alt="physical_memory"></p>
<p>内存地址是由段寄存器左移4位，再加上一个统统寄存器的值形成地址，然后由这个地址去访问内存
（这个即是分段内存管理模式）</p>
<p>代码段是CS和IP确定的，栈段是由SS和SP确定的</p>
<p>DOS实模式汇编代码程序实例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-AS" data-lang="AS"><span class="nx">data</span> <span class="nx">SEGMENT</span> <span class="o">;</span><span class="err">定义一个数据段存放</span><span class="nx">Hello</span> <span class="nx">World</span><span class="o">!</span>
    <span class="nx">hello</span>  <span class="nx">DB</span> <span class="s1">&#39;Hello World!$&#39;</span> <span class="o">;</span><span class="err">注意要以</span><span class="nx">$结束</span>
<span class="nx">data</span> <span class="nx">ENDS</span>
<span class="nx">code</span> <span class="nx">SEGMENT</span> <span class="o">;</span><span class="err">定义一个代码段存放程序指令</span>
    <span class="nx">ASSUME</span> <span class="nx">CS</span><span class="o">:</span><span class="nx">CODE</span><span class="o">,</span><span class="nx">DS</span><span class="o">:</span><span class="nx">DATA</span> <span class="o">;</span><span class="err">告诉汇编程序，</span><span class="nx">DS指向数据段</span><span class="err">，</span><span class="nx">CS指向代码段</span>
<span class="nx">start</span><span class="o">:</span>
    <span class="nx">MOV</span> <span class="nx">AX</span><span class="o">,</span><span class="nx">data</span>  <span class="o">;</span><span class="err">将</span><span class="nx">data段首地址赋值给AX</span>                
    <span class="nx">MOV</span> <span class="nx">DS</span><span class="o">,</span><span class="nx">AX</span>    <span class="o">;</span><span class="err">将</span><span class="nx">AX赋值给DS</span><span class="err">，使</span><span class="nx">DS指向data段</span>
    <span class="nx">LEA</span> <span class="nx">DX</span><span class="o">,</span><span class="nx">hello</span> <span class="o">;</span><span class="err">使</span><span class="nx">DX指向hello首地址</span>
    <span class="nx">MOV</span> <span class="nx">AH</span><span class="o">,</span><span class="mi">09</span><span class="nx">h</span>   <span class="o">;</span><span class="err">给</span><span class="nx">AH设置参数09H</span><span class="err">，</span><span class="nx">AH是AX高8位</span><span class="err">，</span><span class="nx">AL是AX低8位</span><span class="err">，其它类似</span>
    <span class="nx">INT</span> <span class="mi">21</span><span class="nx">h</span>      <span class="o">;</span><span class="err">执行</span><span class="nx">DOS中断输出DS指向的DX指向的字符串hello</span>
    <span class="nx">MOV</span> <span class="nx">AX</span><span class="o">,</span><span class="mi">4</span><span class="nx">C00h</span> <span class="o">;</span><span class="err">给</span><span class="nx">AH设置参数4C00h</span>
    <span class="nx">INT</span> <span class="mi">21</span><span class="nx">h</span>      <span class="o">;</span><span class="err">调用</span><span class="mi">4</span><span class="nx">C00h号功能</span><span class="err">，结束程序</span>
<span class="nx">code</span> <span class="nx">ENDS</span>
<span class="nx">END</span> <span class="nx">start</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="中断">中断</h3>
<p>中断即终止当前程序，转而跳转到另一个特定的地址上，去运行特定的代码。</p>
<p>在实模式中即：先保存CS和IP寄存器，然后装载新的CS和IP寄存器</p>
<p><img src="/image/play_os_in_action/5_3.webp" alt="interrupt-vector-table">
为了实现中断，就需要在内存中放一个中断向量表（中断信号和对应响应程序的首地址）</p>
<p>这个表的地址和长度由IDTR寄存器指向，在实模式中，一个条目由代码段地址和端内偏移组成</p>
<p>根据中断信合和IDTR寄存器的信息，CPU能够计算出中断向量的条目，进而装载CS（段基地址）、IP寄存器（段内偏移），最终响应中断</p>
<h2 id="保护模式">保护模式</h2>
<p><img src="/image/play_os_in_action/5_4.webp" alt="protected-register"></p>
<p>相比实模式，保护模式增加了一些控制寄存器和段寄存器，扩展通用寄存器的位宽</p>
<h3 id="特权级">特权级</h3>
<p><img src="/image/play_os_in_action/5_5.webp" alt="protected-privilege-level"></p>
<p>从内到外，权力逐步提升</p>
<h3 id="段描述符">段描述符</h3>
<p><img src="/image/play_os_in_action/5_6.webp" alt="protected-segment-descriptor"></p>
<p>内存是分段模型，对内存的保护可以转化成对段的保护</p>
<p>段描述符是一个64位的数据，包含了段基地址、段长度、段权限、段类型和读写状态等</p>
<p>由于信息的扩展，16位的寄存器放不下，段描述符放在内存中</p>
<p>多个段描述符在内存中形成全局段描述符表，该表的基地址和长度由GDTR寄存器指示</p>
<p><img src="/image/play_os_in_action/5_7.webp" alt="protected-segment-descriptor-table"></p>
<p>段寄存器不再放段基地址，而是段在段描述符表的索引</p>
<h3 id="平坦模型">平坦模型</h3>
<p>x86 CPU不能直接使用分页模型，通过简化设计，来时分段称为一个&quot;虚设&quot;，这个称之为保护模式的平坦模型</p>
<p>将段的基地址设为0，段长度设为0xFFFFF(2 ** 20 = 1M),段的粒度为4KB
在此模式下不同的段可以重叠、交叉和包含</p>
<h3 id="中断-1">中断</h3>
<p>保护模式需要检查权限，所以需要扩展中断向量表的信息
每个中断用一个中断门描述符来表示，格式如下</p>
<p><img src="/image/play_os_in_action/5_8.webp" alt="protected-interrupt"></p>
<p>中断向量表的条目也变成了中断门描述符
<img src="/image/play_os_in_action/5_9.webp" alt="protected-interrupt-table"></p>
<p>产生中断后</p>
<ol>
<li>检查中断号是否在有效区间（0~255）</li>
<li>检查描述符类型</li>
<li>权限检查（如果权限等级不同会进行栈切换）</li>
<li>加载目标代码偏移段到EIP寄存器</li>
</ol>
<h3 id="切换">切换</h3>
<p>由实模式切换到保护模式步骤如下：</p>
<ol>
<li>准备全局段描述符表</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">GDT_START:
knull_dsc: dq 0
kcode_dsc: dq 0x00cf9e000000ffff
kdata_dsc: dq 0x00cf92000000ffff
GDT_END:
GDT_PTR:
GDTLEN  dw GDT_END-GDT_START-1
GDTBASE  dd GDT_START
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>设置GDTR寄存器，使之指向全局段描述符表</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">lgdt [GDT_PTR]
</code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>设置CR0寄存器，开启保护模式</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">;开启 PE
mov eax, cr0
bts eax, 0                      ; CR0.PE =1
mov cr0, eax         
</code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>进行长跳转，加载CS段寄存器</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">jmp dword 0x8 :_32bits_mode ;_32bits_mode为32位代码标号即段偏移
</code></pre></td></tr></table>
</div>
</div><h2 id="长模式">长模式</h2>
<p>长模式又称AMD64，它是CPU在现有基础上有了64位的处理能力</p>
<h3 id="寄存器-1">寄存器</h3>
<p>所有通用寄存器都是64位，可以单独使用低32位，低32位可以查封成一个低16位，低16位可以拆分成两个8位寄存器</p>
<p><img src="/image/play_os_in_action/5_10.webp" alt="amd64-register"></p>
<h3 id="段描述符-1">段描述符</h3>
<p><img src="/image/play_os_in_action/5_11.webp" alt="amd64-segment-descriptor"></p>
<h3 id="中断-2">中断</h3>
<p><img src="/image/play_os_in_action/5_12.webp" alt="amd64-interrupt"></p>
<h3 id="切换-1">切换</h3>
<ol>
<li>准备长模式全局段描述符表</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">ex64_GDT:
null_dsc:  dq 0
;第一个段描述符CPU硬件规定必须为0
c64_dsc:dq 0x0020980000000000  ;64位代码段
d64_dsc:dq 0x0000920000000000  ;64位数据段
eGdtLen   equ $ - null_dsc  ;GDT长度
eGdtPtr:dw eGdtLen - 1  ;GDT界限
     dq ex64_GDT
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>准备长模式下的MMU页表</li>
</ol>
<p>长模式下内存地址空间的保护交给了 MMU，MMU 依赖页表对地址进行转换，页表有特定的格式存放在内存中，其地址由 CPU 的 CR3 寄存器指向</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">mov eax, cr4
bts eax, 5   ;CR4.PAE = 1
mov cr4, eax ;开启 PAE
mov eax, PAGE_TLB_BADR ;页表物理地址
mov cr3, eax
</code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>加载GDTR寄存器，是指指向全局段描述符</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">lgdt [eGdtPtr]
</code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>开启长模式</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">;开启 64位长模式
mov ecx, IA32_EFER
rdmsr
bts eax, 8  ;IA32_EFER.LME =1
wrmsr
;开启 保护模式和分页模式
mov eax, cr0
bts eax, 0    ;CR0.PE =1
bts eax, 31
mov cr0, eax 
</code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>进行跳转，加载CS段寄存器</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">jmp 08:entry64 ;entry64为程序标号即64位偏移地址
</code></pre></td></tr></table>
</div>
</div><h1 id="第六讲地址转换">第六讲：地址转换</h1>
<h2 id="虚拟地址">虚拟地址</h2>
<p>虚拟地址由链接器产生，链接器的主要工作是吧多个代码模块组装在一起，并解决模块之间的引用
，即处理程序代码间的地址引用，形成程序运行的静态内存空间视图</p>
<h2 id="物理地址">物理地址</h2>
<p>物理地址会被地址译码器变成电信号，放在地址总线上，地址总线电子信号的各种组合就可以选择到内存的存储单元</p>
<h2 id="虚实转换">虚实转换</h2>
<p>虚实地址转换是通过MMU（内存管理单元）实现的</p>
<p><img src="/image/play_os_in_action/6_1.webp" alt="convert-virtual-address"></p>
<p>地址转换关系表本身存放在内存中，如果一个虚拟对称对应一个物理地址，转换表就会把内存耗尽</p>
<p>于是引出了分页模型，虚拟地址空间和物理地址空间都分成了同等大小的页</p>
<p><img src="/image/play_os_in_action/6_2.webp" alt="page-mode"></p>
<h2 id="mmu">MMU</h2>
<p>MMU负责接受虚拟地址值和地址关系转换表，然后输出物理地址</p>
<h3 id="页表">页表</h3>
<p>页表即虚拟页到物理页的映射关系</p>
<p>为了洁身空间，页表值存放物理页面的地址，MMU以虚拟地址为索引去查表返回物理页地址</p>
<p>页表是分级的，分为三部分</p>
<ul>
<li>一个顶级页目录</li>
<li>多个中继页目录</li>
<li>页表</li>
</ul>
<p><img src="/image/play_os_in_action/6_3.webp" alt="page-mode2"></p>
<p>一个虚拟地址从左到右分为四个位段</p>
<ul>
<li>第一个位段索引顶级页目录，得到中继页目录</li>
<li>第二个位段索引中级页目录，得到页目录</li>
<li>第三个位段索引也目录，得到物理页地址</li>
<li>第四个位段用作该物理页的偏移去访问物理内存</li>
</ul>
<h3 id="保护模式下的分页">保护模式下的分页</h3>
<p>保护模式下只有32位地址空间，32位虚拟地址经过分段机制后得到线性地址，
通常使用平坦模式，所以线性地址和虚拟地址是相同的</p>
<h4 id="4kb页">4KB页</h4>
<p>该分页方式下32位虚拟地址被分为三个位段： 页目录索引、页表索引、页内偏移</p>
<p><img src="/image/play_os_in_action/6_4.webp" alt="page-mode3"></p>
<p>CR3寄存器、页目录项和页表项都是32位，所以低12位可以另做它用，形成了页面相关属性，如
是否存在，是否可读写、是否已访问等待</p>
<p><img src="/image/play_os_in_action/6_5.jpg" alt="page-mode4">
<img src="/image/play_os_in_action/6_6.jpg" alt="page-mode5">
<img src="/image/play_os_in_action/6_7.jpg" alt="page-mode6"></p>
<h4 id="4mb页">4MB页</h4>
<p>该分页方式下，32位虚拟地址被分为2段：页表索引、页内偏移</p>
<p>共1024个条目，每个条目指向一个物理页4MB,正好为4GB地址空间</p>
<p><img src="/image/play_os_in_action/6_8.webp" alt="page-mode7"></p>
<p>CR3还是32位寄存器，指向一个4KB大小的页表，仍然要4KB地址对齐，其中包含1024个页表项</p>
<h3 id="长模式下的分页">长模式下的分页</h3>
<p>长模式下扩展为64位</p>
<h4 id="4kb页-1">4KB页</h4>
<p><img src="/image/play_os_in_action/6_9.webp" alt="long-mode1"></p>
<p>64位虚拟地址被分为6段</p>
<ul>
<li>保留位段： 24位</li>
<li>顶级页目录索引段：9位</li>
<li>页目录指针段： 9位</li>
<li>页目录段：9位</li>
<li>页表段： 9位</li>
<li>页内偏移：12位</li>
</ul>
<p>顶级页目录、页目录指针、页目录、页表都各占4KB, 各512个条目，每个条目8B即64位</p>
<p>因为x86 CPU并没有实现全64位的地址总线，而是只实现了48位，但寄存器却是64位的，
当第47位是1的时候48~63为1，反之为0</p>
<h4 id="2mb页">2MB页</h4>
<p>该方式下分为5个分段</p>
<ul>
<li>保留位段： 16位</li>
<li>顶级页目录索引：9位</li>
<li>页目录指针索引：9位</li>
<li>页目录索引：9位</li>
<li>页内偏移：21位</li>
</ul>
<p>顶级页目录、页目录指针、页目录都各占4KB, 各512个条目，每个条目8B即64位
页表项被放弃，页目录项直接指定了2MB大小的物理页面</p>
<h3 id="开启mmu">开启MMU</h3>
<ol>
<li>使CPU进入保护模式或长模式</li>
<li>准备页表数据</li>
<li>将顶级页目录的物理地址赋值给CR3寄存器</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">mov eax, PGAE_TLB_BADR ;页表物理地址
mov cr3, eax
</code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>将CPU的CR0的PE为设置为0，这样就开启了 MMU</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">;开启保护模式和分页模式
mov eax, cr0
bts eax, 0    ;CR0.PE = 1
bts eax, 31   ;CR0.P = 1
mov cr0, eax
</code></pre></td></tr></table>
</div>
</div><h1 id="第七讲cache与内存">第七讲：Cache与内存</h1>
<h2 id="内存-1">内存</h2>
<p>控制内存读写和刷新的是内存控制器，内存控制器集成在北桥芯片中</p>
<p>由于制造工艺升级，现在北桥芯片被集成到了CPU芯片，这样大大提升了CPU访问内存的性能</p>
<h2 id="cache">Cache</h2>
<p>通过程序的局部性原理可以知道CPU大多数时间在访问相同或者相近的地址</p>
<p>那么可以用一块小而快的存储器放在CPU和内存之间，来缓解CPU和内存的之间的性能差距</p>
<p>这个就称之为Cache</p>
<p>Cache中存放了部分内存数据，CPU在访问内存时要先访问Cache</p>
<p>现在的x86 CPU是将Cache集成在CPU内</p>
<p><img src="/image/play_os_in_action/7_1.webp" alt="cache"></p>
<p>Cache主要由高速的静态存储器、地址转换模块和行替换模块组成</p>
<p>Cache会把存储器分成若干行，每行32字节或64字节，和内存交换数据最小单位为一行</p>
<p>为了方便管理，多个行又会组成一组</p>
<p>除了正常数据外，行中还有一些标志位，如脏位、回写位等</p>
<p>Cache的大致工作流程如下:</p>
<ol>
<li>CPU发出的地址由Cache的地址转换模块分成3段：组号、行号和行内偏移</li>
<li>Cache会根据组号、行号查找高速静态存储器中对应的行。如果找到即命中，用行内偏移读取并返回数据给CPU;
否则就分配一个新行并访问内存，把内存中对应的数据加载到Cache行并返回给CPU。
写入操作分为回写和直写，回写就是写入对应的Cache行即可，直写写入Cache行的同时会写入内存</li>
<li>如果容量不足，就要进入行替换逻辑，即找出一个Cache行写回内存，腾出空间。</li>
</ol>
<h2 id="cache引入的问题">Cache引入的问题</h2>
<p><img src="/image/play_os_in_action/7_2.webp" alt="x86_cache"></p>
<p>上图是简单的双核心CPU，有三级Cache，第一级Cache是指令和数据分开的，
第二级是独立于CPU核心的，第三级是所有CPU核心共享的。</p>
<p>Cache一致性问题主要包括以下三个：</p>
<ol>
<li>一个CPU中指令Cache和数据Cache一致性的问题</li>
<li>多个CPU各自的2级Cache一致性问题</li>
<li>3级Cache与网卡、显存等设备存储之间的一致性问题</li>
</ol>
<h2 id="cache的mesi协议">Cache的MESI协议</h2>
<p>MESI协议定义了四种基本状态</p>
<ol>
<li>
<p>Modified
当前Cache内容有效，但已和内存不一致，且不存在其他核心的Cache中</p>
</li>
<li>
<p>Exclusive
当前Cache内容有效，和内存一致，但不存在其他核心的Cache中</p>
</li>
<li>
<p>Shared</p>
</li>
</ol>
<p>当前Cache内容有效，和内存一致，且在其他核心的Cache中也一至</p>
<ol start="4">
<li>Invalid
其他情况，当前Cache无效</li>
</ol>
<h1 id="第八讲锁-并发操作中如何让数据同步">第八讲：锁-并发操作中如何让数据同步</h1>
<h2 id="方法一-原子操作-拿下单体变量">方法一： 原子操作， 拿下单体变量</h2>
<p>C语言可以嵌入汇编代码实现原子操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="c1">//定义一个原子类型
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_ATOMIC</span><span class="p">{</span>
    <span class="k">volatile</span> <span class="n">s32_t</span> <span class="n">a_count</span><span class="p">;</span> <span class="c1">//在变量前加上volatile，是为了禁止编译器优化，使其每次都从内存中加载变量
</span><span class="c1"></span><span class="p">}</span><span class="n">atomic_t</span><span class="p">;</span>
<span class="c1">//原子读
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="n">s32_t</span> <span class="nf">atomic_read</span><span class="p">(</span><span class="k">const</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>        
        <span class="c1">//x86平台取地址处是原子
</span><span class="c1"></span>        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u32_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">a_count</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//原子写
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atomic_write</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">//x86平台把一个值写入一个地址处也是原子的 
</span><span class="c1"></span>        <span class="n">v</span><span class="o">-&gt;</span><span class="n">a_count</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//原子加上一个整数
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atomic_add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&#34;lock;&#34;</span> <span class="s">&#34;addl %1,%0&#34;</span>
                     <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">a_count</span><span class="p">)</span>
                     <span class="o">:</span> <span class="s">&#34;ir&#34;</span> <span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">//原子减去一个整数
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atomic_sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&#34;lock;&#34;</span> <span class="s">&#34;subl %1,%0&#34;</span>
                     <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">a_count</span><span class="p">)</span>
                     <span class="o">:</span> <span class="s">&#34;ir&#34;</span> <span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">//原子加1
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atomic_inc</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&#34;lock;&#34;</span> <span class="s">&#34;incl %0&#34;</span>
                       <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">a_count</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">//原子减1
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atomic_dec</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
       <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&#34;lock;&#34;</span> <span class="s">&#34;decl %0&#34;</span>
                     <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">a_count</span><span class="p">));</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>加上lock前缀的addl、subl、incl、decl指令都是原子操作，lock前缀表示锁定总线，CPU能互斥使用特定的内存地址</p>
<p>代码模板以<code>__asm__ __volatile</code>开始，后面括号内容分为四个部分，以<code>:</code>分割
以<code>atomic_add</code>举例：</p>
<ol>
<li>汇编代码， <code>&quot;lock&quot;; &quot;add %1, %0&quot;</code></li>
<li>输出列表，<code>&quot;+m&quot; (v-&gt;a_count)</code>，&quot;+m&quot;表示输出和内存地址关联</li>
<li>输入列表， <code>&quot;ir&quot;</code>, &ldquo;r&quot;表示输入i和寄存器关联</li>
<li>损坏部分，告诉编译器使用了哪些寄存器，以便保存和恢复寄存器的值</li>
</ol>
<h2 id="方法二-中断控制搞定复杂变量">方法二： 中断控制，搞定复杂变量</h2>
<p>x86 使用cli、sti 指令关闭和开启中断，它们主要是对CPU的eflags寄存器的IF位（第9位）进行
清除和设置，CPU通过此位来决定是否响应中断信号</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">// 关闭中断
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">hal_cli</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&#34;cli&#34;</span><span class="o">:</span> <span class="o">:</span> <span class="o">:</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 开启中断
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">hal_sti</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&#34;sti&#34;</span><span class="o">:</span> <span class="o">:</span> <span class="o">:</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面这种方式不支持嵌套调用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">hal_cli</span><span class="p">();</span>
    <span class="p">...</span>
    <span class="n">hal_sti</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">hal_cli</span><span class="p">();</span>
    <span class="n">foo</span><span class="p">();</span>
    <span class="p">...</span>
    <span class="n">hal_sti</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>解决方案为：</p>
<ul>
<li>关闭中断函数先保存eflags寄存器，然后执行cli指令</li>
<li>开启中断函数恢复保存的eflags寄存器的值</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="k">typedef</span> <span class="n">u32_t</span> <span class="n">cpuflg_t</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hal_save_flags_cli</span><span class="p">(</span><span class="n">cpuflg_t</span><span class="o">*</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
     <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
            <span class="s">&#34;pushfl </span><span class="se">\t\n</span><span class="s">&#34;</span> <span class="c1">//把eflags寄存器压入当前栈顶
</span><span class="c1"></span>            <span class="s">&#34;cli    </span><span class="se">\t\n</span><span class="s">&#34;</span> <span class="c1">//关闭中断
</span><span class="c1"></span>            <span class="s">&#34;popl %0 </span><span class="se">\t\n</span><span class="s">&#34;</span><span class="c1">//把当前栈顶弹出到eflags为地址的内存中        
</span><span class="c1"></span>            <span class="o">:</span> <span class="s">&#34;=m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">)</span>
            <span class="o">:</span>
            <span class="o">:</span> <span class="s">&#34;memory&#34;</span>
          <span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hal_restore_flags_sti</span><span class="p">(</span><span class="n">cpuflg_t</span><span class="o">*</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
              <span class="s">&#34;pushl %0 </span><span class="se">\t\n</span><span class="s">&#34;</span><span class="c1">//把flags为地址处的值寄存器压入当前栈顶
</span><span class="c1"></span>              <span class="s">&#34;popfl </span><span class="se">\t\n</span><span class="s">&#34;</span>   <span class="c1">//把当前栈顶弹出到eflags寄存器中
</span><span class="c1"></span>              <span class="o">:</span>
              <span class="o">:</span> <span class="s">&#34;m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">)</span>
              <span class="o">:</span> <span class="s">&#34;memory&#34;</span>
              <span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="方法三-自旋锁协调多核心cpu">方法三： 自旋锁，协调多核心CPU</h2>
<p>控制中断只能控制当前CPU的中断，不能控制其他CPU的中断</p>
<p>自旋锁原理如下图所示：</p>
<p><img src="/image/play_os_in_action/8_1.webp" alt="spin_lock"></p>
<p>如果需要正确执行，需要保证读取锁变量和判断并加锁的操作是原子的</p>
<p>x86 提供了一个原子交换指令<code>xchg</code>，它可以让寄存器的值和内存空间的值进行交换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//自旋锁结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
     <span class="k">volatile</span> <span class="n">u32_t</span> <span class="n">lock</span><span class="p">;</span><span class="c1">//volatile可以防止编译器优化，保证其它代码始终从内存加载lock变量的值 
</span><span class="c1"></span><span class="p">}</span> <span class="n">spinlock_t</span><span class="p">;</span>
<span class="c1">//锁初始化函数
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x86_spin_lock_init</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
     <span class="n">lock</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//锁值初始化为0是未加锁状态
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//加锁函数
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x86_spin_lock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
    <span class="s">&#34;1: </span><span class="se">\n</span><span class="s">&#34;</span>
    <span class="s">&#34;lock; xchg  %0, %1 </span><span class="se">\n</span><span class="s">&#34;</span><span class="c1">//把值为1的寄存器和lock内存中的值进行交换
</span><span class="c1"></span>    <span class="s">&#34;cmpl   $0, %0 </span><span class="se">\n</span><span class="s">&#34;</span> <span class="c1">//用0和交换回来的值进行比较
</span><span class="c1"></span>    <span class="s">&#34;jnz    2f </span><span class="se">\n</span><span class="s">&#34;</span>  <span class="c1">//不等于0则跳转后面2标号处运行
</span><span class="c1"></span>    <span class="s">&#34;jmp 3f </span><span class="se">\n</span><span class="s">&#34;</span>     <span class="c1">//若等于0则跳转后面3标号处返回
</span><span class="c1"></span>    <span class="s">&#34;2:         </span><span class="se">\n</span><span class="s">&#34;</span> 
    <span class="s">&#34;cmpl   $0, %1  </span><span class="se">\n</span><span class="s">&#34;</span><span class="c1">//用0和lock内存中的值进行比较
</span><span class="c1"></span>    <span class="s">&#34;jne    2b      </span><span class="se">\n</span><span class="s">&#34;</span><span class="c1">//若不等于0则跳转到前面2标号处运行继续比较  
</span><span class="c1"></span>    <span class="s">&#34;jmp    1b      </span><span class="se">\n</span><span class="s">&#34;</span><span class="c1">//若等于0则跳转到前面1标号处运行，交换并加锁
</span><span class="c1"></span>    <span class="s">&#34;3:  </span><span class="se">\n</span><span class="s">&#34;</span>     
    <span class="o">:</span>
    <span class="o">:</span> <span class="s">&#34;r&#34;</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> 
    <span class="s">&#34;m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">//解锁函数
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x86_spin_unlock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
    <span class="s">&#34;movl   $0, %0</span><span class="se">\n</span><span class="s">&#34;</span><span class="c1">//解锁把lock内存中的值设为0就行
</span><span class="c1"></span>    <span class="o">:</span>
    <span class="o">:</span> <span class="s">&#34;m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>xchg %0, %1</code>其中 <code>%0</code> 对应<code>&quot;r&quot;(1)</code>，表示编译器自动分配一个通用寄存器，并填入值1；
而 <code>%1</code>对应<code>&quot;m&quot;(*lock)</code>，表示lock是内存地址。
把1和内存的值交换，如果内存值是1，则不影响，否则已交换内存就变成了1，即加锁成功。</p>
<p>自旋锁需要在处理中断的过程中也能使用，所以需要改进</p>
<ul>
<li>获取自旋锁时先关闭中断</li>
<li>释放自旋锁后恢复</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x86_spin_lock_disable_irq</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">,</span><span class="n">cpuflg_t</span><span class="o">*</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
    <span class="s">&#34;pushfq                 </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;cli                    </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;popq %0                </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;1:         </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;lock; xchg  %1, %2 </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;cmpl   $0,%1       </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;jnz    2f      </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;jmp    3f      </span><span class="se">\n</span><span class="s">&#34;</span>  
    <span class="s">&#34;2:         </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;cmpl   $0,%2       </span><span class="se">\n\t</span><span class="s">&#34;</span> 
    <span class="s">&#34;jne    2b      </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;jmp    1b      </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;3:     </span><span class="se">\n</span><span class="s">&#34;</span>     
    <span class="o">:</span><span class="s">&#34;=m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">)</span>
    <span class="o">:</span> <span class="s">&#34;r&#34;</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s">&#34;m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x86_spin_unlock_enabled_irq</span><span class="p">(</span><span class="n">spinlock_t</span><span class="o">*</span> <span class="n">lock</span><span class="p">,</span><span class="n">cpuflg_t</span><span class="o">*</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
    <span class="s">&#34;movl   $0, %0</span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;pushq %1 </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;popfq </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="o">:</span>
    <span class="o">:</span> <span class="s">&#34;m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">),</span> <span class="s">&#34;m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="方法四-信号量时间管理大师">方法四： 信号量，时间管理大师</h2>
<p>信号量可以对资源进行保护，同一时刻只有一个代码执行流，又能在资源无法满足的情况下，让CPU执行其他任务</p>
<p>信号量数据结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="cp">#define SEM_FLG_MUTEX 0
</span><span class="cp">#define SEM_FLG_MULTI 1
</span><span class="cp">#define SEM_MUTEX_ONE_LOCK 1
</span><span class="cp">#define SEM_MULTI_LOCK 0
</span><span class="cp"></span><span class="c1">//等待链数据结构，用于挂载等待代码执行流（线程）的结构，里面有用于挂载代码执行流的链表和计数器变量，这里我们先不深入研究这个数据结构。
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_KWLST</span>
<span class="p">{</span>   
    <span class="n">spinlock_t</span> <span class="n">wl_lock</span><span class="p">;</span>
    <span class="n">uint_t</span>   <span class="n">wl_tdnr</span><span class="p">;</span>
    <span class="n">list_h_t</span> <span class="n">wl_list</span><span class="p">;</span>
<span class="p">}</span><span class="n">kwlst_t</span><span class="p">;</span>
<span class="c1">//信号量数据结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_SEM</span>
<span class="p">{</span>
    <span class="n">spinlock_t</span> <span class="n">sem_lock</span><span class="p">;</span><span class="c1">//维护sem_t自身数据的自旋锁
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">sem_flg</span><span class="p">;</span><span class="c1">//信号量相关的标志
</span><span class="c1"></span>    <span class="n">sint_t</span> <span class="n">sem_count</span><span class="p">;</span><span class="c1">//信号量计数值
</span><span class="c1"></span>    <span class="n">kwlst_t</span> <span class="n">sem_waitlst</span><span class="p">;</span><span class="c1">//用于挂载等待代码执行流（线程）结构
</span><span class="c1"></span><span class="p">}</span><span class="n">sem_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>假定信号量sem_count初始化为1，等待链sem_waitlst初始化为空</p>
<p>信号量的获取down和释放up的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="c1">//获取信号量
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">krlsem_down</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cpuflg_t</span> <span class="n">cpufg</span><span class="p">;</span>
<span class="nl">start_step</span><span class="p">:</span>    
    <span class="n">krlspinlock_cli</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_lock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span><span class="c1">//获取自旋锁
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_count</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span><span class="c1">//如果信号量值小于1,则让代码执行流（线程）睡眠
</span><span class="c1"></span>        <span class="n">krlwlst_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_waitlst</span><span class="p">);</span>
        <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_lock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span>
        <span class="n">krlschedul</span><span class="p">();</span><span class="c1">//切换代码执行流，下次恢复执行时依然从下一行开始执行，所以要goto开始处重新获取信号量
</span><span class="c1"></span>        <span class="k">goto</span> <span class="n">start_step</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_count</span><span class="o">--</span><span class="p">;</span><span class="c1">//信号量值减1,表示成功获取信号量
</span><span class="c1"></span>    <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_lock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span><span class="c1">//释放自旋锁
</span><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//释放信号量
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">krlsem_up</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cpuflg_t</span> <span class="n">cpufg</span><span class="p">;</span>
    <span class="n">krlspinlock_cli</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_lock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span> <span class="c1">//获取自旋锁
</span><span class="c1"></span>    <span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_count</span><span class="o">++</span><span class="p">;</span><span class="c1">//释放信号量
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_count</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span><span class="c1">//如果小于1,则说数据结构出错了，挂起系统
</span><span class="c1"></span>        <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_lock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span>
        <span class="n">hal_sysdie</span><span class="p">(</span><span class="s">&#34;sem up err&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//唤醒该信号量上所有等待的代码执行流（线程）
</span><span class="c1"></span>    <span class="n">krlwlst_allup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_waitlst</span><span class="p">);</span>
    <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_lock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span>
    <span class="n">krlsched_set_schedflgs</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="获取信号量">获取信号量</h3>
<ol>
<li>对用于保护信号量本身的自旋锁sem_lock加锁</li>
<li>判断sem_count的值: 如果小于1则让进程进入等待状态并将其挂入sem_waitlst；
否则表示信号量获取成功，将sem_count-1，并释放自旋锁</li>
</ol>
<h3 id="释放信号量">释放信号量</h3>
<ol>
<li>对用于保护信号量本身的自旋锁sem_lock加锁</li>
<li>对sem_count+1</li>
<li>唤醒sem_waitlst的进程，释放自旋锁</li>
</ol>
<h1 id="第九讲-linux的并发实现">第九讲 Linux的并发实现</h1>
<h2 id="原子变量">原子变量</h2>
<p>Linux提供了一个原子类型变量atomic_t</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="n">tyepedef</span> <span class="k">struct</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>
<span class="p">}</span> <span class="n">atomic_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">s64</span> <span class="n">counter</span><span class="p">;</span>    
<span class="p">}</span> <span class="n">atomic64_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>操作函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="c1">//原子读取变量中的值
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">int</span> <span class="nf">arch_atomic_read</span><span class="p">(</span><span class="k">const</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">__READ_ONCE</span><span class="p">((</span><span class="n">v</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//原子写入一个具体的值
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_atomic_set</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__WRITE_ONCE</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//原子加上一个具体的值
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_atomic_add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="n">LOCK_PREFIX</span> <span class="s">&#34;addl %1,%0&#34;</span>
             <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">)</span>
             <span class="o">:</span> <span class="s">&#34;ir&#34;</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//原子减去一个具体的值
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_atomic_sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="n">LOCK_PREFIX</span> <span class="s">&#34;subl %1,%0&#34;</span>
             <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">)</span>
             <span class="o">:</span> <span class="s">&#34;ir&#34;</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//原子加1
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_atomic_inc</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="n">LOCK_PREFIX</span> <span class="s">&#34;incl %0&#34;</span>
             <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">)</span> <span class="o">::</span> <span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//原子减1
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_atomic_dec</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="n">LOCK_PREFIX</span> <span class="s">&#34;decl %0&#34;</span>
             <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">)</span> <span class="o">::</span> <span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>



<span class="cp">#define __READ_ONCE(x)  \
</span><span class="cp">(*(const volatile __unqual_scalar_typeof(x) *)&amp;(x))
</span><span class="cp">#define __WRITE_ONCE(x, val) \
</span><span class="cp">do {*(volatile typeof(x) *)&amp;(x) = (val);} while (0)
</span><span class="cp"></span><span class="c1">//__unqual_scalar_typeof表示声明一个非限定的标量类型，非标量类型保持不变。说人话就是返回x变量的类型，这是GCC的功能，typeof只是纯粹返回x的类型。
</span><span class="c1"></span>
<span class="c1">//如果 x 是int类型则返回“int” 
</span><span class="c1"></span><span class="cp">#define __READ_ONCE(x)  \
</span><span class="cp">(*(const volatile int *)&amp;(x))
</span><span class="cp">#define __WRITE_ONCE(x, val) \
</span><span class="cp">do {*(volatile int *)&amp;(x) = (val);} while (0) 
</span></code></pre></td></tr></table>
</div>
</div><h2 id="中断控制">中断控制</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="c1">//实际保存eflags寄存器
</span><span class="c1"></span><span class="k">extern</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">native_save_fl</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;# __raw_save_flags</span><span class="se">\n\t</span><span class="s">&#34;</span>
                 <span class="s">&#34;pushf ; pop %0&#34;</span><span class="o">:</span><span class="s">&#34;=rm&#34;</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span><span class="o">::</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//实际恢复eflags寄存器
</span><span class="c1"></span><span class="k">extern</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">native_restore_fl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">){</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;push %0 ; popf&#34;</span><span class="o">::</span><span class="s">&#34;g&#34;</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span><span class="o">:</span><span class="s">&#34;memory&#34;</span><span class="p">,</span><span class="s">&#34;cc&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//实际关中断
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">native_irq_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;cli&#34;</span><span class="o">:::</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//实际开启中断
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">native_irq_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;sti&#34;</span><span class="o">:::</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//arch层关中断
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_local_irq_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">native_irq_disable</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">//arch层开启中断
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_local_irq_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span> 
    <span class="n">native_irq_enable</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">//arch层保存eflags寄存器
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="nf">arch_local_save_flags</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">native_save_fl</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">//arch层恢复eflags寄存器
</span><span class="c1"></span><span class="k">static</span>  <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_local_irq_restore</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">){</span>
    <span class="n">native_restore_fl</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//实际保存eflags寄存器并关中断
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">arch_local_irq_save</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">arch_local_save_flags</span><span class="p">();</span>
    <span class="n">arch_local_irq_disable</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//raw层关闭开启中断宏
</span><span class="c1"></span><span class="cp">#define raw_local_irq_disable()     arch_local_irq_disable()
</span><span class="cp">#define raw_local_irq_enable()      arch_local_irq_enable()
</span><span class="cp"></span><span class="c1">//raw层保存恢复eflags寄存器宏
</span><span class="c1"></span><span class="cp">#define raw_local_irq_save(flags)           \
</span><span class="cp">    do {                        \
</span><span class="cp">        typecheck(unsigned long, flags);    \
</span><span class="cp">        flags = arch_local_irq_save();      \
</span><span class="cp">    } while (0)
</span><span class="cp"></span>    
<span class="cp">#define raw_local_irq_restore(flags)            \
</span><span class="cp">    do {                        \
</span><span class="cp">        typecheck(unsigned long, flags);    \
</span><span class="cp">        arch_local_irq_restore(flags);      \
</span><span class="cp">    } while (0)
</span><span class="cp"></span>    
<span class="cp">#define raw_local_save_flags(flags)         \
</span><span class="cp">    do {                        \
</span><span class="cp">        typecheck(unsigned long, flags);    \
</span><span class="cp">        flags = arch_local_save_flags();    \
</span><span class="cp">    } while (0)
</span><span class="cp"></span><span class="c1">//通用层接口宏 
</span><span class="c1"></span><span class="cp">#define local_irq_enable()              \
</span><span class="cp">    do { \
</span><span class="cp">        raw_local_irq_enable();         \
</span><span class="cp">    } while (0)
</span><span class="cp"></span>
<span class="cp">#define local_irq_disable()             \
</span><span class="cp">    do {                        \
</span><span class="cp">        raw_local_irq_disable();        \
</span><span class="cp">    } while (0)
</span><span class="cp"></span>
<span class="cp">#define local_irq_save(flags)               \
</span><span class="cp">    do {                        \
</span><span class="cp">        raw_local_irq_save(flags);      \
</span><span class="cp">    } while (0)
</span><span class="cp"></span>
<span class="cp">#define local_irq_restore(flags)            \
</span><span class="cp">    do {                        \
</span><span class="cp">        raw_local_irq_restore(flags);       \
</span><span class="cp">    } while (0)
</span></code></pre></td></tr></table>
</div>
</div><p><code>do{}while(0)</code>表达式会保证<code>{}</code>中的代码片段执行一次，保证宏展开时这个代码片段是一个整体</p>
<h2 id="自旋锁">自旋锁</h2>
<p>Linux自旋锁有多种实现，下面介绍两种</p>
<h3 id="原始自旋锁">原始自旋锁</h3>
<p>数据结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock</span><span class="p">;</span> 
<span class="p">}</span> <span class="n">spinlock_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="cp">#define spin_unlock_string \  
</span><span class="cp"></span>    <span class="s">&#34;movb $1,%0&#34;</span> <span class="err">\</span> <span class="c1">//写入1表示解锁
</span><span class="c1"></span>    <span class="o">:</span><span class="s">&#34;=m&#34;</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&#34;memory&#34;</span>

<span class="cp">#define spin_lock_string \
</span><span class="cp">  &#34;\n1:\t&#34; \  
</span><span class="cp"></span>    <span class="s">&#34;lock ; decb %0</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="err">\</span> <span class="c1">//原子减1
</span><span class="c1"></span>  <span class="s">&#34;js 2f</span><span class="se">\n</span><span class="s">&#34;</span> <span class="err">\</span>    <span class="c1">//当结果小于0则跳转到标号2处，表示加锁失败
</span><span class="c1"></span>    <span class="s">&#34;.section .text.lock,</span><span class="se">\&#34;</span><span class="s">ax</span><span class="se">\&#34;\n</span><span class="s">&#34;</span> <span class="err">\</span> <span class="c1">//重新定义一个代码段，这是优化技术，避免后面的代码填充cache，因为大部分情况会加锁成功，链接器会处理好这个代码段的
</span><span class="c1"></span>  <span class="s">&#34;2:</span><span class="se">\t</span><span class="s">&#34;</span> <span class="err">\</span>  
    <span class="s">&#34;cmpb $0,%0</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="err">\</span>  <span class="c1">//和0比较
</span><span class="c1"></span>    <span class="s">&#34;rep;nop</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="err">\</span>  <span class="c1">//空指令
</span><span class="c1"></span>    <span class="s">&#34;jle 2b</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="err">\</span>   <span class="c1">//小于或等于0跳转到标号2
</span><span class="c1"></span>    <span class="s">&#34;jmp 1b</span><span class="se">\n</span><span class="s">&#34;</span> <span class="err">\</span>   <span class="c1">//跳转到标号1  
</span><span class="c1"></span>    <span class="s">&#34;.previous&#34;</span>
<span class="c1">//获取自旋锁
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">spin_lock</span><span class="p">(</span><span class="n">spinlock_t</span><span class="o">*</span><span class="n">lock</span><span class="p">){</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
    <span class="nl">spin_lock_string</span>
    <span class="p">:</span><span class="s">&#34;=m&#34;</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span><span class="o">::</span><span class="s">&#34;memory&#34;</span>
    <span class="p">);</span>
<span class="p">}</span>
<span class="c1">//释放自旋锁
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">spin_unlock</span><span class="p">(</span><span class="n">spinlock_t</span><span class="o">*</span><span class="n">lock</span><span class="p">){</span>
<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
    <span class="n">spin_unlock_string</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>spin_unlock_string</code>只是简单将锁值设置为1，表示释放自旋锁</p>
<p><code>spin_lock_string</code>使用了<code>decb</code>原子减一指令，如果结果为0表示加锁成功；否则
进入循环比较</p>
<p>当有多个进程同时等在自旋锁时，后续获取锁的进程是不确定的，
取决于内存总线协议决定哪个CPU核心可以访问内存</p>
<h3 id="排队自旋锁">排队自旋锁</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="c1">//RAW层的自旋锁数据结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">raw_spinlock</span><span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slock</span><span class="p">;</span><span class="c1">//真正的锁值变量
</span><span class="c1"></span><span class="p">}</span><span class="n">raw_spinlock_t</span><span class="p">;</span>
<span class="c1">//最上层的自旋锁数据结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">spinlock</span><span class="p">{</span>
    <span class="k">struct</span> <span class="n">raw_spinlock</span> <span class="n">rlock</span><span class="p">;</span>
<span class="p">}</span><span class="n">spinlock_t</span><span class="p">;</span>
<span class="c1">//Linux没有这样的结构，这只是为了描述方便
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">raw_spinlock</span><span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slock</span><span class="p">;</span><span class="c1">//真正的锁值变量
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span><span class="n">raw_spinlock_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>slock域被分为两部分，分别保存锁持有者owner（低16位）和未来锁申请者next（高16位）的序号</p>
<p>只有next域和owner域相等时，才表示处于未使用的状态</p>
<p>slock初始值为0，即next和owner被置为0</p>
<p>进程申请自旋锁时，将next域加1，并将原值作为自己的序号</p>
<p>如果序号等于申请时的owner的值，说明自旋锁处于未使用的状态，则进程直接获得锁；</p>
<p>否则，该进程循环检查owner域是否等于自己持有的序号，一旦相等则表名锁轮到自己获取</p>
<p>进程释放锁时，原子的将owner域加 1 即可，下一个进程会发现这个变化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__raw_spin_lock</span><span class="p">(</span><span class="n">raw_spinlock_t</span><span class="o">*</span><span class="n">lock</span><span class="p">){</span>
<span class="kt">int</span> <span class="n">inc</span> <span class="o">=</span> <span class="mh">0x00010000</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
<span class="s">&#34;lock ; xaddl %0, %1</span><span class="se">\n</span><span class="s">&#34;</span> <span class="c1">//将inc和slock交换，然后 inc=inc+slock
</span><span class="c1"></span>                        <span class="c1">//相当于原子读取next和owner并对next+1
</span><span class="c1"></span><span class="s">&#34;movzwl %w0, %2</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//将inc的低16位做0扩展后送tmp tmp=(u16)inc
</span><span class="c1"></span><span class="s">&#34;shrl $16, %0</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//将inc右移16位 inc=inc&gt;&gt;16
</span><span class="c1"></span><span class="s">&#34;1:</span><span class="se">\t</span><span class="s">&#34;</span>
<span class="s">&#34;cmpl %0, %2</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//比较inc和tmp，即比较next和owner 
</span><span class="c1"></span><span class="s">&#34;je 2f</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//相等则跳转到标号2处返回
</span><span class="c1"></span><span class="s">&#34;rep ; nop</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//空指令
</span><span class="c1"></span><span class="s">&#34;movzwl %1, %2</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//将slock的低16位做0扩展后送tmp 即tmp=owner
</span><span class="c1"></span><span class="s">&#34;jmp 1b</span><span class="se">\n</span><span class="s">&#34;</span> <span class="c1">//跳转到标号1处继续比较
</span><span class="c1"></span><span class="s">&#34;2:&#34;</span>
<span class="o">:</span><span class="s">&#34;+Q&#34;</span><span class="p">(</span><span class="n">inc</span><span class="p">),</span><span class="s">&#34;+m&#34;</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">),</span><span class="s">&#34;=r&#34;</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
<span class="o">::</span><span class="s">&#34;memory&#34;</span><span class="p">,</span><span class="s">&#34;cc&#34;</span>
<span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define UNLOCK_LOCK_PREFIX LOCK_PREFIX
</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__raw_spin_unlock</span><span class="p">(</span><span class="n">raw_spinlock_t</span><span class="o">*</span><span class="n">lock</span><span class="p">){</span>
<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
<span class="n">UNLOCK_LOCK_PREFIX</span><span class="s">&#34;incw %0&#34;</span><span class="c1">//将slock的低16位加1 即owner+1
</span><span class="c1"></span><span class="o">:</span><span class="s">&#34;+m&#34;</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">)</span>
<span class="o">::</span><span class="s">&#34;memory&#34;</span><span class="p">,</span><span class="s">&#34;cc&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>try_lock实现当无法立即获取自旋锁时，资源放弃</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__raw_spin_trylock</span><span class="p">(</span><span class="n">raw_spinlock_t</span><span class="o">*</span><span class="n">lock</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">new</span><span class="p">;</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span>
    <span class="s">&#34;movl %2,%0</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//tmp=slock
</span><span class="c1"></span>    <span class="s">&#34;movl %0,%1</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//new=tmp
</span><span class="c1"></span>    <span class="s">&#34;roll $16, %0</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//tmp循环左移16位，即next和owner交换了
</span><span class="c1"></span>    <span class="s">&#34;cmpl %0,%1</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//比较tmp和new即（owner、next）？=（next、owner）
</span><span class="c1"></span>    <span class="s">&#34;jne 1f</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//不等则跳转到标号1处 
</span><span class="c1"></span>    <span class="s">&#34;addl $0x00010000, %1</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//相当于next+1
</span><span class="c1"></span>    <span class="s">&#34;lock ; cmpxchgl %1,%2</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//new和slock交换比较    
</span><span class="c1"></span>    <span class="s">&#34;1:&#34;</span>
    <span class="s">&#34;sete %b1</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//new = eflags.ZF位，ZF取决于前面的判断是否相等
</span><span class="c1"></span>    <span class="s">&#34;movzbl %b1,%0</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//tmp = new
</span><span class="c1"></span>    <span class="o">:</span><span class="s">&#34;=&amp;a&#34;</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span><span class="s">&#34;=Q&#34;</span><span class="p">(</span><span class="n">new</span><span class="p">),</span><span class="s">&#34;+m&#34;</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">)</span>
    <span class="o">::</span><span class="s">&#34;memory&#34;</span><span class="p">,</span><span class="s">&#34;cc&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">__lockfunc</span> <span class="nf">_spin_trylock</span><span class="p">(</span><span class="n">spinlock_t</span><span class="o">*</span><span class="n">lock</span><span class="p">){</span> 
    <span class="n">preempt_disable</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_raw_spin_trylock</span><span class="p">(</span><span class="n">lock</span><span class="p">)){</span>
        <span class="n">spin_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">dep_map</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">_RET_IP_</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">preempt_enable</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define spin_trylock(lock) __cond_lock(lock, _spin_trylock(lock))
</span></code></pre></td></tr></table>
</div>
</div><p><code>_spin_trylock</code>返回1表示尝试加锁成功</p>
<h2 id="信号量">信号量</h2>
<p>信号量可以分为单值信号量和多值信号量</p>
<p>信号量最大的优势是即可以是申请失败的进程睡眠，又可以作为资源计数器使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">semaphore</span>
<span class="p">{</span>
    <span class="n">raw_spinlock_t</span> <span class="n">lock</span><span class="p">;</span> <span class="c1">// 保护信号量自身的自旋锁
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="c1">// 信号量值
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">wait_list</span><span class="p">;</span> <span class="c1">//挂载睡眠等待进程的链表
</span><span class="c1"></span><span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>接口函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__sched</span> <span class="nf">__down_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="kt">long</span> <span class="n">state</span><span class="p">,</span><span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">semaphore_waiter</span> <span class="n">waiter</span><span class="p">;</span>
    <span class="c1">//把waiter加入sem-&gt;wait_list的头部
</span><span class="c1"></span>    <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">);</span>
    <span class="n">waiter</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span><span class="c1">//current表示当前进程，即调用该函数的进程
</span><span class="c1"></span>    <span class="n">waiter</span><span class="p">.</span><span class="n">up</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">signal_pending_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span>
            <span class="k">goto</span> <span class="n">interrupted</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">goto</span> <span class="n">timed_out</span><span class="p">;</span>
        <span class="n">__set_current_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span><span class="c1">//设置当前进程的状态，进程睡眠，即先前__down函数中传入的TASK_UNINTERRUPTIBLE：该状态是等待资源有效时唤醒（比如等待键盘输入、socket连接、信号（signal）等等），但不可以被中断唤醒
</span><span class="c1"></span>        <span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="c1">//释放在down函数中加的锁
</span><span class="c1"></span>        <span class="n">timeout</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span><span class="c1">//真正进入睡眠
</span><span class="c1"></span>        <span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="c1">//进程下次运行会回到这里，所以要加锁
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">waiter</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
 <span class="nl">timed_out</span><span class="p">:</span>
    <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
 <span class="nl">interrupted</span><span class="p">:</span>
    <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

    <span class="c1">//为了简单起见处理进程信号（signal）和超时的逻辑代码我已经删除
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//进入睡眠等待
</span><span class="c1"></span><span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="nf">__down</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__down_common</span><span class="p">(</span><span class="n">sem</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">,</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//获取信号量
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">down</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="c1">//对信号量本身加锁并关中断，也许另一段代码也在操作该信号量
</span><span class="c1"></span>    <span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">sem</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span><span class="c1">//如果信号量值大于0,则对其减1
</span><span class="c1"></span>    <span class="k">else</span>
        <span class="n">__down</span><span class="p">(</span><span class="n">sem</span><span class="p">);</span><span class="c1">//否则让当前进程进入睡眠
</span><span class="c1"></span>    <span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//实际唤醒进程 
</span><span class="c1"></span><span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="nf">__up</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">semaphore_waiter</span> <span class="o">*</span><span class="n">waiter</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">semaphore_waiter</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
    <span class="c1">//获取信号量等待链表中的第一个数据结构semaphore_waiter，它里面保存着睡眠进程的指针
</span><span class="c1"></span>    <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
    <span class="n">waiter</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">wake_up_process</span><span class="p">(</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span><span class="c1">//唤醒进程重新加入调度队列
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//释放信号量
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">up</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="c1">//对信号量本身加锁并关中断，必须另一段代码也在操作该信号量
</span><span class="c1"></span>    <span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">)))</span>
        <span class="n">sem</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="c1">//如果信号量等待链表中为空，则对信号量值加1
</span><span class="c1"></span>    <span class="k">else</span>
        <span class="n">__up</span><span class="p">(</span><span class="n">sem</span><span class="p">);</span><span class="c1">//否则执行唤醒进程相关的操作
</span><span class="c1"></span>    <span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="读写锁">读写锁</h2>
<p>读写之间是互斥的，读写竞争锁时，写会优先得到锁</p>
<p>读写锁本质上是自旋锁的变种，是带计数的自旋锁</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="c1">//读写锁初始化锁值
</span><span class="c1"></span><span class="cp">#define RW_LOCK_BIAS     0x01000000
</span><span class="cp"></span><span class="c1">//读写锁的底层数据结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">}</span><span class="n">arch_rwlock_t</span><span class="p">;</span>
<span class="c1">//释放读锁 
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">arch_read_unlock</span><span class="p">(</span><span class="n">arch_rwlock_t</span><span class="o">*</span><span class="n">rw</span><span class="p">){</span> 
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span>
        <span class="n">LOCK_PREFIX</span><span class="s">&#34;incl %0&#34;</span> <span class="c1">//原子对lock加1
</span><span class="c1"></span>        <span class="o">:</span><span class="s">&#34;+m&#34;</span><span class="p">(</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span><span class="o">::</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//释放写锁
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">arch_write_unlock</span><span class="p">(</span><span class="n">arch_rwlock_t</span><span class="o">*</span><span class="n">rw</span><span class="p">){</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span>
        <span class="n">LOCK_PREFIX</span><span class="s">&#34;addl %1, %0&#34;</span><span class="c1">//原子对lock加上RW_LOCK_BIAS
</span><span class="c1"></span>        <span class="o">:</span><span class="s">&#34;+m&#34;</span><span class="p">(</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span><span class="o">:</span><span class="s">&#34;i&#34;</span><span class="p">(</span><span class="n">RW_LOCK_BIAS</span><span class="p">)</span><span class="o">:</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//获取写锁失败时调用
</span><span class="c1"></span><span class="n">ENTRY</span><span class="p">(</span><span class="n">__write_lock_failed</span><span class="p">)</span>
    <span class="c1">//(%eax)表示由eax指向的内存空间是调用者传进来的 
</span><span class="c1"></span>    <span class="mi">2</span><span class="o">:</span><span class="n">LOCK_PREFIX</span> <span class="n">addl</span>  <span class="err">$</span> <span class="n">RW_LOCK_BIAS</span><span class="p">,(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span>
    <span class="mi">1</span><span class="o">:</span><span class="n">rep</span><span class="p">;</span><span class="n">nop</span><span class="c1">//空指令
</span><span class="c1"></span>    <span class="n">cmpl</span> <span class="err">$</span><span class="n">RW_LOCK_BIAS</span><span class="p">,(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span>
    <span class="c1">//不等于初始值则循环比较，相等则表示有进程释放了写锁
</span><span class="c1"></span>    <span class="n">jne</span>   <span class="mi">1</span><span class="n">b</span>
    <span class="c1">//执行加写锁
</span><span class="c1"></span>    <span class="n">LOCK_PREFIX</span> <span class="n">subl</span>  <span class="err">$</span> <span class="n">RW_LOCK_BIAS</span><span class="p">,(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span>
    <span class="n">jnz</span> <span class="mi">2</span><span class="n">b</span> <span class="c1">//不为0则继续测试，为0则表示加写锁成功
</span><span class="c1"></span>    <span class="n">ret</span> <span class="c1">//返回
</span><span class="c1"></span><span class="n">ENDPROC</span><span class="p">(</span><span class="n">__write_lock_failed</span><span class="p">)</span>
<span class="c1">//获取读锁失败时调用
</span><span class="c1"></span><span class="n">ENTRY</span><span class="p">(</span><span class="n">__read_lock_failed</span><span class="p">)</span>
    <span class="c1">//(%eax)表示由eax指向的内存空间是调用者传进来的 
</span><span class="c1"></span>    <span class="mi">2</span><span class="o">:</span><span class="n">LOCK_PREFIX</span> <span class="n">incl</span><span class="p">(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span><span class="c1">//原子加1
</span><span class="c1"></span>    <span class="mi">1</span><span class="o">:</span>  <span class="n">rep</span><span class="p">;</span> <span class="n">nop</span><span class="c1">//空指令
</span><span class="c1"></span>    <span class="n">cmpl</span>  <span class="err">$</span><span class="mi">1</span><span class="p">,(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span> <span class="c1">//和1比较 小于0则
</span><span class="c1"></span>    <span class="n">js</span> <span class="mi">1</span><span class="n">b</span> <span class="c1">//为负则继续循环比较
</span><span class="c1"></span>    <span class="n">LOCK_PREFIX</span> <span class="n">decl</span><span class="p">(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span> <span class="c1">//加读锁
</span><span class="c1"></span>    <span class="n">js</span>  <span class="mi">2</span><span class="n">b</span>  <span class="c1">//为负则继续加1并比较，否则返回
</span><span class="c1"></span>    <span class="n">ret</span> <span class="c1">//返回
</span><span class="c1"></span><span class="n">ENDPROC</span><span class="p">(</span><span class="n">__read_lock_failed</span><span class="p">)</span>
<span class="c1">//获取读锁
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">arch_read_lock</span><span class="p">(</span><span class="n">arch_rwlock_t</span><span class="o">*</span><span class="n">rw</span><span class="p">){</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span>
        <span class="n">LOCK_PREFIX</span><span class="s">&#34; subl $1,(%0)</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//原子对lock减1
</span><span class="c1"></span>        <span class="s">&#34;jns 1f</span><span class="se">\n</span><span class="s">&#34;</span><span class="c1">//不为小于0则跳转标号1处，表示获取读锁成功
</span><span class="c1"></span>        <span class="s">&#34;call __read_lock_failed</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//调用__read_lock_failed
</span><span class="c1"></span>        <span class="s">&#34;1:</span><span class="se">\n</span><span class="s">&#34;</span>
        <span class="o">::</span><span class="n">LOCK_PTR_REG</span><span class="p">(</span><span class="n">rw</span><span class="p">)</span><span class="o">:</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//获取写锁
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">arch_write_lock</span><span class="p">(</span><span class="n">arch_rwlock_t</span><span class="o">*</span><span class="n">rw</span><span class="p">){</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span>
        <span class="n">LOCK_PREFIX</span><span class="s">&#34;subl %1,(%0)</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//原子对lock减去RW_LOCK_BIAS
</span><span class="c1"></span>        <span class="s">&#34;jz 1f</span><span class="se">\n</span><span class="s">&#34;</span><span class="c1">//为0则跳转标号1处
</span><span class="c1"></span>        <span class="s">&#34;call __write_lock_failed</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//调用__write_lock_failed
</span><span class="c1"></span>        <span class="s">&#34;1:</span><span class="se">\n</span><span class="s">&#34;</span>
        <span class="o">::</span><span class="n">LOCK_PTR_REG</span><span class="p">(</span><span class="n">rw</span><span class="p">),</span><span class="s">&#34;i&#34;</span><span class="p">(</span><span class="n">RW_LOCK_BIAS</span><span class="p">)</span><span class="o">:</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>计数器lock的初始值为<code>0x01000000</code></p>
<ol>
<li>
<p>获取读锁时，lock加1，判断lock的符号位是否为0（即lock是否大于0）为0则表示加锁成功；
否则表示获取读锁失败，此时调用<code>__read_lock_failed</code>，循环测试lock+1&gt;=1</p>
</li>
<li>
<p>获取写时，lock减去初始值，判断lock是否为0，如果不为0则调用<code>__write_lock_failed</code>循环测试lock+0x01000000 == 0x01000000</p>
</li>
</ol>
<h1 id="第十讲设置工作模式和环境">第十讲：设置工作模式和环境</h1>
<h2 id="内核映像文件">内核映像文件</h2>
<p><img src="/image/play_os_in_action/10_1.webp" alt="iso_file_format"></p>
<p>内核映像文件是由多个文件封装的一个文件，其中包含二级引导器的模块，内核模块，图片和文字库文件等。</p>
<p>GRUB通过上图中的4KB的GRUB头来识别映像文件，然后根据映像文件头描述符和文件头描述符的信息解析其他文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//映像文件头描述符
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_mlosrddsc</span>
<span class="p">{</span>
    <span class="n">u64_t</span> <span class="n">mdc_mgic</span><span class="p">;</span> <span class="c1">//映像文件标识
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_sfsum</span><span class="p">;</span><span class="c1">//未使用
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_sfsoff</span><span class="p">;</span><span class="c1">//未使用
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_sfeoff</span><span class="p">;</span><span class="c1">//未使用
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_sfrlsz</span><span class="p">;</span><span class="c1">//未使用
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_ldrbk_s</span><span class="p">;</span><span class="c1">//映像文件中二级引导器的开始偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_ldrbk_e</span><span class="p">;</span><span class="c1">//映像文件中二级引导器的结束偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_ldrbk_rsz</span><span class="p">;</span><span class="c1">//映像文件中二级引导器的实际大小
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_ldrbk_sum</span><span class="p">;</span><span class="c1">//映像文件中二级引导器的校验和
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_fhdbk_s</span><span class="p">;</span><span class="c1">//映像文件中文件头描述的开始偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_fhdbk_e</span><span class="p">;</span><span class="c1">//映像文件中文件头描述的结束偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_fhdbk_rsz</span><span class="p">;</span><span class="c1">//映像文件中文件头描述的实际大小
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_fhdbk_sum</span><span class="p">;</span><span class="c1">//映像文件中文件头描述的校验和
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_filbk_s</span><span class="p">;</span><span class="c1">//映像文件中文件数据的开始偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_filbk_e</span><span class="p">;</span><span class="c1">//映像文件中文件数据的结束偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_filbk_rsz</span><span class="p">;</span><span class="c1">//映像文件中文件数据的实际大小
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_filbk_sum</span><span class="p">;</span><span class="c1">//映像文件中文件数据的校验和
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_ldrcodenr</span><span class="p">;</span><span class="c1">//映像文件中二级引导器的文件头描述符的索引号
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_fhdnr</span><span class="p">;</span><span class="c1">//映像文件中文件头描述符有多少个
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_filnr</span><span class="p">;</span><span class="c1">//映像文件中文件头有多少个
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_endgic</span><span class="p">;</span><span class="c1">//映像文件结束标识
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_rv</span><span class="p">;</span><span class="c1">//映像文件版本
</span><span class="c1"></span><span class="p">}</span><span class="n">mlosrddsc_t</span><span class="p">;</span>

<span class="cp">#define FHDSC_NMAX 192 </span><span class="c1">//文件名长度
</span><span class="c1">//文件头描述符
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_fhdsc</span>
<span class="p">{</span>
    <span class="n">u64_t</span> <span class="n">fhd_type</span><span class="p">;</span><span class="c1">//文件类型
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">fhd_subtype</span><span class="p">;</span><span class="c1">//文件子类型
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">fhd_stuts</span><span class="p">;</span><span class="c1">//文件状态
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">fhd_id</span><span class="p">;</span><span class="c1">//文件id
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">fhd_intsfsoff</span><span class="p">;</span><span class="c1">//文件在映像文件位置开始偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">fhd_intsfend</span><span class="p">;</span><span class="c1">//文件在映像文件的结束偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">fhd_frealsz</span><span class="p">;</span><span class="c1">//文件实际大小
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">fhd_fsum</span><span class="p">;</span><span class="c1">//文件校验和
</span><span class="c1"></span>    <span class="kt">char</span>   <span class="n">fhd_name</span><span class="p">[</span><span class="n">FHDSC_NMAX</span><span class="p">];</span><span class="c1">//文件名
</span><span class="c1"></span><span class="p">}</span><span class="n">fhdsc_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>内核映像文件使用<code>lmoskrlimg</code>打包</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">lmoskrlimg -m k -lhf GRUB头文件 -o 映像文件 -f 输入的文件列表
-m 表示模式 只能是k内核模式
-lhf 表示后面跟上GRUB头文件
-o 表示输出的映像文件名 
-f 表示输入文件列表
<span class="c1">#例如：lmoskrlimg -m k -lhf grubhead.bin -o kernel.img -f file1.bin file2.bin file3.bin file4.bin </span>
</code></pre></td></tr></table>
</div>
</div><h2 id="准备环境">准备环境</h2>
<h3 id="安装虚拟机">安装虚拟机</h3>
<p>使用virtual box虚拟机</p>
<h3 id="准备硬盘">准备硬盘</h3>
<h4 id="生成纯二进制文件">生成纯二进制文件</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">
dd <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>hd.img <span class="nv">count</span><span class="o">=</span><span class="m">204800</span>

<span class="c1">#bs:表示块大小，这里是512字节</span>
<span class="c1">#if：表示输入文件，/dev/zero就是Linux下专门返回0数据的设备文件，读取它就返回0</span>
<span class="c1">#of：表示输出文件，即我们的硬盘文件。</span>
<span class="c1">#count：表示输出多少块</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="格式化建立文件系统">格式化（建立文件系统）</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">
<span class="c1"># 1. 将文件变成回环设备</span>
<span class="c1"># loop0可能被占用，换成其他名字即可 </span>
sudo losetup /dev/loop0 hd.img

<span class="c1"># 2. 建立文件系统</span>
sudo mkfs.ext4 -q /dev/loop0

<span class="c1"># 3. 挂载</span>
<span class="c1"># 挂载硬盘文件, 可通过 lsblk 命令验证结果</span>
sudo mount -o loop ./hd.img  ./hdisk 
 <span class="c1"># 建立boot目录</span>
sudo mkdir ./hdist/boot 
</code></pre></td></tr></table>
</div>
</div><h3 id="安装grub">安装GRUB</h3>
<ol>
<li>安装GRUB</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">
<span class="c1"># 安装GRUB</span>
sudo grub-install --boot-directory<span class="o">=</span>./hdisk/boot/ --force --allow-floppy /dev/loop0
<span class="c1"># --boot-directory 指向先前我们在虚拟硬盘中建立的boot目录。</span>
<span class="c1"># --force --allow-floppy ：指向我们的虚拟硬盘设备文件/dev/loop0</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>编写配置文件</li>
</ol>
<p>在 /hdisk/boot/grub/ 目录建立 grub.config 文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">menuentry &#39;HelloOS&#39; {
insmod part_msdos
insmod ext2
set root=&#39;hd0,msdos1&#39; #我们的硬盘只有一个分区所以是&#39;hd0,msdos1&#39;
multiboot2 /boot/HelloOS.eki #加载boot目录下的HelloOS.eki文件
boot #引导启动
}
set timeout_style=menu
if [ &#34;${timeout}&#34; = 0 ]; then
  set timeout=10 #等待10秒钟自动启动
fi
</code></pre></td></tr></table>
</div>
</div><h4 id="转成硬盘格式">转成硬盘格式</h4>
<p>将Linux识别的硬盘 转换成虚拟机识别的硬盘</p>
<p>VBoxManage是在宿主机执行，文件可通过共享文件夹传输</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">VBoxManage convertfromraw ./hd.img --format VDI ./hd.vdi
<span class="c1">#convertfromraw 指向原始格式文件</span>
<span class="c1">#--format VDI  表示转换成虚拟需要的VDI格式</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="安装虚拟硬盘">安装虚拟硬盘</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">
<span class="c1"># 第一步：配置硬盘控制器 </span>
<span class="c1"># SATA的硬盘其控制器是intelAHCI</span>
VBoxManage storagectl HelloOS --name <span class="s2">&#34;SATA&#34;</span> --add sata --controller IntelAhci --portcount <span class="m">1</span>
<span class="c1"># 第二步：挂载虚拟硬盘</span>
VBoxManage closemedium disk ./hd.vdi <span class="c1">#删除虚拟硬盘UUID并重新分配</span>
<span class="c1">#将虚拟硬盘挂到虚拟机的硬盘控制器</span>
VBoxManage storageattach HelloOS --storagectl <span class="s2">&#34;SATA&#34;</span> --port <span class="m">1</span> --device <span class="m">0</span> --type hdd --medium ./hd.vdi
</code></pre></td></tr></table>
</div>
</div><h3 id="启动">启动</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">VBoxManage startvm HelloOS <span class="c1">#启动虚拟机</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="第十一讲建造二级引导器">第十一讲：建造二级引导器</h1>
<h2 id="二级引导器作用">二级引导器作用</h2>
<p>收集机器信息，对CPU、内存、显卡等进行初级配置</p>
<h2 id="存储结构">存储结构</h2>
<p>收集的信息会存在如下的数据结构中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_MACHBSTART</span>
<span class="p">{</span>
    <span class="n">u64_t</span>   <span class="n">mb_krlinitstack</span><span class="p">;</span><span class="c1">//内核栈地址
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_krlitstacksz</span><span class="p">;</span><span class="c1">//内核栈大小
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_imgpadr</span><span class="p">;</span><span class="c1">//操作系统映像
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_imgsz</span><span class="p">;</span><span class="c1">//操作系统映像大小
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_bfontpadr</span><span class="p">;</span><span class="c1">//操作系统字体地址
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_bfontsz</span><span class="p">;</span><span class="c1">//操作系统字体大小
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_fvrmphyadr</span><span class="p">;</span><span class="c1">//机器显存地址
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_fvrmsz</span><span class="p">;</span><span class="c1">//机器显存大小
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_cpumode</span><span class="p">;</span><span class="c1">//机器CPU工作模式
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_memsz</span><span class="p">;</span><span class="c1">//机器内存大小
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_e820padr</span><span class="p">;</span><span class="c1">//机器e820数组地址
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_e820nr</span><span class="p">;</span><span class="c1">//机器e820数组元素个数
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_e820sz</span><span class="p">;</span><span class="c1">//机器e820数组大小
</span><span class="c1"></span>    <span class="c1">//……
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_pml4padr</span><span class="p">;</span><span class="c1">//机器页表数据地址
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_subpageslen</span><span class="p">;</span><span class="c1">//机器页表个数
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_kpmapphymemsz</span><span class="p">;</span><span class="c1">//操作系统映射空间大小
</span><span class="c1"></span>    <span class="c1">//……
</span><span class="c1"></span>    <span class="n">graph_t</span> <span class="n">mb_ghparm</span><span class="p">;</span><span class="c1">//图形信息
</span><span class="c1"></span><span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">machbstart_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="模块规划">模块规划</h2>
<p><img src="/image/play_os_in_action/11_1.webp" alt="modules"></p>
<p>上图的文件经过编译会生成三个文件，具体流程如下</p>
<p><img src="/image/play_os_in_action/11_2.webp" alt="compile"></p>
<p>然后用映像打包工具打包成映像文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">
lmoskrlimg -m k -lhf initldrimh.bin -o Cosmos.eki -f initldrkrl.bin initldrsve.bin
</code></pre></td></tr></table>
</div>
</div><h2 id="实现grub头">实现GRUB头</h2>
<p>GRUB头有两个文件</p>
<ul>
<li>imginithead.asm汇编文件： 让GUR识别、设置C语言环境</li>
<li>inithead.c文件：查找引导器核心文件initldrkrl,bin文件并将其放到特定的内存地址上</li>
</ul>
<h3 id="imginitheadasm">imginithead.asm</h3>
<p>主要工作是初始化CPU的 寄存器，加载GDT，切换到CPU的保护模式</p>
<p>首先是 GRUB1 和 GRUB2需要的带个头结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">MBT_HDR_FLAGS</span>  <span class="no">EQU</span> <span class="mi">0x00010003</span>
<span class="nf">MBT_HDR_MAGIC</span>  <span class="no">EQU</span> <span class="mi">0x1BADB002</span>
<span class="nf">MBT2_MAGIC</span>  <span class="no">EQU</span> <span class="mi">0xe85250d6</span>
<span class="nf">global</span> <span class="no">_start</span>
<span class="nf">extern</span> <span class="no">inithead_entry</span>
<span class="err">[</span><span class="nf">section</span> <span class="no">.text</span><span class="p">]</span>
<span class="err">[</span><span class="nf">bits</span> <span class="mi">32</span><span class="p">]</span>
<span class="nl">_start:</span>
  <span class="nf">jmp</span> <span class="no">_entry</span>
<span class="nf">align</span> <span class="mi">4</span>
<span class="nl">mbt_hdr:</span>
  <span class="nf">dd</span> <span class="no">MBT_HDR_MAGIC</span>
  <span class="nf">dd</span> <span class="no">MBT_HDR_FLAGS</span>
  <span class="nf">dd</span> <span class="p">-(</span><span class="no">MBT_HDR_MAGIC</span><span class="err">+</span><span class="no">MBT_HDR_FLAGS</span><span class="p">)</span>
  <span class="nf">dd</span> <span class="no">mbt_hdr</span>
  <span class="nf">dd</span> <span class="no">_start</span>
  <span class="nf">dd</span> <span class="mi">0</span>
  <span class="nf">dd</span> <span class="mi">0</span>
  <span class="nf">dd</span> <span class="no">_entry</span>
<span class="nf">ALIGN</span> <span class="mi">8</span>
<span class="nl">mbhdr:</span>
  <span class="nf">DD</span>  <span class="mi">0xE85250D6</span>
  <span class="nf">DD</span>  <span class="mi">0</span>
  <span class="nf">DD</span>  <span class="no">mhdrend</span> <span class="p">-</span> <span class="no">mbhdr</span>
  <span class="nf">DD</span>  <span class="p">-(</span><span class="mi">0xE85250D6</span> <span class="err">+</span> <span class="mi">0</span> <span class="err">+</span> <span class="p">(</span><span class="no">mhdrend</span> <span class="p">-</span> <span class="no">mbhdr</span><span class="p">))</span>
  <span class="nf">DW</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span>
  <span class="nf">DD</span>  <span class="mi">24</span>
  <span class="nf">DD</span>  <span class="no">mbhdr</span>
  <span class="nf">DD</span>  <span class="no">_start</span>
  <span class="nf">DD</span>  <span class="mi">0</span>
  <span class="nf">DD</span>  <span class="mi">0</span>
  <span class="nf">DW</span>  <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span>
  <span class="nf">DD</span>  <span class="mi">12</span>
  <span class="nf">DD</span>  <span class="no">_entry</span> 
  <span class="no">DD</span>  <span class="mi">0</span>  
  <span class="no">DW</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
  <span class="nf">DD</span>  <span class="mi">8</span>
<span class="nl">mhdrend:</span>
</code></pre></td></tr></table>
</div>
</div><p>关闭中断并加载GDT</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">_entry:</span>
  <span class="nf">cli</span>           <span class="err">；关中断</span>
  <span class="nf">in</span> <span class="no">al</span><span class="p">,</span> <span class="mi">0x70</span> 
  <span class="no">or</span> <span class="no">al</span><span class="p">,</span> <span class="mi">0x80</span>  
  <span class="no">out</span> <span class="mi">0x70</span><span class="p">,</span><span class="no">al</span>  <span class="err">；关掉不可屏蔽中断</span>   
  <span class="no">lgdt</span> <span class="p">[</span><span class="no">GDT_PTR</span><span class="p">]</span> <span class="err">；加载</span><span class="no">GDT地址到GDTR寄存器</span>
  <span class="nf">jmp</span> <span class="no">dword</span> <span class="mi">0x8</span> <span class="p">:</span><span class="no">_32bits_mode</span> <span class="err">；长跳转刷新</span><span class="no">CS影子寄存器</span>
  <span class="c">;………………
</span><span class="c">;GDT全局段描述符表
</span><span class="c"></span><span class="nl">GDT_START:</span>
<span class="nl">knull_dsc:</span> <span class="nf">dq</span> <span class="mi">0</span>
<span class="nl">kcode_dsc:</span> <span class="nf">dq</span> <span class="mi">0x00cf9e000000ffff</span>
<span class="nl">kdata_dsc:</span> <span class="nf">dq</span> <span class="mi">0x00cf92000000ffff</span>
<span class="nl">k16cd_dsc:</span> <span class="nf">dq</span> <span class="mi">0x00009e000000ffff</span> <span class="err">；</span><span class="mi">16</span><span class="err">位代码段描述符</span>
<span class="nl">k16da_dsc:</span> <span class="nf">dq</span> <span class="mi">0x000092000000ffff</span> <span class="err">；</span><span class="mi">16</span><span class="err">位数据段描述符</span>
<span class="nl">GDT_END:</span>
<span class="nl">GDT_PTR:</span>
<span class="nf">GDTLEN</span>  <span class="no">dw</span> <span class="no">GDT_END-GDT_START-1</span>  <span class="c">;GDT界限
</span><span class="c"></span><span class="no">GDTBASE</span>  <span class="no">dd</span> <span class="no">GDT_ST</span>  
</code></pre></td></tr></table>
</div>
</div><p>初始化段寄存器、通用寄存器和栈寄存器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm">
<span class="nf">_32bits_mode</span><span class="err">：</span>
  <span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span> <span class="mi">0x10</span>
  <span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">ss</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">es</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">fs</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">gs</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">xor</span> <span class="no">eax</span><span class="p">,</span><span class="no">eax</span>
  <span class="nf">xor</span> <span class="no">ebx</span><span class="p">,</span><span class="no">ebx</span>
  <span class="nf">xor</span> <span class="no">ecx</span><span class="p">,</span><span class="no">ecx</span>
  <span class="nf">xor</span> <span class="no">edx</span><span class="p">,</span><span class="no">edx</span>
  <span class="nf">xor</span> <span class="no">edi</span><span class="p">,</span><span class="no">edi</span>
  <span class="nf">xor</span> <span class="no">esi</span><span class="p">,</span><span class="no">esi</span>
  <span class="nf">xor</span> <span class="no">ebp</span><span class="p">,</span><span class="no">ebp</span>
  <span class="nf">xor</span> <span class="no">esp</span><span class="p">,</span><span class="no">esp</span>
  <span class="nf">mov</span> <span class="no">esp</span><span class="p">,</span><span class="mi">0x7c00</span> <span class="err">；设置栈顶为</span><span class="mi">0x7c00</span>
  <span class="nf">call</span> <span class="no">inithead_entry</span> <span class="err">；调用</span><span class="no">inithead_entry函数在inithead.c中实现</span>
  <span class="nf">jmp</span> <span class="mi">0x200000</span>  <span class="err">；跳转到</span><span class="mi">0x200000</span><span class="err">地址</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码最后调用了 inithead_entry 函数</p>
<p>inithead_entry分别调用了<code>write_realintsvefile</code>和<code>write_ldrkrlfile</code>，
将映像文件中的initldrsve.bin文件和initldrkrl.bin文件写入到特定的内存中
其中有两个依赖函数<code>find_file</code> 和<code>m2mcopy</code>
find_file函数负责扫描映像文件中的文件头描述符，对比其中的文件名，
然后返回对应的文件的文件头描述符地址，这样就可以得到其位置和大小</p>
<p>m2mcopy函数 负责将 映像文件复制到具体的内存空间中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="cp">#define MDC_ENDGIC 0xaaffaaffaaffaaff
</span><span class="cp">#define MDC_RVGIC 0xffaaffaaffaaffaa
</span><span class="cp">#define REALDRV_PHYADR 0x1000
</span><span class="cp">#define IMGFILE_PHYADR 0x4000000
</span><span class="cp">#define IMGKRNL_PHYADR 0x2000000
</span><span class="cp">#define LDRFILEADR IMGFILE_PHYADR
</span><span class="cp">#define MLOSDSC_OFF (0x1000)
</span><span class="cp">#define MRDDSC_ADR (mlosrddsc_t*)(LDRFILEADR+0x1000)
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">inithead_entry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">write_realintsvefile</span><span class="p">();</span>
    <span class="n">write_ldrkrlfile</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//写initldrsve.bin文件到特定的内存中
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">write_realintsvefile</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">fhdsc_t</span> <span class="o">*</span><span class="n">fhdscstart</span> <span class="o">=</span> <span class="n">find_file</span><span class="p">(</span><span class="s">&#34;initldrsve.bin&#34;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fhdscstart</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#34;not file initldrsve.bin&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">m2mcopy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32_t</span><span class="p">)(</span><span class="n">fhdscstart</span><span class="o">-&gt;</span><span class="n">fhd_intsfsoff</span><span class="p">)</span> <span class="o">+</span> <span class="n">LDRFILEADR</span><span class="p">),</span>
            <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">REALDRV_PHYADR</span><span class="p">,</span> <span class="p">(</span><span class="n">sint_t</span><span class="p">)</span><span class="n">fhdscstart</span><span class="o">-&gt;</span><span class="n">fhd_frealsz</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//写initldrkrl.bin文件到特定的内存中
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">write_ldrkrlfile</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">fhdsc_t</span> <span class="o">*</span><span class="n">fhdscstart</span> <span class="o">=</span> <span class="n">find_file</span><span class="p">(</span><span class="s">&#34;initldrkrl.bin&#34;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fhdscstart</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#34;not file initldrkrl.bin&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">m2mcopy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32_t</span><span class="p">)(</span><span class="n">fhdscstart</span><span class="o">-&gt;</span><span class="n">fhd_intsfsoff</span><span class="p">)</span> <span class="o">+</span> <span class="n">LDRFILEADR</span><span class="p">),</span>
            <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ILDRKRL_PHYADR</span><span class="p">,</span> <span class="p">(</span><span class="n">sint_t</span><span class="p">)</span><span class="n">fhdscstart</span><span class="o">-&gt;</span><span class="n">fhd_frealsz</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//在映像文件中查找对应的文件
</span><span class="c1"></span><span class="n">fhdsc_t</span> <span class="o">*</span><span class="nf">find_file</span><span class="p">(</span><span class="n">char_t</span> <span class="o">*</span><span class="n">fname</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">mlosrddsc_t</span> <span class="o">*</span><span class="n">mrddadrs</span> <span class="o">=</span> <span class="n">MRDDSC_ADR</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mrddadrs</span><span class="o">-&gt;</span><span class="n">mdc_endgic</span> <span class="o">!=</span> <span class="n">MDC_ENDGIC</span> <span class="o">||</span>
        <span class="n">mrddadrs</span><span class="o">-&gt;</span><span class="n">mdc_rv</span> <span class="o">!=</span> <span class="n">MDC_RVGIC</span> <span class="o">||</span>
        <span class="n">mrddadrs</span><span class="o">-&gt;</span><span class="n">mdc_fhdnr</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span>
        <span class="n">mrddadrs</span><span class="o">-&gt;</span><span class="n">mdc_filnr</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#34;no mrddsc&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">s64_t</span> <span class="n">rethn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">fhdsc_t</span> <span class="o">*</span><span class="n">fhdscstart</span> <span class="o">=</span> <span class="p">(</span><span class="n">fhdsc_t</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32_t</span><span class="p">)(</span><span class="n">mrddadrs</span><span class="o">-&gt;</span><span class="n">mdc_fhdbk_s</span><span class="p">)</span> <span class="o">+</span> <span class="n">LDRFILEADR</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mrddadrs</span><span class="o">-&gt;</span><span class="n">mdc_fhdnr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmpl</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fhdscstart</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fhd_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">rethn</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64_t</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">ok_l</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">rethn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="nl">ok_l</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rethn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#34;not find file&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">fhdscstart</span><span class="p">[</span><span class="n">rethn</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="进入二级引导器">进入二级引导器</h2>
<p><code>imginithead.asm</code>最后的指令<code>jump 0x200000</code>跳转到了物理内存地址0x200000地址处
这个地址放置的正是<code>initldrkrk.bin</code>文件
这一跳进入了二级引导器的主模块</p>
<p>由于模块的 改变，需要写一小段汇编代码，建立下面这个<code>initldr32.asm</code>文件</p>
<p>重新把GDT（段描述符表）、IDT（中断选择子表）和寄存器重新初始化，然后调用二级引导器的主函数<code>ldrkrl_entry</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm">
<span class="nl">_entry:</span>
  <span class="nf">cli</span>
  <span class="nf">lgdt</span> <span class="p">[</span><span class="no">GDT_PTR</span><span class="p">]</span><span class="err">；加载</span><span class="no">GDT地址到GDTR寄存器</span>
  <span class="nf">lidt</span> <span class="p">[</span><span class="no">IDT_PTR</span><span class="p">]</span><span class="err">；加载</span><span class="no">IDT地址到IDTR寄存器</span>
  <span class="nf">jmp</span> <span class="no">dword</span> <span class="mi">0x8</span> <span class="p">:</span><span class="no">_32bits_mode</span><span class="err">；长跳转刷新</span><span class="no">CS影子寄存器</span>
<span class="nl">_32bits_mode:</span>
  <span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span> <span class="mi">0x10</span>  <span class="c">; 数据段选择子(目的)
</span><span class="c"></span>  <span class="no">mov</span> <span class="no">ds</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">ss</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">es</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">fs</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">gs</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">xor</span> <span class="no">eax</span><span class="p">,</span><span class="no">eax</span>
  <span class="nf">xor</span> <span class="no">ebx</span><span class="p">,</span><span class="no">ebx</span>
  <span class="nf">xor</span> <span class="no">ecx</span><span class="p">,</span><span class="no">ecx</span>
  <span class="nf">xor</span> <span class="no">edx</span><span class="p">,</span><span class="no">edx</span>
  <span class="nf">xor</span> <span class="no">edi</span><span class="p">,</span><span class="no">edi</span>
  <span class="nf">xor</span> <span class="no">esi</span><span class="p">,</span><span class="no">esi</span>
  <span class="nf">xor</span> <span class="no">ebp</span><span class="p">,</span><span class="no">ebp</span>
  <span class="nf">xor</span> <span class="no">esp</span><span class="p">,</span><span class="no">esp</span>
  <span class="nf">mov</span> <span class="no">esp</span><span class="p">,</span><span class="mi">0x90000</span> <span class="err">；使得栈底指向了</span><span class="mi">0x90000</span>
  <span class="nf">call</span> <span class="no">ldrkrl_entry</span> <span class="err">；调用</span><span class="no">ldrkrl_entry函数</span>
  <span class="nf">xor</span> <span class="no">ebx</span><span class="p">,</span><span class="no">ebx</span>
  <span class="nf">jmp</span> <span class="mi">0x2000000</span> <span class="err">；跳转到</span><span class="mi">0x2000000</span><span class="err">的内存地址</span>
  <span class="nf">jmp</span> <span class="no">$</span>
<span class="nl">GDT_START:</span>
<span class="nl">knull_dsc:</span> <span class="nf">dq</span> <span class="mi">0</span>
<span class="nl">kcode_dsc:</span> <span class="nf">dq</span> <span class="mi">0x00cf9a000000ffff</span> <span class="c">;a-e
</span><span class="c"></span><span class="no">kdata_dsc</span><span class="p">:</span> <span class="no">dq</span> <span class="mi">0x00cf92000000ffff</span>
<span class="nl">k16cd_dsc:</span> <span class="nf">dq</span> <span class="mi">0x00009a000000ffff</span> <span class="err">；</span><span class="mi">16</span><span class="err">位代码段描述符</span>
<span class="nl">k16da_dsc:</span> <span class="nf">dq</span> <span class="mi">0x000092000000ffff</span> <span class="err">；</span><span class="mi">16</span><span class="err">位数据段描述符</span>
<span class="nl">GDT_END:</span>
<span class="nl">GDT_PTR:</span>
<span class="nf">GDTLEN</span>  <span class="no">dw</span> <span class="no">GDT_END-GDT_START-1</span>  <span class="c">;GDT界限
</span><span class="c"></span><span class="no">GDTBASE</span>  <span class="no">dd</span> <span class="no">GDT_START</span>

<span class="nl">IDT_PTR:</span>
<span class="nf">IDTLEN</span>  <span class="no">dw</span> <span class="mi">0x3ff</span>
<span class="nf">IDTBAS</span>  <span class="no">dd</span> <span class="mi">0</span>  <span class="err">；这是</span><span class="no">BIOS中断表的地址和长度</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="调用bios中断">调用BIOS中断</h2>
<p>因为获取内存布局信息、设置显卡图像 模式等功能需要依赖BIOS的中断服务</p>
<p>可是BIOS中断工作在16位实模式，所以需要上下文切换，大体流程如下：</p>
<ol>
<li>保存C语言环境下的 CPU上线文，即保护模式下的所有通用寄存器、段寄存器、程序指针寄存器和栈寄存器</li>
<li>切换到实模式，调用BIOS中断，把中断结果保存在内存中</li>
<li>切换回保护模式，加载之前保存的寄存器</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm">
<span class="nl">realadr_call_entry:</span>
  <span class="nf">pushad</span>     <span class="c">;保存通用寄存器
</span><span class="c"></span>  <span class="no">push</span>    <span class="no">ds</span>
  <span class="nf">push</span>    <span class="no">es</span>
  <span class="nf">push</span>    <span class="no">fs</span> <span class="c">;保存4个段寄存器
</span><span class="c"></span>  <span class="no">push</span>    <span class="no">gs</span>
  <span class="nf">call</span> <span class="no">save_eip_jmp</span> <span class="err">；调用</span><span class="no">save_eip_jmp</span> 
  <span class="no">pop</span>  <span class="no">gs</span>
  <span class="nf">pop</span>  <span class="no">fs</span>
  <span class="nf">pop</span>  <span class="no">es</span>      <span class="c">;恢复4个段寄存器
</span><span class="c"></span>  <span class="no">pop</span>  <span class="no">ds</span>
  <span class="nf">popad</span>       <span class="c">;恢复通用寄存器
</span><span class="c"></span>  <span class="no">ret</span>
<span class="nl">save_eip_jmp:</span>
  <span class="nf">pop</span> <span class="no">esi</span>  <span class="err">；弹出</span><span class="no">call</span> <span class="no">save_eip_jmp时保存的eip到esi寄存器中</span><span class="err">，</span> 
  <span class="no">mov</span> <span class="p">[</span><span class="no">PM32_EIP_OFF</span><span class="p">],</span><span class="no">esi</span> <span class="err">；把</span><span class="no">eip保存到特定的内存空间中</span>
  <span class="nf">mov</span> <span class="p">[</span><span class="no">PM32_ESP_OFF</span><span class="p">],</span><span class="no">esp</span> <span class="err">；把</span><span class="no">esp保存到特定的内存空间中</span>
  <span class="nf">jmp</span> <span class="no">dword</span> <span class="no">far</span> <span class="p">[</span><span class="no">cpmty_mode</span><span class="p">]</span><span class="err">；长跳转这里表示把</span><span class="no">cpmty_mode处的第一个4字节装入eip</span><span class="err">，把其后的</span><span class="mi">2</span><span class="err">字节装入</span><span class="no">cs</span>
<span class="nl">cpmty_mode:</span>
  <span class="nf">dd</span> <span class="mi">0x1000</span>
  <span class="nf">dw</span> <span class="mi">0x18</span>
  <span class="nf">jmp</span> <span class="no">$</span>
</code></pre></td></tr></table>
</div>
</div><p><code>jmp dword far [cpmty_mode]</code>指令表示把 [cpmty_mode] 处的数据装入 CS: EIP，
即把 0x18: 0x1000 装入  CS: EIP 中，
0x18 是段描述索引，指向GDT中的 16 位代码段描述符，
0x10000 表示段内地址偏移</p>
<p>这个地址起始的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm">
<span class="err">[</span><span class="nf">bits</span> <span class="mi">16</span><span class="p">]</span>
<span class="nl">_start:</span>
<span class="nl">_16_mode:</span>
  <span class="nf">mov</span>  <span class="no">bp</span><span class="p">,</span><span class="mi">0x20</span> <span class="c">;0x20是指向GDT中的16位数据段描述符 
</span><span class="c"></span>  <span class="no">mov</span>  <span class="no">ds</span><span class="p">,</span> <span class="no">bp</span>
  <span class="nf">mov</span>  <span class="no">es</span><span class="p">,</span> <span class="no">bp</span>
  <span class="nf">mov</span>  <span class="no">ss</span><span class="p">,</span> <span class="no">bp</span>
  <span class="nf">mov</span>  <span class="no">ebp</span><span class="p">,</span> <span class="no">cr0</span>
  <span class="nf">and</span>  <span class="no">ebp</span><span class="p">,</span> <span class="mi">0xfffffffe</span>
  <span class="nf">mov</span>  <span class="no">cr0</span><span class="p">,</span> <span class="no">ebp</span> <span class="err">；</span><span class="no">CR0.P</span><span class="err">=</span><span class="mi">0</span> <span class="err">关闭保护模式</span>
  <span class="nf">jmp</span>  <span class="mi">0</span><span class="p">:</span><span class="no">real_entry</span> <span class="err">；刷新</span><span class="no">CS影子寄存器</span><span class="err">，真正进入实模式</span>
<span class="nl">real_entry:</span>
  <span class="nf">mov</span> <span class="no">bp</span><span class="p">,</span> <span class="no">cs</span>
  <span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span> <span class="no">bp</span>
  <span class="nf">mov</span> <span class="no">es</span><span class="p">,</span> <span class="no">bp</span>
  <span class="nf">mov</span> <span class="no">ss</span><span class="p">,</span> <span class="no">bp</span> <span class="err">；重新设置实模式下的段寄存器</span> <span class="err">都是</span><span class="no">CS中值</span><span class="err">，即为</span><span class="mi">0</span> 
  <span class="no">mov</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">08000</span><span class="no">h</span> <span class="err">；设置栈</span>
  <span class="nf">mov</span> <span class="no">bp</span><span class="p">,</span><span class="no">func_table</span>
  <span class="nf">add</span> <span class="no">bp</span><span class="p">,</span><span class="no">ax</span>
  <span class="nf">call</span> <span class="p">[</span><span class="no">bp</span><span class="p">]</span> <span class="err">；调用函数表中的汇编函数，</span><span class="no">ax是C函数中传递进来的</span>
  <span class="nf">cli</span>
  <span class="nf">call</span> <span class="no">disable_nmi</span>
  <span class="nf">mov</span>  <span class="no">ebp</span><span class="p">,</span> <span class="no">cr0</span>
  <span class="nf">or</span>  <span class="no">ebp</span><span class="p">,</span> <span class="mi">1</span>
  <span class="nf">mov</span>  <span class="no">cr0</span><span class="p">,</span> <span class="no">ebp</span> <span class="err">；</span><span class="no">CR0.P</span><span class="err">=</span><span class="mi">1</span> <span class="err">开启保护模式</span>
  <span class="nf">jmp</span> <span class="no">dword</span> <span class="mi">0x8</span> <span class="p">:</span><span class="no">_32bits_mode</span>
<span class="err">[</span><span class="nf">BITS</span> <span class="mi">32</span><span class="p">]</span>
<span class="nl">_32bits_mode:</span>
  <span class="nf">mov</span> <span class="no">bp</span><span class="p">,</span> <span class="mi">0x10</span>
  <span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span> <span class="no">bp</span>
  <span class="nf">mov</span> <span class="no">ss</span><span class="p">,</span> <span class="no">bp</span><span class="err">；重新设置保护模式下的段寄存器</span><span class="mi">0x10</span><span class="err">是</span><span class="mi">32</span><span class="err">位数据段描述符的索引</span>
  <span class="nf">mov</span> <span class="no">esi</span><span class="p">,[</span><span class="no">PM32_EIP_OFF</span><span class="p">]</span><span class="err">；加载先前保存的</span><span class="no">EIP</span>
  <span class="nf">mov</span> <span class="no">esp</span><span class="p">,[</span><span class="no">PM32_ESP_OFF</span><span class="p">]</span><span class="err">；加载先前保存的</span><span class="no">ESP</span>
  <span class="nf">jmp</span> <span class="no">esi</span> <span class="err">；</span><span class="no">eip</span><span class="err">=</span><span class="no">esi</span> <span class="err">回到了</span><span class="no">realadr_call_entry函数中</span>

<span class="nl">func_table:</span>  <span class="c">;函数表
</span><span class="c"></span>  <span class="nf">dw</span> <span class="no">_getmmap</span> <span class="err">；获取内存布局视图的函数</span>
  <span class="nf">dw</span> <span class="no">_read</span> <span class="err">；读取硬盘的函数</span>
    <span class="nf">dw</span> <span class="no">_getvbemode</span> <span class="err">；获取显卡</span><span class="no">VBE模式</span> 
    <span class="no">dw</span> <span class="no">_getvbeonemodeinfo</span> <span class="err">；获取显卡</span><span class="no">VBE模式的数据</span>
    <span class="nf">dw</span> <span class="no">_setvbemode</span> <span class="err">；设置显卡</span><span class="no">VBE模式</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的代码将其编译成16位的二进制文件，然后放在0x10000开始的内存空间
代码流程如下：</p>
<ol>
<li>从<code>_16_mode</code>进入实模式</li>
<li>在<code>real_entry</code>根据ax寄存器的值找到函数表对应的函数，执行完后再次进入保护模式</li>
<li>加载EIP和ESP寄存器，从而回到<code>realadr_call_entry</code>函数</li>
</ol>
<h2 id="引导器主函数">引导器主函数</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">ldrkrl_entry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">init_bstartparm</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>ldrkrl_entry</code>函数在<code>initldr32.asm</code>文件中被调用</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://stackoverflow.com/questions/37146637/why-is-interrupt-disabled-between-spin-lock-and-spin-unlock-in-linux">why-is-interrupt-disabled-between-spin-lock-and-spin-unlock-in-linux</a></li>
<li><a href="https://blog.csdn.net/ll15982534415/article/details/118771286">快速建立hdi文件</a></li>
</ul>

    </div>

    
    


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://ppd0705.github.io/tags/c/">C</a>
          <a href="https://ppd0705.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/spot_perpetual_arbitrage/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">期现套利策略介绍和实现</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/getting_started_with_pencil_sketch/">
            <span class="next-text nav-default">[笔记]零基础素描入门</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "ppd0705/ppd0705.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="ppd0705@icloud.com" rel="me noopener" class="iconfont"
      title="email"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://twitter.com/ppd0705" rel="me noopener" class="iconfont"
      title="twitter"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1264 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M1229.8616 18.043658c0 0-117.852626 63.135335-164.151872 67.344358-105.225559-164.151872-505.082682-92.598492-437.738325 223.078185C278.622548 312.675223 89.216542 47.506814 89.216542 47.506814s-117.852626 189.406006 75.762402 345.139833C127.097743 396.85567 55.544363 371.601535 55.544363 371.601535S26.081207 535.753407 253.368414 615.724832c-21.045112 29.463156-113.643603 8.418045-113.643603 8.418045s25.254134 143.10676 231.496229 180.987961c-143.10676 130.479693-387.230056 92.598492-370.393967 105.225559 206.242095 189.406006 1119.599946 231.496229 1128.01799-643.98042C1179.353331 249.539887 1263.533778 123.269217 1263.533778 123.269217s-130.479693 37.881201-138.897738 33.672179C1225.652577 98.015083 1229.8616 18.043658 1229.8616 18.043658"></path>
</svg>

    </a>
  
    <a href="https://github.com/ppd0705" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>
  
    <a href="https://www.douban.com/people/ppd0705/" rel="me noopener" class="iconfont"
      title="douban"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M926.917973 37.80608C959.65184 37.80608 986.19392 64.34816 986.19392 97.082027L986.19392 926.917973C986.19392 959.65184 959.65184 986.19392 926.917973 986.19392L97.082027 986.19392C64.34816 986.19392 37.80608 959.65184 37.80608 926.917973L37.80608 97.082027C37.80608 64.34816 64.34816 37.80608 97.082027 37.80608zM176.653653 176.19968 176.653653 252.678827 825.658027 252.678827 825.658027 176.19968zM217.719467 316.146347 217.719467 628.08064 273.524053 628.08064 341.292373 770.39616 157.259093 770.39616 157.259093 845.417813 842.949973 845.417813 842.949973 770.39616 654.226773 770.39616 722.899627 628.08064 783.67744 628.08064 783.67744 316.146347zM684.885333 392.891733 684.885333 553.987413 312.576 553.987413 312.576 392.891733zM570.770773 770.39616 426.653013 770.39616 359.621973 628.08064 639.443627 628.08064z"></path>
</svg>

    </a>


<a href="https://ppd0705.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2019 -
    2021
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        PPD
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
