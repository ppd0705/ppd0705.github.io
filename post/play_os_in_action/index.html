<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>[笔记]操作系统实战（更新中） - PPD&#39;s blog</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="PPD" />
  <meta name="description" content="第一讲: 程序的运行过程 程序的编译过程 预处理：加入头文件，替换宏 gcc HelloWorld.c -o HelloWorld.i 编译：包含预处理，将C程序转成成汇编程序 gcc HelloWorld.c -S -c Helloworld.s 汇编：包含预处理和汇" />

  <meta name="keywords" content="PPD, blog" />






<meta name="generator" content="Hugo 0.86.0-DEV" />


<link rel="canonical" href="https://ppd0705.github.io/post/play_os_in_action/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.b3a8813c06e6d785beba22bf8264e174fa2cb3a396b22f9ba24e2c00c18aaf7f.css" integrity="sha256-s6iBPAbm14W&#43;uiK/gmThdPoss6OWsi&#43;bok4sAMGKr38=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="[笔记]操作系统实战（更新中）" />
<meta property="og:description" content="第一讲: 程序的运行过程 程序的编译过程 预处理：加入头文件，替换宏 gcc HelloWorld.c -o HelloWorld.i 编译：包含预处理，将C程序转成成汇编程序 gcc HelloWorld.c -S -c Helloworld.s 汇编：包含预处理和汇" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ppd0705.github.io/post/play_os_in_action/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-07-30T08:06:33+08:00" />
<meta property="article:modified_time" content="2021-07-30T08:06:33+08:00" />

<meta itemprop="name" content="[笔记]操作系统实战（更新中）">
<meta itemprop="description" content="第一讲: 程序的运行过程 程序的编译过程 预处理：加入头文件，替换宏 gcc HelloWorld.c -o HelloWorld.i 编译：包含预处理，将C程序转成成汇编程序 gcc HelloWorld.c -S -c Helloworld.s 汇编：包含预处理和汇"><meta itemprop="datePublished" content="2021-07-30T08:06:33+08:00" />
<meta itemprop="dateModified" content="2021-07-30T08:06:33+08:00" />
<meta itemprop="wordCount" content="53607">
<meta itemprop="keywords" content="C,操作系统," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[笔记]操作系统实战（更新中）"/>
<meta name="twitter:description" content="第一讲: 程序的运行过程 程序的编译过程 预处理：加入头文件，替换宏 gcc HelloWorld.c -o HelloWorld.i 编译：包含预处理，将C程序转成成汇编程序 gcc HelloWorld.c -S -c Helloworld.s 汇编：包含预处理和汇"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">PPD's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/about">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      PPD's blog
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/about">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">[笔记]操作系统实战（更新中）</h1>
      
      <div class="post-meta">
        <time datetime="2021-07-30" class="post-time">
          2021-07-30
        </time>
        <div class="post-category">
            <a href="https://ppd0705.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"> 计算机 </a>
            
          </div>
        <span class="more-meta"> 53607 words </span>
          <span class="more-meta"> 107 min read </span>

        
        
          <span id="busuanzi_container_page_pv">
            | 阅读 <span id="busuanzi_value_page_pv"></span>
          </span>
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#第一讲-程序的运行过程">第一讲: 程序的运行过程</a>
      <ul>
        <li><a href="#程序的编译过程">程序的编译过程</a></li>
        <li><a href="#程序装载执行">程序装载执行</a>
          <ul>
            <li><a href="#冯诺依曼体系结构五大组件">冯诺依曼体系结构五大组件</a></li>
            <li><a href="#helloworld汇编代码解释">HelloWorld汇编代码解释</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第二讲实现一个最小内核">第二讲：实现一个最小内核</a>
      <ul>
        <li><a href="#os引导流程">OS引导流程</a></li>
        <li><a href="#引导汇编代码">引导汇编代码</a></li>
        <li><a href="#主函数">主函数</a></li>
        <li><a href="#控制计算机屏幕">控制计算机屏幕</a></li>
        <li><a href="#编译和安装">编译和安装</a>
          <ul>
            <li><a href="#编译">编译</a></li>
            <li><a href="#安装">安装</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第三讲内核结构设计">第三讲：内核结构设计</a>
      <ul>
        <li><a href="#内核功能">内核功能</a></li>
        <li><a href="#宏内核结构">宏内核结构</a></li>
        <li><a href="#微内核结构">微内核结构</a></li>
        <li><a href="#我们的选择">我们的选择</a>
          <ul>
            <li><a href="#内核接口层">内核接口层</a></li>
            <li><a href="#内核功能层">内核功能层</a></li>
            <li><a href="#内核硬件层">内核硬件层</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第四讲业界成熟内核架构">第四讲：业界成熟内核架构</a>
      <ul>
        <li><a href="#linux">Linux</a></li>
        <li><a href="#darwin">Darwin</a></li>
        <li><a href="#windows-nt">Windows NT</a></li>
        <li><a href="#评论区拾遗">评论区拾遗</a></li>
      </ul>
    </li>
    <li><a href="#第五讲执行程序的三种模式">第五讲：执行程序的三种模式</a>
      <ul>
        <li><a href="#实模式">实模式</a>
          <ul>
            <li><a href="#寄存器">寄存器</a></li>
            <li><a href="#内存">内存</a></li>
            <li><a href="#中断">中断</a></li>
          </ul>
        </li>
        <li><a href="#保护模式">保护模式</a>
          <ul>
            <li><a href="#特权级">特权级</a></li>
            <li><a href="#段描述符">段描述符</a></li>
            <li><a href="#平坦模型">平坦模型</a></li>
            <li><a href="#中断-1">中断</a></li>
            <li><a href="#切换">切换</a></li>
          </ul>
        </li>
        <li><a href="#长模式">长模式</a>
          <ul>
            <li><a href="#寄存器-1">寄存器</a></li>
            <li><a href="#段描述符-1">段描述符</a></li>
            <li><a href="#中断-2">中断</a></li>
            <li><a href="#切换-1">切换</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第六讲地址转换">第六讲：地址转换</a>
      <ul>
        <li><a href="#虚拟地址">虚拟地址</a></li>
        <li><a href="#物理地址">物理地址</a></li>
        <li><a href="#虚实转换">虚实转换</a></li>
        <li><a href="#mmu">MMU</a>
          <ul>
            <li><a href="#页表">页表</a></li>
            <li><a href="#保护模式下的分页">保护模式下的分页</a>
              <ul>
                <li><a href="#4kb页">4KB页</a></li>
                <li><a href="#4mb页">4MB页</a></li>
              </ul>
            </li>
            <li><a href="#长模式下的分页">长模式下的分页</a>
              <ul>
                <li><a href="#4kb页-1">4KB页</a></li>
                <li><a href="#2mb页">2MB页</a></li>
              </ul>
            </li>
            <li><a href="#开启mmu">开启MMU</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第七讲cache与内存">第七讲：Cache与内存</a>
      <ul>
        <li><a href="#内存-1">内存</a></li>
        <li><a href="#cache">Cache</a></li>
        <li><a href="#cache引入的问题">Cache引入的问题</a></li>
        <li><a href="#cache的mesi协议">Cache的MESI协议</a></li>
      </ul>
    </li>
    <li><a href="#第八讲锁-并发操作中如何让数据同步">第八讲：锁-并发操作中如何让数据同步</a>
      <ul>
        <li><a href="#方法一-原子操作-拿下单体变量">方法一： 原子操作， 拿下单体变量</a></li>
        <li><a href="#方法二-中断控制搞定复杂变量">方法二： 中断控制，搞定复杂变量</a></li>
        <li><a href="#方法三-自旋锁协调多核心cpu">方法三： 自旋锁，协调多核心CPU</a></li>
        <li><a href="#方法四-信号量时间管理大师">方法四： 信号量，时间管理大师</a>
          <ul>
            <li><a href="#获取信号量">获取信号量</a></li>
            <li><a href="#释放信号量">释放信号量</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第九讲-linux的并发实现">第九讲 Linux的并发实现</a>
      <ul>
        <li><a href="#原子变量">原子变量</a></li>
        <li><a href="#中断控制">中断控制</a></li>
        <li><a href="#自旋锁">自旋锁</a>
          <ul>
            <li><a href="#原始自旋锁">原始自旋锁</a></li>
            <li><a href="#排队自旋锁">排队自旋锁</a></li>
          </ul>
        </li>
        <li><a href="#信号量">信号量</a></li>
        <li><a href="#读写锁">读写锁</a></li>
      </ul>
    </li>
    <li><a href="#第十讲设置工作模式和环境">第十讲：设置工作模式和环境</a>
      <ul>
        <li><a href="#内核映像文件">内核映像文件</a></li>
        <li><a href="#准备环境">准备环境</a>
          <ul>
            <li><a href="#安装虚拟机">安装虚拟机</a></li>
            <li><a href="#准备硬盘">准备硬盘</a>
              <ul>
                <li><a href="#生成纯二进制文件">生成纯二进制文件</a></li>
                <li><a href="#格式化建立文件系统">格式化（建立文件系统）</a></li>
              </ul>
            </li>
            <li><a href="#安装grub">安装GRUB</a>
              <ul>
                <li><a href="#转成硬盘格式">转成硬盘格式</a></li>
              </ul>
            </li>
            <li><a href="#安装虚拟硬盘">安装虚拟硬盘</a></li>
            <li><a href="#启动">启动</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第十一讲建造二级引导器">第十一讲：建造二级引导器</a>
      <ul>
        <li><a href="#二级引导器作用">二级引导器作用</a></li>
        <li><a href="#存储结构">存储结构</a></li>
        <li><a href="#模块规划">模块规划</a></li>
        <li><a href="#实现grub头">实现GRUB头</a>
          <ul>
            <li><a href="#imginitheadasm">imginithead.asm</a></li>
          </ul>
        </li>
        <li><a href="#进入二级引导器">进入二级引导器</a></li>
        <li><a href="#调用bios中断">调用BIOS中断</a></li>
        <li><a href="#引导器主函数">引导器主函数</a></li>
      </ul>
    </li>
    <li><a href="#第十二讲探查和收集信息">第十二讲：探查和收集信息</a>
      <ul>
        <li><a href="#初始化">初始化</a></li>
        <li><a href="#检查cpu">检查CPU</a></li>
        <li><a href="#获取内存布局">获取内存布局</a></li>
        <li><a href="#初始化内核栈">初始化内核栈</a></li>
        <li><a href="#放置内核文件和字库文件">放置内核文件和字库文件</a></li>
        <li><a href="#建立mmu页表数据">建立MMU页表数据</a></li>
        <li><a href="#设置显卡图形模式">设置显卡图形模式</a></li>
        <li><a href="#集成">集成</a></li>
        <li><a href="#显示logo">显示Logo</a></li>
        <li><a href="#切换cpu到长模式">切换CPU到长模式</a></li>
      </ul>
    </li>
    <li><a href="#第十三讲-实现板级初始化">第十三讲 实现板级初始化</a>
      <ul>
        <li><a href="#hal层初始化">hal层初始化</a>
          <ul>
            <li><a href="#初始化平台">初始化平台</a></li>
            <li><a href="#初始化内存">初始化内存</a></li>
            <li><a href="#初始化中断">初始化中断</a></li>
            <li><a href="#初始化中断控制器">初始化中断控制器</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第十四讲-linux初始化上">第十四讲 Linux初始化（上）</a>
      <ul>
        <li><a href="#全局流程">全局流程</a></li>
        <li><a href="#从bios到grub">从BIOS到GRUB</a></li>
        <li><a href="#grub启动">GRUB启动</a></li>
        <li><a href="#详解vmlinuz文件结构">详解vmlinuz文件结构</a></li>
      </ul>
    </li>
    <li><a href="#第十五讲-linux初始化下">第十五讲 Linux初始化（下）</a></li>
    <li><a href="#第十六讲-划分土地上如何划分和组织内存">第十六讲 划分土地（上）：如何划分和组织内存</a>
      <ul>
        <li><a href="#如何表示一个页">如何表示一个页</a></li>
        <li><a href="#内存区">内存区</a>
          <ul>
            <li><a href="#硬件区">硬件区</a></li>
            <li><a href="#内核区">内核区</a></li>
            <li><a href="#应用区">应用区</a></li>
          </ul>
        </li>
        <li><a href="#组织内存页">组织内存页</a></li>
      </ul>
    </li>
    <li><a href="#第十七讲-划分土地中如何实现内存页面初始化">第十七讲 划分土地（中）：如何实现内存页面初始化</a>
      <ul>
        <li><a href="#内存页结构初始化">内存页结构初始化</a></li>
        <li><a href="#内存区结构构初始化">内存区结构构初始化</a></li>
        <li><a href="#处理内存占用">处理内存占用</a></li>
        <li><a href="#合并内存页到内存区">合并内存页到内存区</a></li>
        <li><a href="#虚实地址映射">虚实地址映射</a></li>
      </ul>
    </li>
    <li><a href="#第十八讲-划分土地下如何实现内存页的分配和释放">第十八讲 划分土地（下）：如何实现内存页的分配和释放</a>
      <ul>
        <li><a href="#内存页的分配">内存页的分配</a></li>
        <li><a href="#内存页的释放">内存页的释放</a></li>
      </ul>
    </li>
    <li><a href="#第十九讲-如何管理内存对象">第十九讲 如何管理内存对象</a></li>
    <li><a href="#第二十讲-如何表示虚拟内存">第二十讲 如何表示虚拟内存</a>
      <ul>
        <li><a href="#空间划分">空间划分</a>
          <ul>
            <li><a href="#x86">x86</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第二十一讲-如何分配和释放虚拟内存">第二十一讲 如何分配和释放虚拟内存</a></li>
    <li><a href="#第二十二讲-linux伙伴系统">第二十二讲 Linux伙伴系统</a>
      <ul>
        <li><a href="#如何表示一个页-1">如何表示一个页</a></li>
        <li><a href="#如何表示一个区">如何表示一个区</a></li>
        <li><a href="#如何表示一个内存节点">如何表示一个内存节点</a></li>
        <li><a href="#何为伙伴">何为伙伴</a></li>
        <li><a href="#页面分配流程">页面分配流程</a></li>
      </ul>
    </li>
    <li><a href="#第二十三讲-linux-slab分配内存">第二十三讲 Linux SLAB分配内存</a>
      <ul>
        <li><a href="#第一个kmem_cache">第一个kmem_cache</a></li>
        <li><a href="#管理-kmem_cache">管理 kmem_cache</a></li>
        <li><a href="#slab分配对象">SLAB分配对象</a></li>
      </ul>
    </li>
    <li><a href="#第二十四讲-什么是进程">第二十四讲 什么是进程</a>
      <ul>
        <li><a href="#进程的结构">进程的结构</a></li>
        <li><a href="#实现进程">实现进程</a>
          <ul>
            <li><a href="#如何表示一个进程">如何表示一个进程</a></li>
            <li><a href="#进程的地址空间">进程的地址空间</a></li>
            <li><a href="#进程的机器上下文">进程的机器上下文</a></li>
          </ul>
        </li>
        <li><a href="#建立进程">建立进程</a></li>
      </ul>
    </li>
    <li><a href="#第二十五讲--多进程如何调度">第二十五讲  多进程如何调度</a>
      <ul>
        <li><a href="#管理进程">管理进程</a>
          <ul>
            <li><a href="#进程的生命周期">进程的生命周期</a></li>
            <li><a href="#如何组织进程">如何组织进程</a></li>
          </ul>
        </li>
        <li><a href="#设计进程调度器">设计进程调度器</a>
          <ul>
            <li><a href="#进程调度器入口">进程调度器入口</a></li>
          </ul>
        </li>
        <li><a href="#进程切换">进程切换</a></li>
      </ul>
    </li>
    <li><a href="#第二十六讲--如何实现进程的等待与唤醒">第二十六讲  如何实现进程的等待与唤醒</a>
      <ul>
        <li><a href="#进程的等待和唤醒">进程的等待和唤醒</a>
          <ul>
            <li><a href="#等待数据结构">等待数据结构</a></li>
            <li><a href="#进程等待">进程等待</a></li>
            <li><a href="#进程唤醒">进程唤醒</a></li>
          </ul>
        </li>
        <li><a href="#空转进程">空转进程</a>
          <ul>
            <li><a href="#建立空转进程">建立空转进程</a></li>
            <li><a href="#空转进程运行">空转进程运行</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第二十七讲--linux如何实现进程和进程调度">第二十七讲  Linux如何实现进程和进程调度</a>
      <ul>
        <li><a href="#进程">进程</a>
          <ul>
            <li><a href="#进程数据结构">进程数据结构</a></li>
            <li><a href="#创建-task_struct-实例">创建 task_struct 实例</a></li>
            <li><a href="#进程地址空间">进程地址空间</a></li>
            <li><a href="#进程文件表">进程文件表</a></li>
          </ul>
        </li>
        <li><a href="#进程调度">进程调度</a>
          <ul>
            <li><a href="#进程调度实体数据结构">进程调度实体数据结构</a></li>
            <li><a href="#进程运行队列">进程运行队列</a></li>
            <li><a href="#调度实体和运行队列的关系">调度实体和运行队列的关系</a></li>
            <li><a href="#调度器类">调度器类</a></li>
            <li><a href="#cfs调度器">CFS调度器</a></li>
            <li><a href="#进程调度延迟">进程调度延迟</a></li>
            <li><a href="#虚拟时间">虚拟时间</a></li>
            <li><a href="#定时周期调度">定时周期调度</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第二十八讲--如何管理设备">第二十八讲  如何管理设备</a>
      <ul>
        <li><a href="#计算机的结构">计算机的结构</a></li>
        <li><a href="#设备分类">设备分类</a></li>
        <li><a href="#设备驱动">设备驱动</a>
          <ul>
            <li><a href="#设备">设备</a></li>
            <li><a href="#驱动程序">驱动程序</a></li>
            <li><a href="#组织设备">组织设备</a></li>
            <li><a href="#驱动程序功能">驱动程序功能</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第二十九讲--如何注册设备">第二十九讲  如何注册设备</a>
      <ul>
        <li><a href="#注册流程">注册流程</a></li>
        <li><a href="#驱动程序表">驱动程序表</a></li>
        <li><a href="#运行驱动程序">运行驱动程序</a>
          <ul>
            <li><a href="#调用驱动程序入口函数">调用驱动程序入口函数</a></li>
            <li><a href="#挂载设备到驱动上">挂载设备到驱动上</a></li>
            <li><a href="#向内核注册设备">向内核注册设备</a></li>
            <li><a href="#安装中断回调函数">安装中断回调函数</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第三十讲--如何处理内核io">第三十讲  如何处理内核I/O</a>
      <ul>
        <li><a href="#io-包">I/O 包</a></li>
        <li><a href="#发送-io-包">发送 I/O 包</a></li>
        <li><a href="#实现systick设备驱动">实现systick设备驱动</a></li>
      </ul>
    </li>
    <li><a href="#第三十一讲--linux如何获取所有设备信息">第三十一讲  Linux如何获取所有设备信息</a>
      <ul>
        <li><a href="#linux的设备信息">Linux的设备信息</a></li>
      </ul>
    </li>
    <li><a href="#第三十二讲--如何组织文件">第三十二讲  如何组织文件</a>
      <ul>
        <li><a href="#文件系统">文件系统</a>
          <ul>
            <li><a href="#文件系统设计">文件系统设计</a></li>
            <li><a href="#文件格式和存储块">文件格式和存储块</a></li>
          </ul>
        </li>
        <li><a href="#组织文件">组织文件</a>
          <ul>
            <li><a href="#文件系统数据结构">文件系统数据结构</a>
              <ul>
                <li><a href="#超级块">超级块</a></li>
                <li><a href="#位图">位图</a></li>
                <li><a href="#目录">目录</a></li>
                <li><a href="#文件管理头">文件管理头</a></li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第三十三讲--文件系统格式化">第三十三讲  文件系统格式化</a>
      <ul>
        <li><a href="#文件系统设备">文件系统设备</a></li>
        <li><a href="#建立超级块">建立超级块</a></li>
        <li><a href="#建立位图">建立位图</a></li>
        <li><a href="#建立根目录">建立根目录</a></li>
      </ul>
    </li>
    <li><a href="#第三十四讲--实现文件的六大基本操作">第三十四讲  实现文件的六大基本操作</a>
      <ul>
        <li><a href="#辅助操作">辅助操作</a>
          <ul>
            <li><a href="#操作根目录文件">操作根目录文件</a></li>
            <li><a href="#获取文件名">获取文件名</a></li>
            <li><a href="#判断文件是否存在">判断文件是否存在</a></li>
          </ul>
        </li>
        <li><a href="#文件相关操作">文件相关操作</a>
          <ul>
            <li><a href="#新建文件">新建文件</a></li>
            <li><a href="#删除文件">删除文件</a></li>
            <li><a href="#打开文件">打开文件</a></li>
            <li><a href="#读写文件">读写文件</a></li>
            <li><a href="#关闭文件">关闭文件</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#第三十五讲-linux如何管理文件">第三十五讲 Linux如何管理文件</a>
      <ul>
        <li><a href="#vfs-虚拟文件系统">VFS 虚拟文件系统</a></li>
        <li><a href="#vfs-数据结构">VFS 数据结构</a>
          <ul>
            <li><a href="#超级块结构">超级块结构</a></li>
            <li><a href="#目录结构">目录结构</a></li>
            <li><a href="#文件索引节点">文件索引节点</a></li>
            <li><a href="#实例结构">实例结构</a></li>
            <li><a href="#四大对象结构的关系">四大对象结构的关系</a></li>
          </ul>
        </li>
        <li><a href="#文件操作">文件操作</a>
          <ul>
            <li><a href="#打开文件-1">打开文件</a></li>
            <li><a href="#读写文件-1">读写文件</a></li>
            <li><a href="#关闭文件-1">关闭文件</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h1 id="第一讲-程序的运行过程">第一讲: 程序的运行过程</h1>
<h2 id="程序的编译过程">程序的编译过程</h2>
<p><img src="/image/play_os_in_action/1_1.webp" alt="compile_process"></p>
<ol>
<li>预处理：加入头文件，替换宏
<code>gcc HelloWorld.c -o HelloWorld.i</code></li>
<li>编译：包含预处理，将C程序转成成汇编程序
<code>gcc HelloWorld.c -S -c Helloworld.s</code></li>
<li>汇编：包含预处理和汇编，将汇编程序转换成可链接的二进制程序
<code>gcc HelloWorld.c -c HelloWorld.o</code></li>
<li>链接：将可链接的二进制程序和其他的库链接在一起，形成可执行的程序文件
<code>gcc HelloWorld.c -o HelloWorld</code></li>
</ol>
<h2 id="程序装载执行">程序装载执行</h2>
<h3 id="冯诺依曼体系结构五大组件">冯诺依曼体系结构五大组件</h3>
<ul>
<li>装载数据和程序的输入设备</li>
<li>记住程序和数据的存储器</li>
<li>完成数据加工的运算器</li>
<li>控制程序执行的控制器</li>
<li>显示处理结果的输出设备</li>
</ul>
<h3 id="helloworld汇编代码解释">HelloWorld汇编代码解释</h3>
<p><code> objdump -d hello_world.o</code>
<img src="/image/play_os_in_action/1_2.webp" alt="compile_code"></p>
<p>上图分为四列：</p>
<ul>
<li>第一列为地址</li>
<li>第二列为数据</li>
<li>第三列为汇编命令</li>
<li>第四列为注释</li>
</ul>
<p>将上图中代码装入计算机中，状态如下图：</p>
<p><img src="/image/play_os_in_action/1_3.webp" alt="compile_code_status"></p>
<h1 id="第二讲实现一个最小内核">第二讲：实现一个最小内核</h1>
<h2 id="os引导流程">OS引导流程</h2>
<p><img src="/image/play_os_in_action/2_1.webp" alt="os_load"></p>
<p>BIOS固件负责检测和初始化CPU、内存及主办平台，然后加载引导设备（如磁盘）的第一个扇区地址的数据
到0x7c00地址开始的内存空间，街道跳转到0x7c00处执行指令，即GRUB指导程序</p>
<h2 id="引导汇编代码">引导汇编代码</h2>
<p>C作为通用的高级语言不能直接操作特定的硬件，而且C语言的函数调用、传参都 需要栈
所以需要汇编代码来出席这些C语言的工作环境</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">;彭东 @ 2021.01.09
MBT_HDR_FLAGS EQU 0x00010003
MBT_HDR_MAGIC EQU 0x1BADB002 ;多引导协议头魔数
MBT_HDR2_MAGIC EQU 0xe85250d6 ;第二版多引导协议头魔数
global _start ;导出_start符号
extern main ;导入外部的main函数符号
[section .start.text] ;定义.start.text代码节
[bits 32] ;汇编成32位代码
_start:
jmp _entry
ALIGN 8
mbt_hdr:
dd MBT_HDR_MAGIC
dd MBT_HDR_FLAGS
dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)
dd mbt_hdr
dd _start
dd 0
dd 0
dd _entry
;以上是GRUB所需要的头
ALIGN 8
mbt2_hdr:
DD MBT_HDR2_MAGIC
DD 0
DD mbt2_hdr_end - mbt2_hdr
DD -(MBT_HDR2_MAGIC + 0 + (mbt2_hdr_end - mbt2_hdr))
DW 2, 0
DD 24
DD mbt2_hdr
DD _start
DD 0
DD 0
DW 3, 0
DD 12
DD _entry
DD 0
DW 0, 0
DD 8
mbt2_hdr_end:
;以上是GRUB2所需要的头
;包含两个头是为了同时兼容GRUB、GRUB2
ALIGN 8
_entry:
;关中断
cli
;关不可屏蔽中断
in al, 0x70
or al, 0x80
out 0x70,al
;重新加载GDT
lgdt [GDT_PTR]
jmp dword 0x8 :_32bits_mode
_32bits_mode:
;下面初始化C语言可能会用到的寄存器
mov ax, 0x10
mov ds, ax
mov ss, ax
mov es, ax
mov fs, ax
mov gs, ax
xor eax,eax
xor ebx,ebx
xor ecx,ecx
xor edx,edx
xor edi,edi
xor esi,esi
xor ebp,ebp
xor esp,esp
;初始化栈，C语言需要栈才能工作
mov esp,0x9000
;调用C语言函数main
call main
;让CPU停止执行指令
halt_step:
halt
jmp halt_step
GDT_START:
knull_dsc: dq 0
kcode_dsc: dq 0x00cf9e000000ffff
kdata_dsc: dq 0x00cf92000000ffff
k16cd_dsc: dq 0x00009e000000ffff
k16da_dsc: dq 0x000092000000ffff
GDT_END:
GDT_PTR:
GDTLEN dw GDT_END-GDT_START-1
GDTBASE dd GDT_START
</code></pre></td></tr></table>
</div>
</div><ul>
<li>1~40行：GRUB多引导协议头</li>
<li>44~52行：关掉中断，设定CPU的工作模式</li>
<li>54~73行：初始化CPU的寄存器和C语言的运行环境</li>
<li>78~87行：设置CPU工作模式所需要的数据</li>
</ul>
<h2 id="主函数">主函数</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//main.c
</span><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;vgastr.h&#34;</span><span class="cp">
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Hello OS!&#34;</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></td></tr></table>
</div>
</div><h2 id="控制计算机屏幕">控制计算机屏幕</h2>
<p>显卡有多种形式</p>
<ul>
<li>集显：集成在主办</li>
<li>核显：CPU芯片内</li>
<li>独显：独立存在，同时PCIE接口连接</li>
</ul>
<p>显卡的字符模式将屏幕分成24行，每行80个字符，把字符映射到以0xb8000开始的内存中
一个字符对应两个字节，一个字节是字符的ASCII码，另外一个字节为字符的颜色值</p>
<p><img src="/image/play_os_in_action/2_2.webp" alt="byte_mode"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">// vgsstr.c
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">_strwrite</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">string</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">p_string</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">oxb8000</span><span class="p">);</span> <span class="c1">//显存开始的地址
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">string</span><span class="p">)</span> 
    <span class="p">{</span>
        <span class="o">*</span><span class="n">p_string</span> <span class="o">=</span> <span class="o">*</span><span class="n">string</span><span class="o">++</span><span class="p">;</span>
        <span class="n">p_string</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">printf</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span> 
<span class="p">{</span>
    <span class="n">_strwrite</span><span class="p">(</span><span class="n">fmt</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="编译和安装">编译和安装</h2>
<h3 id="编译">编译</h3>
<p><img src="/image/play_os_in_action/2_2.webp" alt="compile_process"></p>
<h3 id="安装">安装</h3>
<p>上述编译流程会得到HelloOS.bin文件，但序言GRUB能够找到它
具体配置在grub.cfg的文件中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">menuentry &#39;HelloOS&#39; {
     insmod part_msdos #GRUB加载分区模块识别分区
     insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统
     set root=&#39;hd0,msdos4&#39; #注意boot目录挂载的分区(df /boot 查看)
     multiboot2 /boot/HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin
     boot #GRUB启动HelloOS.bin
}
</code></pre></td></tr></table>
</div>
</div><p>重启系统长按shit键然后选择HelloOS即可</p>
<h1 id="第三讲内核结构设计">第三讲：内核结构设计</h1>
<h2 id="内核功能">内核功能</h2>
<ul>
<li>管理CPU：CPU是执行程序的，而内核吧运行时的程序抽象成 进程，所以称之为进程管理</li>
<li>管理内存</li>
<li>管理硬盘</li>
<li>管理显卡</li>
<li>管理各种I/O设备</li>
</ul>
<h2 id="宏内核结构">宏内核结构</h2>
<p>宏内核就是所有诸如管理进程等功能的代码进过编译链接形成一个大的可执行程序</p>
<p>这个大程序里有实现这个功能的所有代码，向应用软件提供一些接口（即系统API）
<img src="/image/play_os_in_action/3_1.webp" alt="macro-core"></p>
<p>宏内核的优点是组件都在内核中合一相互调用性能极高；但缺点也很明显，高度耦合，没有模块化</p>
<h2 id="微内核结构">微内核结构</h2>
<p>微内核仅仅只有进程调度、处理中断、内存空间映射和进程间通信等功能</p>
<p>实际功能如进程管理、内存管理、文件管理等做成一个个服务进程</p>
<p>微内核与应用进程和服务进程通过消息通信</p>
<p>应用程序要请求相关服务，就向微内核发送一条与此服务对应的消息，微内核再把这条消息转发给相关的服务进程，接着服务进程会完成相关的服务。</p>
<h2 id="我们的选择">我们的选择</h2>
<p>大致将内核分为三个大层</p>
<ul>
<li>内核接口层</li>
<li>内核功能层</li>
<li>内核硬件层</li>
</ul>
<p><img src="/image/play_os_in_action/3_2.webp" alt="core-structure"></p>
<h3 id="内核接口层">内核接口层</h3>
<ol>
<li>定义了一套UNIX接口的子集</li>
<li>检查参数的合法性</li>
</ol>
<h3 id="内核功能层">内核功能层</h3>
<p>主要完成各种事件功能</p>
<ol>
<li>进程管理：实现进程的创建、销毁、调度</li>
<li>内存管理：内存池分为页面内存池和任意大小的内存池</li>
<li>中断管理：把中断回调函数安插在相关的数据结构中，发生相关的中断就会调用回调函数</li>
<li>设备管理：把驱动程序模块、驱动程序本身和驱动程序创建的设备组织在一起</li>
</ol>
<h3 id="内核硬件层">内核硬件层</h3>
<ol>
<li>初始化：初始化少量的设备、CPU、内存、中断的控制，内核用户管理的数据结构</li>
<li>CPU控制：提供CPU模式设定、开关中断、读写CPU特定寄存器等功能</li>
<li>中断处理：保存上下文、调用中断回调函数、操作中断控制器</li>
<li>物理内存管理：分配和释放大块内存、内存空间映射、操作MMU和Cache</li>
<li>平台其他相关功能</li>
</ol>
<h1 id="第四讲业界成熟内核架构">第四讲：业界成熟内核架构</h1>
<h2 id="linux">Linux</h2>
<p><img src="/image/play_os_in_action/4_1.webp" alt="linux-core"></p>
<p>Linux使用的宏内核架构，模块之间的通信主要是函数调用</p>
<h2 id="darwin">Darwin</h2>
<p><img src="/image/play_os_in_action/4_2.jpg" alt="macos-core"></p>
<p>Darwin有两个内核层</p>
<ul>
<li>Mach层：微内核，然提供十分简单的进程、线程、IPC 通信、虚拟内存设备驱动相关的功能服务</li>
<li>BSD层：提供强大的安全特性，完善的网络服务，各种文件系统的支持，同时对 Mach 的进程、线程、IPC、虚拟内核组件进行细化、扩展延伸</li>
</ul>
<h2 id="windows-nt">Windows NT</h2>
<p><img src="/image/play_os_in_action/4_3.jpg" alt="windows-core"></p>
<p>每个执行体互相独立，只对外提供相应的接口，其它执行体要通过内核模式可调用接口和其它执行体通信或者请求其完成相应的功能服务</p>
<h2 id="评论区拾遗">评论区拾遗</h2>
<p>内核相当于所有的功能都耦合在一起，放在内核内
微内核是把大多数功能解耦出来，放在用户态，使用IPC在用户态调用服务进程
混合结构其实与微内核相似，只不过解耦出来的这些功能依然放在内核里，动态加载和卸载</p>
<h1 id="第五讲执行程序的三种模式">第五讲：执行程序的三种模式</h1>
<p>CPU的工作模式有三种</p>
<ul>
<li>实模式</li>
<li>保护模式</li>
<li>长模式</li>
</ul>
<h2 id="实模式">实模式</h2>
<p>实模式又称实地址模式，一方面是运行真实的指令，另一方面内存地址是真实的</p>
<h3 id="寄存器">寄存器</h3>
<p>通常情况下指令的操作数就是寄存器，下图为x86 实模式下的寄存器</p>
<p><img src="/image/play_os_in_action/5_1.webp" alt="physical_register"></p>
<h3 id="内存">内存</h3>
<p>指令和数据都放在内存中，内存的地址值计算过程如下图</p>
<p><img src="/image/play_os_in_action/5_2.webp" alt="physical_memory"></p>
<p>内存地址是由段寄存器左移4位，再加上一个统统寄存器的值形成地址，然后由这个地址去访问内存
（这个即是分段内存管理模式）</p>
<p>代码段是CS和IP确定的，栈段是由SS和SP确定的</p>
<p>DOS实模式汇编代码程序实例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-AS" data-lang="AS"><span class="nx">data</span> <span class="nx">SEGMENT</span> <span class="o">;</span><span class="err">定义一个数据段存放</span><span class="nx">Hello</span> <span class="nx">World</span><span class="o">!</span>
    <span class="nx">hello</span>  <span class="nx">DB</span> <span class="s1">&#39;Hello World!$&#39;</span> <span class="o">;</span><span class="err">注意要以</span><span class="nx">$结束</span>
<span class="nx">data</span> <span class="nx">ENDS</span>
<span class="nx">code</span> <span class="nx">SEGMENT</span> <span class="o">;</span><span class="err">定义一个代码段存放程序指令</span>
    <span class="nx">ASSUME</span> <span class="nx">CS</span><span class="o">:</span><span class="nx">CODE</span><span class="o">,</span><span class="nx">DS</span><span class="o">:</span><span class="nx">DATA</span> <span class="o">;</span><span class="err">告诉汇编程序，</span><span class="nx">DS指向数据段</span><span class="err">，</span><span class="nx">CS指向代码段</span>
<span class="nx">start</span><span class="o">:</span>
    <span class="nx">MOV</span> <span class="nx">AX</span><span class="o">,</span><span class="nx">data</span>  <span class="o">;</span><span class="err">将</span><span class="nx">data段首地址赋值给AX</span>                
    <span class="nx">MOV</span> <span class="nx">DS</span><span class="o">,</span><span class="nx">AX</span>    <span class="o">;</span><span class="err">将</span><span class="nx">AX赋值给DS</span><span class="err">，使</span><span class="nx">DS指向data段</span>
    <span class="nx">LEA</span> <span class="nx">DX</span><span class="o">,</span><span class="nx">hello</span> <span class="o">;</span><span class="err">使</span><span class="nx">DX指向hello首地址</span>
    <span class="nx">MOV</span> <span class="nx">AH</span><span class="o">,</span><span class="mi">09</span><span class="nx">h</span>   <span class="o">;</span><span class="err">给</span><span class="nx">AH设置参数09H</span><span class="err">，</span><span class="nx">AH是AX高8位</span><span class="err">，</span><span class="nx">AL是AX低8位</span><span class="err">，其它类似</span>
    <span class="nx">INT</span> <span class="mi">21</span><span class="nx">h</span>      <span class="o">;</span><span class="err">执行</span><span class="nx">DOS中断输出DS指向的DX指向的字符串hello</span>
    <span class="nx">MOV</span> <span class="nx">AX</span><span class="o">,</span><span class="mi">4</span><span class="nx">C00h</span> <span class="o">;</span><span class="err">给</span><span class="nx">AH设置参数4C00h</span>
    <span class="nx">INT</span> <span class="mi">21</span><span class="nx">h</span>      <span class="o">;</span><span class="err">调用</span><span class="mi">4</span><span class="nx">C00h号功能</span><span class="err">，结束程序</span>
<span class="nx">code</span> <span class="nx">ENDS</span>
<span class="nx">END</span> <span class="nx">start</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="中断">中断</h3>
<p>中断即终止当前程序，转而跳转到另一个特定的地址上，去运行特定的代码。</p>
<p>在实模式中即：先保存CS和IP寄存器，然后装载新的CS和IP寄存器</p>
<p><img src="/image/play_os_in_action/5_3.webp" alt="interrupt-vector-table">
为了实现中断，就需要在内存中放一个中断向量表（中断信号和对应响应程序的首地址）</p>
<p>这个表的地址和长度由IDTR寄存器指向，在实模式中，一个条目由代码段地址和端内偏移组成</p>
<p>根据中断信合和IDTR寄存器的信息，CPU能够计算出中断向量的条目，进而装载CS（段基地址）、IP寄存器（段内偏移），最终响应中断</p>
<h2 id="保护模式">保护模式</h2>
<p><img src="/image/play_os_in_action/5_4.webp" alt="protected-register"></p>
<p>相比实模式，保护模式增加了一些控制寄存器和段寄存器，扩展通用寄存器的位宽</p>
<h3 id="特权级">特权级</h3>
<p><img src="/image/play_os_in_action/5_5.webp" alt="protected-privilege-level"></p>
<p>从内到外，权力逐步提升</p>
<h3 id="段描述符">段描述符</h3>
<p><img src="/image/play_os_in_action/5_6.webp" alt="protected-segment-descriptor"></p>
<p>内存是分段模型，对内存的保护可以转化成对段的保护</p>
<p>段描述符是一个64位的数据，包含了段基地址、段长度、段权限、段类型和读写状态等</p>
<p>由于信息的扩展，16位的寄存器放不下，段描述符放在内存中</p>
<p>多个段描述符在内存中形成全局段描述符表，该表的基地址和长度由GDTR寄存器指示</p>
<p><img src="/image/play_os_in_action/5_7.webp" alt="protected-segment-descriptor-table"></p>
<p>段寄存器不再放段基地址，而是段在段描述符表的索引</p>
<h3 id="平坦模型">平坦模型</h3>
<p>x86 CPU不能直接使用分页模型，通过简化设计，来时分段称为一个&quot;虚设&quot;，这个称之为保护模式的平坦模型</p>
<p>将段的基地址设为0，段长度设为0xFFFFF(2 ** 20 = 1M),段的粒度为4KB
在此模式下不同的段可以重叠、交叉和包含</p>
<h3 id="中断-1">中断</h3>
<p>保护模式需要检查权限，所以需要扩展中断向量表的信息
每个中断用一个中断门描述符来表示，格式如下</p>
<p><img src="/image/play_os_in_action/5_8.webp" alt="protected-interrupt"></p>
<p>中断向量表的条目也变成了中断门描述符
<img src="/image/play_os_in_action/5_9.webp" alt="protected-interrupt-table"></p>
<p>产生中断后</p>
<ol>
<li>检查中断号是否在有效区间（0~255）</li>
<li>检查描述符类型</li>
<li>权限检查（如果权限等级不同会进行栈切换）</li>
<li>加载目标代码偏移段到EIP寄存器</li>
</ol>
<h3 id="切换">切换</h3>
<p>由实模式切换到保护模式步骤如下：</p>
<ol>
<li>准备全局段描述符表</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">GDT_START:
knull_dsc: dq 0
kcode_dsc: dq 0x00cf9e000000ffff
kdata_dsc: dq 0x00cf92000000ffff
GDT_END:
GDT_PTR:
GDTLEN  dw GDT_END-GDT_START-1
GDTBASE  dd GDT_START
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>设置GDTR寄存器，使之指向全局段描述符表</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">lgdt [GDT_PTR]
</code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>设置CR0寄存器，开启保护模式</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">;开启 PE
mov eax, cr0
bts eax, 0                      ; CR0.PE =1
mov cr0, eax         
</code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>进行长跳转，加载CS段寄存器</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">jmp dword 0x8 :_32bits_mode ;_32bits_mode为32位代码标号即段偏移
</code></pre></td></tr></table>
</div>
</div><h2 id="长模式">长模式</h2>
<p>长模式又称AMD64，它是CPU在现有基础上有了64位的处理能力</p>
<h3 id="寄存器-1">寄存器</h3>
<p>所有通用寄存器都是64位，可以单独使用低32位，低32位可以查封成一个低16位，低16位可以拆分成两个8位寄存器</p>
<p><img src="/image/play_os_in_action/5_10.webp" alt="amd64-register"></p>
<h3 id="段描述符-1">段描述符</h3>
<p><img src="/image/play_os_in_action/5_11.webp" alt="amd64-segment-descriptor"></p>
<h3 id="中断-2">中断</h3>
<p><img src="/image/play_os_in_action/5_12.webp" alt="amd64-interrupt"></p>
<h3 id="切换-1">切换</h3>
<ol>
<li>准备长模式全局段描述符表</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">ex64_GDT:
null_dsc:  dq 0
;第一个段描述符CPU硬件规定必须为0
c64_dsc:dq 0x0020980000000000  ;64位代码段
d64_dsc:dq 0x0000920000000000  ;64位数据段
eGdtLen   equ $ - null_dsc  ;GDT长度
eGdtPtr:dw eGdtLen - 1  ;GDT界限
     dq ex64_GDT
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>准备长模式下的MMU页表</li>
</ol>
<p>长模式下内存地址空间的保护交给了 MMU，MMU 依赖页表对地址进行转换，页表有特定的格式存放在内存中，其地址由 CPU 的 CR3 寄存器指向</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">mov eax, cr4
bts eax, 5   ;CR4.PAE = 1
mov cr4, eax ;开启 PAE
mov eax, PAGE_TLB_BADR ;页表物理地址
mov cr3, eax
</code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>加载GDTR寄存器，是指指向全局段描述符</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">lgdt [eGdtPtr]
</code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>开启长模式</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">;开启 64位长模式
mov ecx, IA32_EFER
rdmsr
bts eax, 8  ;IA32_EFER.LME =1
wrmsr
;开启 保护模式和分页模式
mov eax, cr0
bts eax, 0    ;CR0.PE =1
bts eax, 31
mov cr0, eax 
</code></pre></td></tr></table>
</div>
</div><ol start="5">
<li>进行跳转，加载CS段寄存器</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">jmp 08:entry64 ;entry64为程序标号即64位偏移地址
</code></pre></td></tr></table>
</div>
</div><h1 id="第六讲地址转换">第六讲：地址转换</h1>
<h2 id="虚拟地址">虚拟地址</h2>
<p>虚拟地址由链接器产生，链接器的主要工作是吧多个代码模块组装在一起，并解决模块之间的引用
，即处理程序代码间的地址引用，形成程序运行的静态内存空间视图</p>
<h2 id="物理地址">物理地址</h2>
<p>物理地址会被地址译码器变成电信号，放在地址总线上，地址总线电子信号的各种组合就可以选择到内存的存储单元</p>
<h2 id="虚实转换">虚实转换</h2>
<p>虚实地址转换是通过MMU（内存管理单元）实现的</p>
<p><img src="/image/play_os_in_action/6_1.webp" alt="convert-virtual-address"></p>
<p>地址转换关系表本身存放在内存中，如果一个虚拟对称对应一个物理地址，转换表就会把内存耗尽</p>
<p>于是引出了分页模型，虚拟地址空间和物理地址空间都分成了同等大小的页</p>
<p><img src="/image/play_os_in_action/6_2.webp" alt="page-mode"></p>
<h2 id="mmu">MMU</h2>
<p>MMU负责接受虚拟地址值和地址关系转换表，然后输出物理地址</p>
<h3 id="页表">页表</h3>
<p>页表即虚拟页到物理页的映射关系</p>
<p>为了洁身空间，页表值存放物理页面的地址，MMU以虚拟地址为索引去查表返回物理页地址</p>
<p>页表是分级的，分为三部分</p>
<ul>
<li>一个顶级页目录</li>
<li>多个中继页目录</li>
<li>页表</li>
</ul>
<p><img src="/image/play_os_in_action/6_3.webp" alt="page-mode2"></p>
<p>一个虚拟地址从左到右分为四个位段</p>
<ul>
<li>第一个位段索引顶级页目录，得到中继页目录</li>
<li>第二个位段索引中级页目录，得到页目录</li>
<li>第三个位段索引也目录，得到物理页地址</li>
<li>第四个位段用作该物理页的偏移去访问物理内存</li>
</ul>
<h3 id="保护模式下的分页">保护模式下的分页</h3>
<p>保护模式下只有32位地址空间，32位虚拟地址经过分段机制后得到线性地址，
通常使用平坦模式，所以线性地址和虚拟地址是相同的</p>
<h4 id="4kb页">4KB页</h4>
<p>该分页方式下32位虚拟地址被分为三个位段： 页目录索引、页表索引、页内偏移</p>
<p><img src="/image/play_os_in_action/6_4.webp" alt="page-mode3"></p>
<p>CR3寄存器、页目录项和页表项都是32位，所以低12位可以另做它用，形成了页面相关属性，如
是否存在，是否可读写、是否已访问等待</p>
<p><img src="/image/play_os_in_action/6_5.jpg" alt="page-mode4">
<img src="/image/play_os_in_action/6_6.jpg" alt="page-mode5">
<img src="/image/play_os_in_action/6_7.jpg" alt="page-mode6"></p>
<h4 id="4mb页">4MB页</h4>
<p>该分页方式下，32位虚拟地址被分为2段：页表索引、页内偏移</p>
<p>共1024个条目，每个条目指向一个物理页4MB,正好为4GB地址空间</p>
<p><img src="/image/play_os_in_action/6_8.webp" alt="page-mode7"></p>
<p>CR3还是32位寄存器，指向一个4KB大小的页表，仍然要4KB地址对齐，其中包含1024个页表项</p>
<h3 id="长模式下的分页">长模式下的分页</h3>
<p>长模式下扩展为64位</p>
<h4 id="4kb页-1">4KB页</h4>
<p><img src="/image/play_os_in_action/6_9.webp" alt="long-mode1"></p>
<p>64位虚拟地址被分为6段</p>
<ul>
<li>保留位段： 24位</li>
<li>顶级页目录索引段：9位</li>
<li>页目录指针段： 9位</li>
<li>页目录段：9位</li>
<li>页表段： 9位</li>
<li>页内偏移：12位</li>
</ul>
<p>顶级页目录、页目录指针、页目录、页表都各占4KB, 各512个条目，每个条目8B即64位</p>
<p>因为x86 CPU并没有实现全64位的地址总线，而是只实现了48位，但寄存器却是64位的，
当第47位是1的时候48~63为1，反之为0</p>
<h4 id="2mb页">2MB页</h4>
<p>该方式下分为5个分段</p>
<ul>
<li>保留位段： 16位</li>
<li>顶级页目录索引：9位</li>
<li>页目录指针索引：9位</li>
<li>页目录索引：9位</li>
<li>页内偏移：21位</li>
</ul>
<p>顶级页目录、页目录指针、页目录都各占4KB, 各512个条目，每个条目8B即64位
页表项被放弃，页目录项直接指定了2MB大小的物理页面</p>
<h3 id="开启mmu">开启MMU</h3>
<ol>
<li>使CPU进入保护模式或长模式</li>
<li>准备页表数据</li>
<li>将顶级页目录的物理地址赋值给CR3寄存器</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">mov eax, PGAE_TLB_BADR ;页表物理地址
mov cr3, eax
</code></pre></td></tr></table>
</div>
</div><ol start="4">
<li>将CPU的CR0的PE为设置为0，这样就开启了 MMU</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">;开启保护模式和分页模式
mov eax, cr0
bts eax, 0    ;CR0.PE = 1
bts eax, 31   ;CR0.P = 1
mov cr0, eax
</code></pre></td></tr></table>
</div>
</div><h1 id="第七讲cache与内存">第七讲：Cache与内存</h1>
<h2 id="内存-1">内存</h2>
<p>控制内存读写和刷新的是内存控制器，内存控制器集成在北桥芯片中</p>
<p>由于制造工艺升级，现在北桥芯片被集成到了CPU芯片，这样大大提升了CPU访问内存的性能</p>
<h2 id="cache">Cache</h2>
<p>通过程序的局部性原理可以知道CPU大多数时间在访问相同或者相近的地址</p>
<p>那么可以用一块小而快的存储器放在CPU和内存之间，来缓解CPU和内存的之间的性能差距</p>
<p>这个就称之为Cache</p>
<p>Cache中存放了部分内存数据，CPU在访问内存时要先访问Cache</p>
<p>现在的x86 CPU是将Cache集成在CPU内</p>
<p><img src="/image/play_os_in_action/7_1.webp" alt="cache"></p>
<p>Cache主要由高速的静态存储器、地址转换模块和行替换模块组成</p>
<p>Cache会把存储器分成若干行，每行32字节或64字节，和内存交换数据最小单位为一行</p>
<p>为了方便管理，多个行又会组成一组</p>
<p>除了正常数据外，行中还有一些标志位，如脏位、回写位等</p>
<p>Cache的大致工作流程如下:</p>
<ol>
<li>CPU发出的地址由Cache的地址转换模块分成3段：组号、行号和行内偏移</li>
<li>Cache会根据组号、行号查找高速静态存储器中对应的行。如果找到即命中，用行内偏移读取并返回数据给CPU;
否则就分配一个新行并访问内存，把内存中对应的数据加载到Cache行并返回给CPU。
写入操作分为回写和直写，回写就是写入对应的Cache行即可，直写写入Cache行的同时会写入内存</li>
<li>如果容量不足，就要进入行替换逻辑，即找出一个Cache行写回内存，腾出空间。</li>
</ol>
<h2 id="cache引入的问题">Cache引入的问题</h2>
<p><img src="/image/play_os_in_action/7_2.webp" alt="x86_cache"></p>
<p>上图是简单的双核心CPU，有三级Cache，第一级Cache是指令和数据分开的，
第二级是独立于CPU核心的，第三级是所有CPU核心共享的。</p>
<p>Cache一致性问题主要包括以下三个：</p>
<ol>
<li>一个CPU中指令Cache和数据Cache一致性的问题</li>
<li>多个CPU各自的2级Cache一致性问题</li>
<li>3级Cache与网卡、显存等设备存储之间的一致性问题</li>
</ol>
<h2 id="cache的mesi协议">Cache的MESI协议</h2>
<p>MESI协议定义了四种基本状态</p>
<ol>
<li>
<p>Modified
当前Cache内容有效，但已和内存不一致，且不存在其他核心的Cache中</p>
</li>
<li>
<p>Exclusive
当前Cache内容有效，和内存一致，但不存在其他核心的Cache中</p>
</li>
<li>
<p>Shared</p>
</li>
</ol>
<p>当前Cache内容有效，和内存一致，且在其他核心的Cache中也一至</p>
<ol start="4">
<li>Invalid
其他情况，当前Cache无效</li>
</ol>
<h1 id="第八讲锁-并发操作中如何让数据同步">第八讲：锁-并发操作中如何让数据同步</h1>
<h2 id="方法一-原子操作-拿下单体变量">方法一： 原子操作， 拿下单体变量</h2>
<p>C语言可以嵌入汇编代码实现原子操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="c1">//定义一个原子类型
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_ATOMIC</span><span class="p">{</span>
    <span class="k">volatile</span> <span class="n">s32_t</span> <span class="n">a_count</span><span class="p">;</span> <span class="c1">//在变量前加上volatile，是为了禁止编译器优化，使其每次都从内存中加载变量
</span><span class="c1"></span><span class="p">}</span><span class="n">atomic_t</span><span class="p">;</span>
<span class="c1">//原子读
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="n">s32_t</span> <span class="nf">atomic_read</span><span class="p">(</span><span class="k">const</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>        
        <span class="c1">//x86平台取地址处是原子
</span><span class="c1"></span>        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="k">volatile</span> <span class="n">u32_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">a_count</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//原子写
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atomic_write</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">//x86平台把一个值写入一个地址处也是原子的 
</span><span class="c1"></span>        <span class="n">v</span><span class="o">-&gt;</span><span class="n">a_count</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//原子加上一个整数
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atomic_add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&#34;lock;&#34;</span> <span class="s">&#34;addl %1,%0&#34;</span>
                     <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">a_count</span><span class="p">)</span>
                     <span class="o">:</span> <span class="s">&#34;ir&#34;</span> <span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">//原子减去一个整数
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atomic_sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&#34;lock;&#34;</span> <span class="s">&#34;subl %1,%0&#34;</span>
                     <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">a_count</span><span class="p">)</span>
                     <span class="o">:</span> <span class="s">&#34;ir&#34;</span> <span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">//原子加1
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atomic_inc</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&#34;lock;&#34;</span> <span class="s">&#34;incl %0&#34;</span>
                       <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">a_count</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">//原子减1
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">atomic_dec</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
       <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&#34;lock;&#34;</span> <span class="s">&#34;decl %0&#34;</span>
                     <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">a_count</span><span class="p">));</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>加上lock前缀的addl、subl、incl、decl指令都是原子操作，lock前缀表示锁定总线，CPU能互斥使用特定的内存地址</p>
<p>代码模板以<code>__asm__ __volatile</code>开始，后面括号内容分为四个部分，以<code>:</code>分割
以<code>atomic_add</code>举例：</p>
<ol>
<li>汇编代码， <code>&quot;lock&quot;; &quot;add %1, %0&quot;</code></li>
<li>输出列表，<code>&quot;+m&quot; (v-&gt;a_count)</code>，&quot;+m&quot;表示输出和内存地址关联</li>
<li>输入列表， <code>&quot;ir&quot;</code>, &ldquo;r&quot;表示输入i和寄存器关联</li>
<li>损坏部分，告诉编译器使用了哪些寄存器，以便保存和恢复寄存器的值</li>
</ol>
<h2 id="方法二-中断控制搞定复杂变量">方法二： 中断控制，搞定复杂变量</h2>
<p>x86 使用cli、sti 指令关闭和开启中断，它们主要是对CPU的eflags寄存器的IF位（第9位）进行
清除和设置，CPU通过此位来决定是否响应中断信号</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">// 关闭中断
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">hal_cli</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&#34;cli&#34;</span><span class="o">:</span> <span class="o">:</span> <span class="o">:</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 开启中断
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">hal_sti</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">&#34;sti&#34;</span><span class="o">:</span> <span class="o">:</span> <span class="o">:</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面这种方式不支持嵌套调用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">hal_cli</span><span class="p">();</span>
    <span class="p">...</span>
    <span class="n">hal_sti</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bar</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">hal_cli</span><span class="p">();</span>
    <span class="n">foo</span><span class="p">();</span>
    <span class="p">...</span>
    <span class="n">hal_sti</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>解决方案为：</p>
<ul>
<li>关闭中断函数先保存eflags寄存器，然后执行cli指令</li>
<li>开启中断函数恢复保存的eflags寄存器的值</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="k">typedef</span> <span class="n">u32_t</span> <span class="n">cpuflg_t</span><span class="p">;</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hal_save_flags_cli</span><span class="p">(</span><span class="n">cpuflg_t</span><span class="o">*</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
     <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
            <span class="s">&#34;pushfl </span><span class="se">\t\n</span><span class="s">&#34;</span> <span class="c1">//把eflags寄存器压入当前栈顶
</span><span class="c1"></span>            <span class="s">&#34;cli    </span><span class="se">\t\n</span><span class="s">&#34;</span> <span class="c1">//关闭中断
</span><span class="c1"></span>            <span class="s">&#34;popl %0 </span><span class="se">\t\n</span><span class="s">&#34;</span><span class="c1">//把当前栈顶弹出到eflags为地址的内存中        
</span><span class="c1"></span>            <span class="o">:</span> <span class="s">&#34;=m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">)</span>
            <span class="o">:</span>
            <span class="o">:</span> <span class="s">&#34;memory&#34;</span>
          <span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">hal_restore_flags_sti</span><span class="p">(</span><span class="n">cpuflg_t</span><span class="o">*</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
              <span class="s">&#34;pushl %0 </span><span class="se">\t\n</span><span class="s">&#34;</span><span class="c1">//把flags为地址处的值寄存器压入当前栈顶
</span><span class="c1"></span>              <span class="s">&#34;popfl </span><span class="se">\t\n</span><span class="s">&#34;</span>   <span class="c1">//把当前栈顶弹出到eflags寄存器中
</span><span class="c1"></span>              <span class="o">:</span>
              <span class="o">:</span> <span class="s">&#34;m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">)</span>
              <span class="o">:</span> <span class="s">&#34;memory&#34;</span>
              <span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="方法三-自旋锁协调多核心cpu">方法三： 自旋锁，协调多核心CPU</h2>
<p>控制中断只能控制当前CPU的中断，不能控制其他CPU的中断</p>
<p>自旋锁原理如下图所示：</p>
<p><img src="/image/play_os_in_action/8_1.webp" alt="spin_lock"></p>
<p>如果需要正确执行，需要保证读取锁变量和判断并加锁的操作是原子的</p>
<p>x86 提供了一个原子交换指令<code>xchg</code>，它可以让寄存器的值和内存空间的值进行交换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//自旋锁结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
     <span class="k">volatile</span> <span class="n">u32_t</span> <span class="n">lock</span><span class="p">;</span><span class="c1">//volatile可以防止编译器优化，保证其它代码始终从内存加载lock变量的值 
</span><span class="c1"></span><span class="p">}</span> <span class="n">spinlock_t</span><span class="p">;</span>
<span class="c1">//锁初始化函数
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x86_spin_lock_init</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
     <span class="n">lock</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">//锁值初始化为0是未加锁状态
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//加锁函数
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x86_spin_lock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span> <span class="p">(</span>
    <span class="s">&#34;1: </span><span class="se">\n</span><span class="s">&#34;</span>
    <span class="s">&#34;lock; xchg  %0, %1 </span><span class="se">\n</span><span class="s">&#34;</span><span class="c1">//把值为1的寄存器和lock内存中的值进行交换
</span><span class="c1"></span>    <span class="s">&#34;cmpl   $0, %0 </span><span class="se">\n</span><span class="s">&#34;</span> <span class="c1">//用0和交换回来的值进行比较
</span><span class="c1"></span>    <span class="s">&#34;jnz    2f </span><span class="se">\n</span><span class="s">&#34;</span>  <span class="c1">//不等于0则跳转后面2标号处运行
</span><span class="c1"></span>    <span class="s">&#34;jmp 3f </span><span class="se">\n</span><span class="s">&#34;</span>     <span class="c1">//若等于0则跳转后面3标号处返回
</span><span class="c1"></span>    <span class="s">&#34;2:         </span><span class="se">\n</span><span class="s">&#34;</span> 
    <span class="s">&#34;cmpl   $0, %1  </span><span class="se">\n</span><span class="s">&#34;</span><span class="c1">//用0和lock内存中的值进行比较
</span><span class="c1"></span>    <span class="s">&#34;jne    2b      </span><span class="se">\n</span><span class="s">&#34;</span><span class="c1">//若不等于0则跳转到前面2标号处运行继续比较  
</span><span class="c1"></span>    <span class="s">&#34;jmp    1b      </span><span class="se">\n</span><span class="s">&#34;</span><span class="c1">//若等于0则跳转到前面1标号处运行，交换并加锁
</span><span class="c1"></span>    <span class="s">&#34;3:  </span><span class="se">\n</span><span class="s">&#34;</span>     
    <span class="o">:</span>
    <span class="o">:</span> <span class="s">&#34;r&#34;</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> 
    <span class="s">&#34;m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">//解锁函数
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x86_spin_unlock</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
    <span class="s">&#34;movl   $0, %0</span><span class="se">\n</span><span class="s">&#34;</span><span class="c1">//解锁把lock内存中的值设为0就行
</span><span class="c1"></span>    <span class="o">:</span>
    <span class="o">:</span> <span class="s">&#34;m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>xchg %0, %1</code>其中 <code>%0</code> 对应<code>&quot;r&quot;(1)</code>，表示编译器自动分配一个通用寄存器，并填入值1；
而 <code>%1</code>对应<code>&quot;m&quot;(*lock)</code>，表示lock是内存地址。
把1和内存的值交换，如果内存值是1，则不影响，否则已交换内存就变成了1，即加锁成功。</p>
<p>自旋锁需要在处理中断的过程中也能使用，所以需要改进</p>
<ul>
<li>获取自旋锁时先关闭中断</li>
<li>释放自旋锁后恢复</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x86_spin_lock_disable_irq</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">,</span><span class="n">cpuflg_t</span><span class="o">*</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
    <span class="s">&#34;pushfq                 </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;cli                    </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;popq %0                </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;1:         </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;lock; xchg  %1, %2 </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;cmpl   $0,%1       </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;jnz    2f      </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;jmp    3f      </span><span class="se">\n</span><span class="s">&#34;</span>  
    <span class="s">&#34;2:         </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;cmpl   $0,%2       </span><span class="se">\n\t</span><span class="s">&#34;</span> 
    <span class="s">&#34;jne    2b      </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;jmp    1b      </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;3:     </span><span class="se">\n</span><span class="s">&#34;</span>     
    <span class="o">:</span><span class="s">&#34;=m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">)</span>
    <span class="o">:</span> <span class="s">&#34;r&#34;</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s">&#34;m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">x86_spin_unlock_enabled_irq</span><span class="p">(</span><span class="n">spinlock_t</span><span class="o">*</span> <span class="n">lock</span><span class="p">,</span><span class="n">cpuflg_t</span><span class="o">*</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
    <span class="s">&#34;movl   $0, %0</span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;pushq %1 </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="s">&#34;popfq </span><span class="se">\n\t</span><span class="s">&#34;</span>
    <span class="o">:</span>
    <span class="o">:</span> <span class="s">&#34;m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">),</span> <span class="s">&#34;m&#34;</span><span class="p">(</span><span class="o">*</span><span class="n">flags</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="方法四-信号量时间管理大师">方法四： 信号量，时间管理大师</h2>
<p>信号量可以对资源进行保护，同一时刻只有一个代码执行流，又能在资源无法满足的情况下，让CPU执行其他任务</p>
<p>信号量数据结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="cp">#define SEM_FLG_MUTEX 0
</span><span class="cp">#define SEM_FLG_MULTI 1
</span><span class="cp">#define SEM_MUTEX_ONE_LOCK 1
</span><span class="cp">#define SEM_MULTI_LOCK 0
</span><span class="cp"></span><span class="c1">//等待链数据结构，用于挂载等待代码执行流（线程）的结构，里面有用于挂载代码执行流的链表和计数器变量，这里我们先不深入研究这个数据结构。
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_KWLST</span>
<span class="p">{</span>   
    <span class="n">spinlock_t</span> <span class="n">wl_lock</span><span class="p">;</span>
    <span class="n">uint_t</span>   <span class="n">wl_tdnr</span><span class="p">;</span>
    <span class="n">list_h_t</span> <span class="n">wl_list</span><span class="p">;</span>
<span class="p">}</span><span class="n">kwlst_t</span><span class="p">;</span>
<span class="c1">//信号量数据结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_SEM</span>
<span class="p">{</span>
    <span class="n">spinlock_t</span> <span class="n">sem_lock</span><span class="p">;</span><span class="c1">//维护sem_t自身数据的自旋锁
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">sem_flg</span><span class="p">;</span><span class="c1">//信号量相关的标志
</span><span class="c1"></span>    <span class="n">sint_t</span> <span class="n">sem_count</span><span class="p">;</span><span class="c1">//信号量计数值
</span><span class="c1"></span>    <span class="n">kwlst_t</span> <span class="n">sem_waitlst</span><span class="p">;</span><span class="c1">//用于挂载等待代码执行流（线程）结构
</span><span class="c1"></span><span class="p">}</span><span class="n">sem_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>假定信号量sem_count初始化为1，等待链sem_waitlst初始化为空</p>
<p>信号量的获取down和释放up的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="c1">//获取信号量
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">krlsem_down</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cpuflg_t</span> <span class="n">cpufg</span><span class="p">;</span>
<span class="nl">start_step</span><span class="p">:</span>    
    <span class="n">krlspinlock_cli</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_lock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span><span class="c1">//获取自旋锁
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_count</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span><span class="c1">//如果信号量值小于1,则让代码执行流（线程）睡眠
</span><span class="c1"></span>        <span class="n">krlwlst_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_waitlst</span><span class="p">);</span>
        <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_lock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span>
        <span class="n">krlschedul</span><span class="p">();</span><span class="c1">//切换代码执行流，下次恢复执行时依然从下一行开始执行，所以要goto开始处重新获取信号量
</span><span class="c1"></span>        <span class="k">goto</span> <span class="n">start_step</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_count</span><span class="o">--</span><span class="p">;</span><span class="c1">//信号量值减1,表示成功获取信号量
</span><span class="c1"></span>    <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_lock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span><span class="c1">//释放自旋锁
</span><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//释放信号量
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">krlsem_up</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cpuflg_t</span> <span class="n">cpufg</span><span class="p">;</span>
    <span class="n">krlspinlock_cli</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_lock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span> <span class="c1">//获取自旋锁
</span><span class="c1"></span>    <span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_count</span><span class="o">++</span><span class="p">;</span><span class="c1">//释放信号量
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_count</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span><span class="c1">//如果小于1,则说数据结构出错了，挂起系统
</span><span class="c1"></span>        <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_lock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span>
        <span class="n">hal_sysdie</span><span class="p">(</span><span class="s">&#34;sem up err&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//唤醒该信号量上所有等待的代码执行流（线程）
</span><span class="c1"></span>    <span class="n">krlwlst_allup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_waitlst</span><span class="p">);</span>
    <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">sem_lock</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span>
    <span class="n">krlsched_set_schedflgs</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="获取信号量">获取信号量</h3>
<ol>
<li>对用于保护信号量本身的自旋锁sem_lock加锁</li>
<li>判断sem_count的值: 如果小于1则让进程进入等待状态并将其挂入sem_waitlst；
否则表示信号量获取成功，将sem_count-1，并释放自旋锁</li>
</ol>
<h3 id="释放信号量">释放信号量</h3>
<ol>
<li>对用于保护信号量本身的自旋锁sem_lock加锁</li>
<li>对sem_count+1</li>
<li>唤醒sem_waitlst的进程，释放自旋锁</li>
</ol>
<h1 id="第九讲-linux的并发实现">第九讲 Linux的并发实现</h1>
<h2 id="原子变量">原子变量</h2>
<p>Linux提供了一个原子类型变量atomic_t</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="n">tyepedef</span> <span class="k">struct</span> 
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>
<span class="p">}</span> <span class="n">atomic_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
    <span class="n">s64</span> <span class="n">counter</span><span class="p">;</span>    
<span class="p">}</span> <span class="n">atomic64_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>操作函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="c1">//原子读取变量中的值
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">int</span> <span class="nf">arch_atomic_read</span><span class="p">(</span><span class="k">const</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">__READ_ONCE</span><span class="p">((</span><span class="n">v</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//原子写入一个具体的值
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_atomic_set</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__WRITE_ONCE</span><span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//原子加上一个具体的值
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_atomic_add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="n">LOCK_PREFIX</span> <span class="s">&#34;addl %1,%0&#34;</span>
             <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">)</span>
             <span class="o">:</span> <span class="s">&#34;ir&#34;</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//原子减去一个具体的值
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_atomic_sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="n">LOCK_PREFIX</span> <span class="s">&#34;subl %1,%0&#34;</span>
             <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">)</span>
             <span class="o">:</span> <span class="s">&#34;ir&#34;</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//原子加1
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_atomic_inc</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="n">LOCK_PREFIX</span> <span class="s">&#34;incl %0&#34;</span>
             <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">)</span> <span class="o">::</span> <span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//原子减1
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_atomic_dec</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="n">LOCK_PREFIX</span> <span class="s">&#34;decl %0&#34;</span>
             <span class="o">:</span> <span class="s">&#34;+m&#34;</span> <span class="p">(</span><span class="n">v</span><span class="o">-&gt;</span><span class="n">counter</span><span class="p">)</span> <span class="o">::</span> <span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>



<span class="cp">#define __READ_ONCE(x)  \
</span><span class="cp">(*(const volatile __unqual_scalar_typeof(x) *)&amp;(x))
</span><span class="cp">#define __WRITE_ONCE(x, val) \
</span><span class="cp">do {*(volatile typeof(x) *)&amp;(x) = (val);} while (0)
</span><span class="cp"></span><span class="c1">//__unqual_scalar_typeof表示声明一个非限定的标量类型，非标量类型保持不变。说人话就是返回x变量的类型，这是GCC的功能，typeof只是纯粹返回x的类型。
</span><span class="c1"></span>
<span class="c1">//如果 x 是int类型则返回“int” 
</span><span class="c1"></span><span class="cp">#define __READ_ONCE(x)  \
</span><span class="cp">(*(const volatile int *)&amp;(x))
</span><span class="cp">#define __WRITE_ONCE(x, val) \
</span><span class="cp">do {*(volatile int *)&amp;(x) = (val);} while (0) 
</span></code></pre></td></tr></table>
</div>
</div><h2 id="中断控制">中断控制</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="c1">//实际保存eflags寄存器
</span><span class="c1"></span><span class="k">extern</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">native_save_fl</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;# __raw_save_flags</span><span class="se">\n\t</span><span class="s">&#34;</span>
                 <span class="s">&#34;pushf ; pop %0&#34;</span><span class="o">:</span><span class="s">&#34;=rm&#34;</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span><span class="o">::</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//实际恢复eflags寄存器
</span><span class="c1"></span><span class="k">extern</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">native_restore_fl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">){</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;push %0 ; popf&#34;</span><span class="o">::</span><span class="s">&#34;g&#34;</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span><span class="o">:</span><span class="s">&#34;memory&#34;</span><span class="p">,</span><span class="s">&#34;cc&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//实际关中断
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">native_irq_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;cli&#34;</span><span class="o">:::</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//实际开启中断
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">native_irq_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span><span class="s">&#34;sti&#34;</span><span class="o">:::</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//arch层关中断
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_local_irq_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">native_irq_disable</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">//arch层开启中断
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_local_irq_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span> 
    <span class="n">native_irq_enable</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">//arch层保存eflags寄存器
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="nf">arch_local_save_flags</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">native_save_fl</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">//arch层恢复eflags寄存器
</span><span class="c1"></span><span class="k">static</span>  <span class="n">__always_inline</span> <span class="kt">void</span> <span class="nf">arch_local_irq_restore</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">){</span>
    <span class="n">native_restore_fl</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//实际保存eflags寄存器并关中断
</span><span class="c1"></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">arch_local_irq_save</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">arch_local_save_flags</span><span class="p">();</span>
    <span class="n">arch_local_irq_disable</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//raw层关闭开启中断宏
</span><span class="c1"></span><span class="cp">#define raw_local_irq_disable()     arch_local_irq_disable()
</span><span class="cp">#define raw_local_irq_enable()      arch_local_irq_enable()
</span><span class="cp"></span><span class="c1">//raw层保存恢复eflags寄存器宏
</span><span class="c1"></span><span class="cp">#define raw_local_irq_save(flags)           \
</span><span class="cp">    do {                        \
</span><span class="cp">        typecheck(unsigned long, flags);    \
</span><span class="cp">        flags = arch_local_irq_save();      \
</span><span class="cp">    } while (0)
</span><span class="cp"></span>    
<span class="cp">#define raw_local_irq_restore(flags)            \
</span><span class="cp">    do {                        \
</span><span class="cp">        typecheck(unsigned long, flags);    \
</span><span class="cp">        arch_local_irq_restore(flags);      \
</span><span class="cp">    } while (0)
</span><span class="cp"></span>    
<span class="cp">#define raw_local_save_flags(flags)         \
</span><span class="cp">    do {                        \
</span><span class="cp">        typecheck(unsigned long, flags);    \
</span><span class="cp">        flags = arch_local_save_flags();    \
</span><span class="cp">    } while (0)
</span><span class="cp"></span><span class="c1">//通用层接口宏 
</span><span class="c1"></span><span class="cp">#define local_irq_enable()              \
</span><span class="cp">    do { \
</span><span class="cp">        raw_local_irq_enable();         \
</span><span class="cp">    } while (0)
</span><span class="cp"></span>
<span class="cp">#define local_irq_disable()             \
</span><span class="cp">    do {                        \
</span><span class="cp">        raw_local_irq_disable();        \
</span><span class="cp">    } while (0)
</span><span class="cp"></span>
<span class="cp">#define local_irq_save(flags)               \
</span><span class="cp">    do {                        \
</span><span class="cp">        raw_local_irq_save(flags);      \
</span><span class="cp">    } while (0)
</span><span class="cp"></span>
<span class="cp">#define local_irq_restore(flags)            \
</span><span class="cp">    do {                        \
</span><span class="cp">        raw_local_irq_restore(flags);       \
</span><span class="cp">    } while (0)
</span></code></pre></td></tr></table>
</div>
</div><p><code>do{}while(0)</code>表达式会保证<code>{}</code>中的代码片段执行一次，保证宏展开时这个代码片段是一个整体</p>
<h2 id="自旋锁">自旋锁</h2>
<p>Linux自旋锁有多种实现，下面介绍两种</p>
<h3 id="原始自旋锁">原始自旋锁</h3>
<p>数据结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="k">volatile</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lock</span><span class="p">;</span> 
<span class="p">}</span> <span class="n">spinlock_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="cp">#define spin_unlock_string \  
</span><span class="cp"></span>    <span class="s">&#34;movb $1,%0&#34;</span> <span class="err">\</span> <span class="c1">//写入1表示解锁
</span><span class="c1"></span>    <span class="o">:</span><span class="s">&#34;=m&#34;</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span> <span class="o">:</span> <span class="o">:</span> <span class="s">&#34;memory&#34;</span>

<span class="cp">#define spin_lock_string \
</span><span class="cp">  &#34;\n1:\t&#34; \  
</span><span class="cp"></span>    <span class="s">&#34;lock ; decb %0</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="err">\</span> <span class="c1">//原子减1
</span><span class="c1"></span>  <span class="s">&#34;js 2f</span><span class="se">\n</span><span class="s">&#34;</span> <span class="err">\</span>    <span class="c1">//当结果小于0则跳转到标号2处，表示加锁失败
</span><span class="c1"></span>    <span class="s">&#34;.section .text.lock,</span><span class="se">\&#34;</span><span class="s">ax</span><span class="se">\&#34;\n</span><span class="s">&#34;</span> <span class="err">\</span> <span class="c1">//重新定义一个代码段，这是优化技术，避免后面的代码填充cache，因为大部分情况会加锁成功，链接器会处理好这个代码段的
</span><span class="c1"></span>  <span class="s">&#34;2:</span><span class="se">\t</span><span class="s">&#34;</span> <span class="err">\</span>  
    <span class="s">&#34;cmpb $0,%0</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="err">\</span>  <span class="c1">//和0比较
</span><span class="c1"></span>    <span class="s">&#34;rep;nop</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="err">\</span>  <span class="c1">//空指令
</span><span class="c1"></span>    <span class="s">&#34;jle 2b</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="err">\</span>   <span class="c1">//小于或等于0跳转到标号2
</span><span class="c1"></span>    <span class="s">&#34;jmp 1b</span><span class="se">\n</span><span class="s">&#34;</span> <span class="err">\</span>   <span class="c1">//跳转到标号1  
</span><span class="c1"></span>    <span class="s">&#34;.previous&#34;</span>
<span class="c1">//获取自旋锁
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">spin_lock</span><span class="p">(</span><span class="n">spinlock_t</span><span class="o">*</span><span class="n">lock</span><span class="p">){</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
    <span class="nl">spin_lock_string</span>
    <span class="p">:</span><span class="s">&#34;=m&#34;</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span><span class="o">::</span><span class="s">&#34;memory&#34;</span>
    <span class="p">);</span>
<span class="p">}</span>
<span class="c1">//释放自旋锁
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">spin_unlock</span><span class="p">(</span><span class="n">spinlock_t</span><span class="o">*</span><span class="n">lock</span><span class="p">){</span>
<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
    <span class="n">spin_unlock_string</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>spin_unlock_string</code>只是简单将锁值设置为1，表示释放自旋锁</p>
<p><code>spin_lock_string</code>使用了<code>decb</code>原子减一指令，如果结果为0表示加锁成功；否则
进入循环比较</p>
<p>当有多个进程同时等在自旋锁时，后续获取锁的进程是不确定的，
取决于内存总线协议决定哪个CPU核心可以访问内存</p>
<h3 id="排队自旋锁">排队自旋锁</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="c1">//RAW层的自旋锁数据结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">raw_spinlock</span><span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slock</span><span class="p">;</span><span class="c1">//真正的锁值变量
</span><span class="c1"></span><span class="p">}</span><span class="n">raw_spinlock_t</span><span class="p">;</span>
<span class="c1">//最上层的自旋锁数据结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">spinlock</span><span class="p">{</span>
    <span class="k">struct</span> <span class="n">raw_spinlock</span> <span class="n">rlock</span><span class="p">;</span>
<span class="p">}</span><span class="n">spinlock_t</span><span class="p">;</span>
<span class="c1">//Linux没有这样的结构，这只是为了描述方便
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">raw_spinlock</span><span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slock</span><span class="p">;</span><span class="c1">//真正的锁值变量
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span><span class="n">raw_spinlock_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>slock域被分为两部分，分别保存锁持有者owner（低16位）和未来锁申请者next（高16位）的序号</p>
<p>只有next域和owner域相等时，才表示处于未使用的状态</p>
<p>slock初始值为0，即next和owner被置为0</p>
<p>进程申请自旋锁时，将next域加1，并将原值作为自己的序号</p>
<p>如果序号等于申请时的owner的值，说明自旋锁处于未使用的状态，则进程直接获得锁；</p>
<p>否则，该进程循环检查owner域是否等于自己持有的序号，一旦相等则表名锁轮到自己获取</p>
<p>进程释放锁时，原子的将owner域加 1 即可，下一个进程会发现这个变化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__raw_spin_lock</span><span class="p">(</span><span class="n">raw_spinlock_t</span><span class="o">*</span><span class="n">lock</span><span class="p">){</span>
<span class="kt">int</span> <span class="n">inc</span> <span class="o">=</span> <span class="mh">0x00010000</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
<span class="s">&#34;lock ; xaddl %0, %1</span><span class="se">\n</span><span class="s">&#34;</span> <span class="c1">//将inc和slock交换，然后 inc=inc+slock
</span><span class="c1"></span>                        <span class="c1">//相当于原子读取next和owner并对next+1
</span><span class="c1"></span><span class="s">&#34;movzwl %w0, %2</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//将inc的低16位做0扩展后送tmp tmp=(u16)inc
</span><span class="c1"></span><span class="s">&#34;shrl $16, %0</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//将inc右移16位 inc=inc&gt;&gt;16
</span><span class="c1"></span><span class="s">&#34;1:</span><span class="se">\t</span><span class="s">&#34;</span>
<span class="s">&#34;cmpl %0, %2</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//比较inc和tmp，即比较next和owner 
</span><span class="c1"></span><span class="s">&#34;je 2f</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//相等则跳转到标号2处返回
</span><span class="c1"></span><span class="s">&#34;rep ; nop</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//空指令
</span><span class="c1"></span><span class="s">&#34;movzwl %1, %2</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//将slock的低16位做0扩展后送tmp 即tmp=owner
</span><span class="c1"></span><span class="s">&#34;jmp 1b</span><span class="se">\n</span><span class="s">&#34;</span> <span class="c1">//跳转到标号1处继续比较
</span><span class="c1"></span><span class="s">&#34;2:&#34;</span>
<span class="o">:</span><span class="s">&#34;+Q&#34;</span><span class="p">(</span><span class="n">inc</span><span class="p">),</span><span class="s">&#34;+m&#34;</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">),</span><span class="s">&#34;=r&#34;</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
<span class="o">::</span><span class="s">&#34;memory&#34;</span><span class="p">,</span><span class="s">&#34;cc&#34;</span>
<span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define UNLOCK_LOCK_PREFIX LOCK_PREFIX
</span><span class="cp"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__raw_spin_unlock</span><span class="p">(</span><span class="n">raw_spinlock_t</span><span class="o">*</span><span class="n">lock</span><span class="p">){</span>
<span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
<span class="n">UNLOCK_LOCK_PREFIX</span><span class="s">&#34;incw %0&#34;</span><span class="c1">//将slock的低16位加1 即owner+1
</span><span class="c1"></span><span class="o">:</span><span class="s">&#34;+m&#34;</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">)</span>
<span class="o">::</span><span class="s">&#34;memory&#34;</span><span class="p">,</span><span class="s">&#34;cc&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>try_lock实现当无法立即获取自旋锁时，资源放弃</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__raw_spin_trylock</span><span class="p">(</span><span class="n">raw_spinlock_t</span><span class="o">*</span><span class="n">lock</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">new</span><span class="p">;</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span>
    <span class="s">&#34;movl %2,%0</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//tmp=slock
</span><span class="c1"></span>    <span class="s">&#34;movl %0,%1</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//new=tmp
</span><span class="c1"></span>    <span class="s">&#34;roll $16, %0</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//tmp循环左移16位，即next和owner交换了
</span><span class="c1"></span>    <span class="s">&#34;cmpl %0,%1</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//比较tmp和new即（owner、next）？=（next、owner）
</span><span class="c1"></span>    <span class="s">&#34;jne 1f</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//不等则跳转到标号1处 
</span><span class="c1"></span>    <span class="s">&#34;addl $0x00010000, %1</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//相当于next+1
</span><span class="c1"></span>    <span class="s">&#34;lock ; cmpxchgl %1,%2</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//new和slock交换比较    
</span><span class="c1"></span>    <span class="s">&#34;1:&#34;</span>
    <span class="s">&#34;sete %b1</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//new = eflags.ZF位，ZF取决于前面的判断是否相等
</span><span class="c1"></span>    <span class="s">&#34;movzbl %b1,%0</span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//tmp = new
</span><span class="c1"></span>    <span class="o">:</span><span class="s">&#34;=&amp;a&#34;</span><span class="p">(</span><span class="n">tmp</span><span class="p">),</span><span class="s">&#34;=Q&#34;</span><span class="p">(</span><span class="n">new</span><span class="p">),</span><span class="s">&#34;+m&#34;</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">slock</span><span class="p">)</span>
    <span class="o">::</span><span class="s">&#34;memory&#34;</span><span class="p">,</span><span class="s">&#34;cc&#34;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">__lockfunc</span> <span class="nf">_spin_trylock</span><span class="p">(</span><span class="n">spinlock_t</span><span class="o">*</span><span class="n">lock</span><span class="p">){</span> 
    <span class="n">preempt_disable</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="n">_raw_spin_trylock</span><span class="p">(</span><span class="n">lock</span><span class="p">)){</span>
        <span class="n">spin_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">dep_map</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">_RET_IP_</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">preempt_enable</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define spin_trylock(lock) __cond_lock(lock, _spin_trylock(lock))
</span></code></pre></td></tr></table>
</div>
</div><p><code>_spin_trylock</code>返回1表示尝试加锁成功</p>
<h2 id="信号量">信号量</h2>
<p>信号量可以分为单值信号量和多值信号量</p>
<p>信号量最大的优势是即可以是申请失败的进程睡眠，又可以作为资源计数器使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">semaphore</span>
<span class="p">{</span>
    <span class="n">raw_spinlock_t</span> <span class="n">lock</span><span class="p">;</span> <span class="c1">// 保护信号量自身的自旋锁
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span> <span class="c1">// 信号量值
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">wait_list</span><span class="p">;</span> <span class="c1">//挂载睡眠等待进程的链表
</span><span class="c1"></span><span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>接口函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">__sched</span> <span class="nf">__down_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">,</span> <span class="kt">long</span> <span class="n">state</span><span class="p">,</span><span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">semaphore_waiter</span> <span class="n">waiter</span><span class="p">;</span>
    <span class="c1">//把waiter加入sem-&gt;wait_list的头部
</span><span class="c1"></span>    <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">);</span>
    <span class="n">waiter</span><span class="p">.</span><span class="n">task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span><span class="c1">//current表示当前进程，即调用该函数的进程
</span><span class="c1"></span>    <span class="n">waiter</span><span class="p">.</span><span class="n">up</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">signal_pending_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span>
            <span class="k">goto</span> <span class="n">interrupted</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">timeout</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">goto</span> <span class="n">timed_out</span><span class="p">;</span>
        <span class="n">__set_current_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span><span class="c1">//设置当前进程的状态，进程睡眠，即先前__down函数中传入的TASK_UNINTERRUPTIBLE：该状态是等待资源有效时唤醒（比如等待键盘输入、socket连接、信号（signal）等等），但不可以被中断唤醒
</span><span class="c1"></span>        <span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="c1">//释放在down函数中加的锁
</span><span class="c1"></span>        <span class="n">timeout</span> <span class="o">=</span> <span class="n">schedule_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">);</span><span class="c1">//真正进入睡眠
</span><span class="c1"></span>        <span class="n">raw_spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="c1">//进程下次运行会回到这里，所以要加锁
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">waiter</span><span class="p">.</span><span class="n">up</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
 <span class="nl">timed_out</span><span class="p">:</span>
    <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ETIME</span><span class="p">;</span>
 <span class="nl">interrupted</span><span class="p">:</span>
    <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

    <span class="c1">//为了简单起见处理进程信号（signal）和超时的逻辑代码我已经删除
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//进入睡眠等待
</span><span class="c1"></span><span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="nf">__down</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__down_common</span><span class="p">(</span><span class="n">sem</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">,</span> <span class="n">MAX_SCHEDULE_TIMEOUT</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//获取信号量
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">down</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="c1">//对信号量本身加锁并关中断，也许另一段代码也在操作该信号量
</span><span class="c1"></span>    <span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">sem</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">--</span><span class="p">;</span><span class="c1">//如果信号量值大于0,则对其减1
</span><span class="c1"></span>    <span class="k">else</span>
        <span class="n">__down</span><span class="p">(</span><span class="n">sem</span><span class="p">);</span><span class="c1">//否则让当前进程进入睡眠
</span><span class="c1"></span>    <span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//实际唤醒进程 
</span><span class="c1"></span><span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="nf">__up</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">semaphore_waiter</span> <span class="o">*</span><span class="n">waiter</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">semaphore_waiter</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
    <span class="c1">//获取信号量等待链表中的第一个数据结构semaphore_waiter，它里面保存着睡眠进程的指针
</span><span class="c1"></span>    <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
    <span class="n">waiter</span><span class="o">-&gt;</span><span class="n">up</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">wake_up_process</span><span class="p">(</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">);</span><span class="c1">//唤醒进程重新加入调度队列
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//释放信号量
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">up</span><span class="p">(</span><span class="k">struct</span> <span class="n">semaphore</span> <span class="o">*</span><span class="n">sem</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="c1">//对信号量本身加锁并关中断，必须另一段代码也在操作该信号量
</span><span class="c1"></span>    <span class="n">raw_spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">wait_list</span><span class="p">)))</span>
        <span class="n">sem</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="c1">//如果信号量等待链表中为空，则对信号量值加1
</span><span class="c1"></span>    <span class="k">else</span>
        <span class="n">__up</span><span class="p">(</span><span class="n">sem</span><span class="p">);</span><span class="c1">//否则执行唤醒进程相关的操作
</span><span class="c1"></span>    <span class="n">raw_spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="读写锁">读写锁</h2>
<p>读写之间是互斥的，读写竞争锁时，写会优先得到锁</p>
<p>读写锁本质上是自旋锁的变种，是带计数的自旋锁</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="c1">//读写锁初始化锁值
</span><span class="c1"></span><span class="cp">#define RW_LOCK_BIAS     0x01000000
</span><span class="cp"></span><span class="c1">//读写锁的底层数据结构
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">}</span><span class="n">arch_rwlock_t</span><span class="p">;</span>
<span class="c1">//释放读锁 
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">arch_read_unlock</span><span class="p">(</span><span class="n">arch_rwlock_t</span><span class="o">*</span><span class="n">rw</span><span class="p">){</span> 
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span>
        <span class="n">LOCK_PREFIX</span><span class="s">&#34;incl %0&#34;</span> <span class="c1">//原子对lock加1
</span><span class="c1"></span>        <span class="o">:</span><span class="s">&#34;+m&#34;</span><span class="p">(</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span><span class="o">::</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//释放写锁
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">arch_write_unlock</span><span class="p">(</span><span class="n">arch_rwlock_t</span><span class="o">*</span><span class="n">rw</span><span class="p">){</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span>
        <span class="n">LOCK_PREFIX</span><span class="s">&#34;addl %1, %0&#34;</span><span class="c1">//原子对lock加上RW_LOCK_BIAS
</span><span class="c1"></span>        <span class="o">:</span><span class="s">&#34;+m&#34;</span><span class="p">(</span><span class="n">rw</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span><span class="o">:</span><span class="s">&#34;i&#34;</span><span class="p">(</span><span class="n">RW_LOCK_BIAS</span><span class="p">)</span><span class="o">:</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//获取写锁失败时调用
</span><span class="c1"></span><span class="n">ENTRY</span><span class="p">(</span><span class="n">__write_lock_failed</span><span class="p">)</span>
    <span class="c1">//(%eax)表示由eax指向的内存空间是调用者传进来的 
</span><span class="c1"></span>    <span class="mi">2</span><span class="o">:</span><span class="n">LOCK_PREFIX</span> <span class="n">addl</span>  <span class="err">$</span> <span class="n">RW_LOCK_BIAS</span><span class="p">,(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span>
    <span class="mi">1</span><span class="o">:</span><span class="n">rep</span><span class="p">;</span><span class="n">nop</span><span class="c1">//空指令
</span><span class="c1"></span>    <span class="n">cmpl</span> <span class="err">$</span><span class="n">RW_LOCK_BIAS</span><span class="p">,(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span>
    <span class="c1">//不等于初始值则循环比较，相等则表示有进程释放了写锁
</span><span class="c1"></span>    <span class="n">jne</span>   <span class="mi">1</span><span class="n">b</span>
    <span class="c1">//执行加写锁
</span><span class="c1"></span>    <span class="n">LOCK_PREFIX</span> <span class="n">subl</span>  <span class="err">$</span> <span class="n">RW_LOCK_BIAS</span><span class="p">,(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span>
    <span class="n">jnz</span> <span class="mi">2</span><span class="n">b</span> <span class="c1">//不为0则继续测试，为0则表示加写锁成功
</span><span class="c1"></span>    <span class="n">ret</span> <span class="c1">//返回
</span><span class="c1"></span><span class="n">ENDPROC</span><span class="p">(</span><span class="n">__write_lock_failed</span><span class="p">)</span>
<span class="c1">//获取读锁失败时调用
</span><span class="c1"></span><span class="n">ENTRY</span><span class="p">(</span><span class="n">__read_lock_failed</span><span class="p">)</span>
    <span class="c1">//(%eax)表示由eax指向的内存空间是调用者传进来的 
</span><span class="c1"></span>    <span class="mi">2</span><span class="o">:</span><span class="n">LOCK_PREFIX</span> <span class="n">incl</span><span class="p">(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span><span class="c1">//原子加1
</span><span class="c1"></span>    <span class="mi">1</span><span class="o">:</span>  <span class="n">rep</span><span class="p">;</span> <span class="n">nop</span><span class="c1">//空指令
</span><span class="c1"></span>    <span class="n">cmpl</span>  <span class="err">$</span><span class="mi">1</span><span class="p">,(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span> <span class="c1">//和1比较 小于0则
</span><span class="c1"></span>    <span class="n">js</span> <span class="mi">1</span><span class="n">b</span> <span class="c1">//为负则继续循环比较
</span><span class="c1"></span>    <span class="n">LOCK_PREFIX</span> <span class="n">decl</span><span class="p">(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span> <span class="c1">//加读锁
</span><span class="c1"></span>    <span class="n">js</span>  <span class="mi">2</span><span class="n">b</span>  <span class="c1">//为负则继续加1并比较，否则返回
</span><span class="c1"></span>    <span class="n">ret</span> <span class="c1">//返回
</span><span class="c1"></span><span class="n">ENDPROC</span><span class="p">(</span><span class="n">__read_lock_failed</span><span class="p">)</span>
<span class="c1">//获取读锁
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">arch_read_lock</span><span class="p">(</span><span class="n">arch_rwlock_t</span><span class="o">*</span><span class="n">rw</span><span class="p">){</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span>
        <span class="n">LOCK_PREFIX</span><span class="s">&#34; subl $1,(%0)</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//原子对lock减1
</span><span class="c1"></span>        <span class="s">&#34;jns 1f</span><span class="se">\n</span><span class="s">&#34;</span><span class="c1">//不为小于0则跳转标号1处，表示获取读锁成功
</span><span class="c1"></span>        <span class="s">&#34;call __read_lock_failed</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//调用__read_lock_failed
</span><span class="c1"></span>        <span class="s">&#34;1:</span><span class="se">\n</span><span class="s">&#34;</span>
        <span class="o">::</span><span class="n">LOCK_PTR_REG</span><span class="p">(</span><span class="n">rw</span><span class="p">)</span><span class="o">:</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//获取写锁
</span><span class="c1"></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">arch_write_lock</span><span class="p">(</span><span class="n">arch_rwlock_t</span><span class="o">*</span><span class="n">rw</span><span class="p">){</span>
    <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span>
        <span class="n">LOCK_PREFIX</span><span class="s">&#34;subl %1,(%0)</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//原子对lock减去RW_LOCK_BIAS
</span><span class="c1"></span>        <span class="s">&#34;jz 1f</span><span class="se">\n</span><span class="s">&#34;</span><span class="c1">//为0则跳转标号1处
</span><span class="c1"></span>        <span class="s">&#34;call __write_lock_failed</span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//调用__write_lock_failed
</span><span class="c1"></span>        <span class="s">&#34;1:</span><span class="se">\n</span><span class="s">&#34;</span>
        <span class="o">::</span><span class="n">LOCK_PTR_REG</span><span class="p">(</span><span class="n">rw</span><span class="p">),</span><span class="s">&#34;i&#34;</span><span class="p">(</span><span class="n">RW_LOCK_BIAS</span><span class="p">)</span><span class="o">:</span><span class="s">&#34;memory&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>计数器lock的初始值为<code>0x01000000</code></p>
<ol>
<li>
<p>获取读锁时，lock加1，判断lock的符号位是否为0（即lock是否大于0）为0则表示加锁成功；
否则表示获取读锁失败，此时调用<code>__read_lock_failed</code>，循环测试lock+1&gt;=1</p>
</li>
<li>
<p>获取写时，lock减去初始值，判断lock是否为0，如果不为0则调用<code>__write_lock_failed</code>循环测试lock+0x01000000 == 0x01000000</p>
</li>
</ol>
<h1 id="第十讲设置工作模式和环境">第十讲：设置工作模式和环境</h1>
<h2 id="内核映像文件">内核映像文件</h2>
<p><img src="/image/play_os_in_action/10_1.webp" alt="iso_file_format"></p>
<p>内核映像文件是由多个文件封装的一个文件，其中包含二级引导器的模块，内核模块，图片和文字库文件等。</p>
<p>GRUB通过上图中的4KB的GRUB头来识别映像文件，然后根据映像文件头描述符和文件头描述符的信息解析其他文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//映像文件头描述符
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_mlosrddsc</span>
<span class="p">{</span>
    <span class="n">u64_t</span> <span class="n">mdc_mgic</span><span class="p">;</span> <span class="c1">//映像文件标识
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_sfsum</span><span class="p">;</span><span class="c1">//未使用
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_sfsoff</span><span class="p">;</span><span class="c1">//未使用
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_sfeoff</span><span class="p">;</span><span class="c1">//未使用
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_sfrlsz</span><span class="p">;</span><span class="c1">//未使用
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_ldrbk_s</span><span class="p">;</span><span class="c1">//映像文件中二级引导器的开始偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_ldrbk_e</span><span class="p">;</span><span class="c1">//映像文件中二级引导器的结束偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_ldrbk_rsz</span><span class="p">;</span><span class="c1">//映像文件中二级引导器的实际大小
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_ldrbk_sum</span><span class="p">;</span><span class="c1">//映像文件中二级引导器的校验和
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_fhdbk_s</span><span class="p">;</span><span class="c1">//映像文件中文件头描述的开始偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_fhdbk_e</span><span class="p">;</span><span class="c1">//映像文件中文件头描述的结束偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_fhdbk_rsz</span><span class="p">;</span><span class="c1">//映像文件中文件头描述的实际大小
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_fhdbk_sum</span><span class="p">;</span><span class="c1">//映像文件中文件头描述的校验和
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_filbk_s</span><span class="p">;</span><span class="c1">//映像文件中文件数据的开始偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_filbk_e</span><span class="p">;</span><span class="c1">//映像文件中文件数据的结束偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_filbk_rsz</span><span class="p">;</span><span class="c1">//映像文件中文件数据的实际大小
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_filbk_sum</span><span class="p">;</span><span class="c1">//映像文件中文件数据的校验和
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_ldrcodenr</span><span class="p">;</span><span class="c1">//映像文件中二级引导器的文件头描述符的索引号
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_fhdnr</span><span class="p">;</span><span class="c1">//映像文件中文件头描述符有多少个
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_filnr</span><span class="p">;</span><span class="c1">//映像文件中文件头有多少个
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_endgic</span><span class="p">;</span><span class="c1">//映像文件结束标识
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">mdc_rv</span><span class="p">;</span><span class="c1">//映像文件版本
</span><span class="c1"></span><span class="p">}</span><span class="n">mlosrddsc_t</span><span class="p">;</span>

<span class="cp">#define FHDSC_NMAX 192 </span><span class="c1">//文件名长度
</span><span class="c1">//文件头描述符
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_fhdsc</span>
<span class="p">{</span>
    <span class="n">u64_t</span> <span class="n">fhd_type</span><span class="p">;</span><span class="c1">//文件类型
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">fhd_subtype</span><span class="p">;</span><span class="c1">//文件子类型
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">fhd_stuts</span><span class="p">;</span><span class="c1">//文件状态
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">fhd_id</span><span class="p">;</span><span class="c1">//文件id
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">fhd_intsfsoff</span><span class="p">;</span><span class="c1">//文件在映像文件位置开始偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">fhd_intsfend</span><span class="p">;</span><span class="c1">//文件在映像文件的结束偏移
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">fhd_frealsz</span><span class="p">;</span><span class="c1">//文件实际大小
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">fhd_fsum</span><span class="p">;</span><span class="c1">//文件校验和
</span><span class="c1"></span>    <span class="kt">char</span>   <span class="n">fhd_name</span><span class="p">[</span><span class="n">FHDSC_NMAX</span><span class="p">];</span><span class="c1">//文件名
</span><span class="c1"></span><span class="p">}</span><span class="n">fhdsc_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>内核映像文件使用<code>lmoskrlimg</code>打包</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">lmoskrlimg -m k -lhf GRUB头文件 -o 映像文件 -f 输入的文件列表
-m 表示模式 只能是k内核模式
-lhf 表示后面跟上GRUB头文件
-o 表示输出的映像文件名 
-f 表示输入文件列表
<span class="c1">#例如：lmoskrlimg -m k -lhf grubhead.bin -o kernel.img -f file1.bin file2.bin file3.bin file4.bin </span>
</code></pre></td></tr></table>
</div>
</div><h2 id="准备环境">准备环境</h2>
<h3 id="安装虚拟机">安装虚拟机</h3>
<p>使用virtual box虚拟机</p>
<h3 id="准备硬盘">准备硬盘</h3>
<h4 id="生成纯二进制文件">生成纯二进制文件</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">
dd <span class="nv">bs</span><span class="o">=</span><span class="m">512</span> <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>hd.img <span class="nv">count</span><span class="o">=</span><span class="m">204800</span>

<span class="c1">#bs:表示块大小，这里是512字节</span>
<span class="c1">#if：表示输入文件，/dev/zero就是Linux下专门返回0数据的设备文件，读取它就返回0</span>
<span class="c1">#of：表示输出文件，即我们的硬盘文件。</span>
<span class="c1">#count：表示输出多少块</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="格式化建立文件系统">格式化（建立文件系统）</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">
<span class="c1"># 1. 将文件变成回环设备</span>
<span class="c1"># loop0可能被占用，换成其他名字即可 </span>
sudo losetup /dev/loop0 hd.img

<span class="c1"># 2. 建立文件系统</span>
sudo mkfs.ext4 -q /dev/loop0

<span class="c1"># 3. 挂载</span>
<span class="c1"># 挂载硬盘文件, 可通过 lsblk 命令验证结果</span>
sudo mount -o loop ./hd.img  ./hdisk 
 <span class="c1"># 建立boot目录</span>
sudo mkdir ./hdist/boot 
</code></pre></td></tr></table>
</div>
</div><h3 id="安装grub">安装GRUB</h3>
<ol>
<li>安装GRUB</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">
<span class="c1"># 安装GRUB</span>
sudo grub-install --boot-directory<span class="o">=</span>./hdisk/boot/ --force --allow-floppy /dev/loop0
<span class="c1"># --boot-directory 指向先前我们在虚拟硬盘中建立的boot目录。</span>
<span class="c1"># --force --allow-floppy ：指向我们的虚拟硬盘设备文件/dev/loop0</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>编写配置文件</li>
</ol>
<p>在 /hdisk/boot/grub/ 目录建立 grub.config 文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">menuentry &#39;HelloOS&#39; {
insmod part_msdos
insmod ext2
set root=&#39;hd0,msdos1&#39; #我们的硬盘只有一个分区所以是&#39;hd0,msdos1&#39;
multiboot2 /boot/HelloOS.eki #加载boot目录下的HelloOS.eki文件
boot #引导启动
}
set timeout_style=menu
if [ &#34;${timeout}&#34; = 0 ]; then
  set timeout=10 #等待10秒钟自动启动
fi
</code></pre></td></tr></table>
</div>
</div><h4 id="转成硬盘格式">转成硬盘格式</h4>
<p>将Linux识别的硬盘 转换成虚拟机识别的硬盘</p>
<p>VBoxManage是在宿主机执行，文件可通过共享文件夹传输</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">VBoxManage convertfromraw ./hd.img --format VDI ./hd.vdi
<span class="c1">#convertfromraw 指向原始格式文件</span>
<span class="c1">#--format VDI  表示转换成虚拟需要的VDI格式</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="安装虚拟硬盘">安装虚拟硬盘</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">
<span class="c1"># 第一步：配置硬盘控制器 </span>
<span class="c1"># SATA的硬盘其控制器是intelAHCI</span>
VBoxManage storagectl HelloOS --name <span class="s2">&#34;SATA&#34;</span> --add sata --controller IntelAhci --portcount <span class="m">1</span>
<span class="c1"># 第二步：挂载虚拟硬盘</span>
VBoxManage closemedium disk ./hd.vdi <span class="c1">#删除虚拟硬盘UUID并重新分配</span>
<span class="c1">#将虚拟硬盘挂到虚拟机的硬盘控制器</span>
VBoxManage storageattach HelloOS --storagectl <span class="s2">&#34;SATA&#34;</span> --port <span class="m">1</span> --device <span class="m">0</span> --type hdd --medium ./hd.vdi
</code></pre></td></tr></table>
</div>
</div><h3 id="启动">启动</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">VBoxManage startvm HelloOS <span class="c1">#启动虚拟机</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="第十一讲建造二级引导器">第十一讲：建造二级引导器</h1>
<h2 id="二级引导器作用">二级引导器作用</h2>
<p>收集机器信息，对CPU、内存、显卡等进行初级配置</p>
<h2 id="存储结构">存储结构</h2>
<p>收集的信息会存在如下的数据结构中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_MACHBSTART</span>
<span class="p">{</span>
    <span class="n">u64_t</span>   <span class="n">mb_krlinitstack</span><span class="p">;</span><span class="c1">//内核栈地址
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_krlitstacksz</span><span class="p">;</span><span class="c1">//内核栈大小
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_imgpadr</span><span class="p">;</span><span class="c1">//操作系统映像
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_imgsz</span><span class="p">;</span><span class="c1">//操作系统映像大小
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_bfontpadr</span><span class="p">;</span><span class="c1">//操作系统字体地址
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_bfontsz</span><span class="p">;</span><span class="c1">//操作系统字体大小
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_fvrmphyadr</span><span class="p">;</span><span class="c1">//机器显存地址
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_fvrmsz</span><span class="p">;</span><span class="c1">//机器显存大小
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_cpumode</span><span class="p">;</span><span class="c1">//机器CPU工作模式
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_memsz</span><span class="p">;</span><span class="c1">//机器内存大小
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_e820padr</span><span class="p">;</span><span class="c1">//机器e820数组地址
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_e820nr</span><span class="p">;</span><span class="c1">//机器e820数组元素个数
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_e820sz</span><span class="p">;</span><span class="c1">//机器e820数组大小
</span><span class="c1"></span>    <span class="c1">//……
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_pml4padr</span><span class="p">;</span><span class="c1">//机器页表数据地址
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_subpageslen</span><span class="p">;</span><span class="c1">//机器页表个数
</span><span class="c1"></span>    <span class="n">u64_t</span>   <span class="n">mb_kpmapphymemsz</span><span class="p">;</span><span class="c1">//操作系统映射空间大小
</span><span class="c1"></span>    <span class="c1">//……
</span><span class="c1"></span>    <span class="n">graph_t</span> <span class="n">mb_ghparm</span><span class="p">;</span><span class="c1">//图形信息
</span><span class="c1"></span><span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">machbstart_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="模块规划">模块规划</h2>
<p><img src="/image/play_os_in_action/11_1.webp" alt="modules"></p>
<p>上图的文件经过编译会生成三个文件，具体流程如下</p>
<p><img src="/image/play_os_in_action/11_2.webp" alt="compile"></p>
<p>然后用映像打包工具打包成映像文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">
lmoskrlimg -m k -lhf initldrimh.bin -o Cosmos.eki -f initldrkrl.bin initldrsve.bin
</code></pre></td></tr></table>
</div>
</div><h2 id="实现grub头">实现GRUB头</h2>
<p>GRUB头有两个文件</p>
<ul>
<li>imginithead.asm汇编文件： 让GUR识别、设置C语言环境</li>
<li>inithead.c文件：查找引导器核心文件initldrkrl,bin文件并将其放到特定的内存地址上</li>
</ul>
<h3 id="imginitheadasm">imginithead.asm</h3>
<p>主要工作是初始化CPU的 寄存器，加载GDT，切换到CPU的保护模式</p>
<p>首先是 GRUB1 和 GRUB2需要的带个头结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nf">MBT_HDR_FLAGS</span>  <span class="no">EQU</span> <span class="mi">0x00010003</span>
<span class="nf">MBT_HDR_MAGIC</span>  <span class="no">EQU</span> <span class="mi">0x1BADB002</span>
<span class="nf">MBT2_MAGIC</span>  <span class="no">EQU</span> <span class="mi">0xe85250d6</span>
<span class="nf">global</span> <span class="no">_start</span>
<span class="nf">extern</span> <span class="no">inithead_entry</span>
<span class="err">[</span><span class="nf">section</span> <span class="no">.text</span><span class="p">]</span>
<span class="err">[</span><span class="nf">bits</span> <span class="mi">32</span><span class="p">]</span>
<span class="nl">_start:</span>
  <span class="nf">jmp</span> <span class="no">_entry</span>
<span class="nf">align</span> <span class="mi">4</span>
<span class="nl">mbt_hdr:</span>
  <span class="nf">dd</span> <span class="no">MBT_HDR_MAGIC</span>
  <span class="nf">dd</span> <span class="no">MBT_HDR_FLAGS</span>
  <span class="nf">dd</span> <span class="p">-(</span><span class="no">MBT_HDR_MAGIC</span><span class="err">+</span><span class="no">MBT_HDR_FLAGS</span><span class="p">)</span>
  <span class="nf">dd</span> <span class="no">mbt_hdr</span>
  <span class="nf">dd</span> <span class="no">_start</span>
  <span class="nf">dd</span> <span class="mi">0</span>
  <span class="nf">dd</span> <span class="mi">0</span>
  <span class="nf">dd</span> <span class="no">_entry</span>
<span class="nf">ALIGN</span> <span class="mi">8</span>
<span class="nl">mbhdr:</span>
  <span class="nf">DD</span>  <span class="mi">0xE85250D6</span>
  <span class="nf">DD</span>  <span class="mi">0</span>
  <span class="nf">DD</span>  <span class="no">mhdrend</span> <span class="p">-</span> <span class="no">mbhdr</span>
  <span class="nf">DD</span>  <span class="p">-(</span><span class="mi">0xE85250D6</span> <span class="err">+</span> <span class="mi">0</span> <span class="err">+</span> <span class="p">(</span><span class="no">mhdrend</span> <span class="p">-</span> <span class="no">mbhdr</span><span class="p">))</span>
  <span class="nf">DW</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span>
  <span class="nf">DD</span>  <span class="mi">24</span>
  <span class="nf">DD</span>  <span class="no">mbhdr</span>
  <span class="nf">DD</span>  <span class="no">_start</span>
  <span class="nf">DD</span>  <span class="mi">0</span>
  <span class="nf">DD</span>  <span class="mi">0</span>
  <span class="nf">DW</span>  <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span>
  <span class="nf">DD</span>  <span class="mi">12</span>
  <span class="nf">DD</span>  <span class="no">_entry</span> 
  <span class="no">DD</span>  <span class="mi">0</span>  
  <span class="no">DW</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
  <span class="nf">DD</span>  <span class="mi">8</span>
<span class="nl">mhdrend:</span>
</code></pre></td></tr></table>
</div>
</div><p>关闭中断并加载GDT</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="nl">_entry:</span>
  <span class="nf">cli</span>           <span class="err">；关中断</span>
  <span class="nf">in</span> <span class="no">al</span><span class="p">,</span> <span class="mi">0x70</span> 
  <span class="no">or</span> <span class="no">al</span><span class="p">,</span> <span class="mi">0x80</span>  
  <span class="no">out</span> <span class="mi">0x70</span><span class="p">,</span><span class="no">al</span>  <span class="err">；关掉不可屏蔽中断</span>   
  <span class="no">lgdt</span> <span class="p">[</span><span class="no">GDT_PTR</span><span class="p">]</span> <span class="err">；加载</span><span class="no">GDT地址到GDTR寄存器</span>
  <span class="nf">jmp</span> <span class="no">dword</span> <span class="mi">0x8</span> <span class="p">:</span><span class="no">_32bits_mode</span> <span class="err">；长跳转刷新</span><span class="no">CS影子寄存器</span>
  <span class="c">;………………
</span><span class="c">;GDT全局段描述符表
</span><span class="c"></span><span class="nl">GDT_START:</span>
<span class="nl">knull_dsc:</span> <span class="nf">dq</span> <span class="mi">0</span>
<span class="nl">kcode_dsc:</span> <span class="nf">dq</span> <span class="mi">0x00cf9e000000ffff</span>
<span class="nl">kdata_dsc:</span> <span class="nf">dq</span> <span class="mi">0x00cf92000000ffff</span>
<span class="nl">k16cd_dsc:</span> <span class="nf">dq</span> <span class="mi">0x00009e000000ffff</span> <span class="err">；</span><span class="mi">16</span><span class="err">位代码段描述符</span>
<span class="nl">k16da_dsc:</span> <span class="nf">dq</span> <span class="mi">0x000092000000ffff</span> <span class="err">；</span><span class="mi">16</span><span class="err">位数据段描述符</span>
<span class="nl">GDT_END:</span>
<span class="nl">GDT_PTR:</span>
<span class="nf">GDTLEN</span>  <span class="no">dw</span> <span class="no">GDT_END-GDT_START-1</span>  <span class="c">;GDT界限
</span><span class="c"></span><span class="no">GDTBASE</span>  <span class="no">dd</span> <span class="no">GDT_ST</span>  
</code></pre></td></tr></table>
</div>
</div><p>初始化段寄存器、通用寄存器和栈寄存器</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm">
<span class="nf">_32bits_mode</span><span class="err">：</span>
  <span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span> <span class="mi">0x10</span>
  <span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">ss</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">es</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">fs</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">gs</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">xor</span> <span class="no">eax</span><span class="p">,</span><span class="no">eax</span>
  <span class="nf">xor</span> <span class="no">ebx</span><span class="p">,</span><span class="no">ebx</span>
  <span class="nf">xor</span> <span class="no">ecx</span><span class="p">,</span><span class="no">ecx</span>
  <span class="nf">xor</span> <span class="no">edx</span><span class="p">,</span><span class="no">edx</span>
  <span class="nf">xor</span> <span class="no">edi</span><span class="p">,</span><span class="no">edi</span>
  <span class="nf">xor</span> <span class="no">esi</span><span class="p">,</span><span class="no">esi</span>
  <span class="nf">xor</span> <span class="no">ebp</span><span class="p">,</span><span class="no">ebp</span>
  <span class="nf">xor</span> <span class="no">esp</span><span class="p">,</span><span class="no">esp</span>
  <span class="nf">mov</span> <span class="no">esp</span><span class="p">,</span><span class="mi">0x7c00</span> <span class="err">；设置栈顶为</span><span class="mi">0x7c00</span>
  <span class="nf">call</span> <span class="no">inithead_entry</span> <span class="err">；调用</span><span class="no">inithead_entry函数在inithead.c中实现</span>
  <span class="nf">jmp</span> <span class="mi">0x200000</span>  <span class="err">；跳转到</span><span class="mi">0x200000</span><span class="err">地址</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码最后调用了 inithead_entry 函数</p>
<p>inithead_entry分别调用了<code>write_realintsvefile</code>和<code>write_ldrkrlfile</code>，
将映像文件中的initldrsve.bin文件和initldrkrl.bin文件写入到特定的内存中
其中有两个依赖函数<code>find_file</code> 和<code>m2mcopy</code>
find_file函数负责扫描映像文件中的文件头描述符，对比其中的文件名，
然后返回对应的文件的文件头描述符地址，这样就可以得到其位置和大小</p>
<p>m2mcopy函数 负责将 映像文件复制到具体的内存空间中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="cp">#define MDC_ENDGIC 0xaaffaaffaaffaaff
</span><span class="cp">#define MDC_RVGIC 0xffaaffaaffaaffaa
</span><span class="cp">#define REALDRV_PHYADR 0x1000
</span><span class="cp">#define IMGFILE_PHYADR 0x4000000
</span><span class="cp">#define IMGKRNL_PHYADR 0x2000000
</span><span class="cp">#define LDRFILEADR IMGFILE_PHYADR
</span><span class="cp">#define MLOSDSC_OFF (0x1000)
</span><span class="cp">#define MRDDSC_ADR (mlosrddsc_t*)(LDRFILEADR+0x1000)
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">inithead_entry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">write_realintsvefile</span><span class="p">();</span>
    <span class="n">write_ldrkrlfile</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//写initldrsve.bin文件到特定的内存中
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">write_realintsvefile</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">fhdsc_t</span> <span class="o">*</span><span class="n">fhdscstart</span> <span class="o">=</span> <span class="n">find_file</span><span class="p">(</span><span class="s">&#34;initldrsve.bin&#34;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fhdscstart</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#34;not file initldrsve.bin&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">m2mcopy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32_t</span><span class="p">)(</span><span class="n">fhdscstart</span><span class="o">-&gt;</span><span class="n">fhd_intsfsoff</span><span class="p">)</span> <span class="o">+</span> <span class="n">LDRFILEADR</span><span class="p">),</span>
            <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">REALDRV_PHYADR</span><span class="p">,</span> <span class="p">(</span><span class="n">sint_t</span><span class="p">)</span><span class="n">fhdscstart</span><span class="o">-&gt;</span><span class="n">fhd_frealsz</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//写initldrkrl.bin文件到特定的内存中
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">write_ldrkrlfile</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">fhdsc_t</span> <span class="o">*</span><span class="n">fhdscstart</span> <span class="o">=</span> <span class="n">find_file</span><span class="p">(</span><span class="s">&#34;initldrkrl.bin&#34;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fhdscstart</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#34;not file initldrkrl.bin&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">m2mcopy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32_t</span><span class="p">)(</span><span class="n">fhdscstart</span><span class="o">-&gt;</span><span class="n">fhd_intsfsoff</span><span class="p">)</span> <span class="o">+</span> <span class="n">LDRFILEADR</span><span class="p">),</span>
            <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ILDRKRL_PHYADR</span><span class="p">,</span> <span class="p">(</span><span class="n">sint_t</span><span class="p">)</span><span class="n">fhdscstart</span><span class="o">-&gt;</span><span class="n">fhd_frealsz</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//在映像文件中查找对应的文件
</span><span class="c1"></span><span class="n">fhdsc_t</span> <span class="o">*</span><span class="nf">find_file</span><span class="p">(</span><span class="n">char_t</span> <span class="o">*</span><span class="n">fname</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">mlosrddsc_t</span> <span class="o">*</span><span class="n">mrddadrs</span> <span class="o">=</span> <span class="n">MRDDSC_ADR</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mrddadrs</span><span class="o">-&gt;</span><span class="n">mdc_endgic</span> <span class="o">!=</span> <span class="n">MDC_ENDGIC</span> <span class="o">||</span>
        <span class="n">mrddadrs</span><span class="o">-&gt;</span><span class="n">mdc_rv</span> <span class="o">!=</span> <span class="n">MDC_RVGIC</span> <span class="o">||</span>
        <span class="n">mrddadrs</span><span class="o">-&gt;</span><span class="n">mdc_fhdnr</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span>
        <span class="n">mrddadrs</span><span class="o">-&gt;</span><span class="n">mdc_filnr</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#34;no mrddsc&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">s64_t</span> <span class="n">rethn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">fhdsc_t</span> <span class="o">*</span><span class="n">fhdscstart</span> <span class="o">=</span> <span class="p">(</span><span class="n">fhdsc_t</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32_t</span><span class="p">)(</span><span class="n">mrddadrs</span><span class="o">-&gt;</span><span class="n">mdc_fhdbk_s</span><span class="p">)</span> <span class="o">+</span> <span class="n">LDRFILEADR</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mrddadrs</span><span class="o">-&gt;</span><span class="n">mdc_fhdnr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">strcmpl</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">fhdscstart</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">fhd_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">rethn</span> <span class="o">=</span> <span class="p">(</span><span class="n">s64_t</span><span class="p">)</span><span class="n">i</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">ok_l</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">rethn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="nl">ok_l</span><span class="p">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rethn</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">error</span><span class="p">(</span><span class="s">&#34;not find file&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">fhdscstart</span><span class="p">[</span><span class="n">rethn</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="进入二级引导器">进入二级引导器</h2>
<p><code>imginithead.asm</code>最后的指令<code>jump 0x200000</code>跳转到了物理内存地址0x200000地址处
这个地址放置的正是<code>initldrkrk.bin</code>文件
这一跳进入了二级引导器的主模块</p>
<p>由于模块的 改变，需要写一小段汇编代码，建立下面这个<code>initldr32.asm</code>文件</p>
<p>重新把GDT（段描述符表）、IDT（中断选择子表）和寄存器重新初始化，然后调用二级引导器的主函数<code>ldrkrl_entry</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm">
<span class="nl">_entry:</span>
  <span class="nf">cli</span>
  <span class="nf">lgdt</span> <span class="p">[</span><span class="no">GDT_PTR</span><span class="p">]</span><span class="err">；加载</span><span class="no">GDT地址到GDTR寄存器</span>
  <span class="nf">lidt</span> <span class="p">[</span><span class="no">IDT_PTR</span><span class="p">]</span><span class="err">；加载</span><span class="no">IDT地址到IDTR寄存器</span>
  <span class="nf">jmp</span> <span class="no">dword</span> <span class="mi">0x8</span> <span class="p">:</span><span class="no">_32bits_mode</span><span class="err">；长跳转刷新</span><span class="no">CS影子寄存器</span>
<span class="nl">_32bits_mode:</span>
  <span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span> <span class="mi">0x10</span>  <span class="c">; 数据段选择子(目的)
</span><span class="c"></span>  <span class="no">mov</span> <span class="no">ds</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">ss</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">es</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">fs</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">mov</span> <span class="no">gs</span><span class="p">,</span> <span class="no">ax</span>
  <span class="nf">xor</span> <span class="no">eax</span><span class="p">,</span><span class="no">eax</span>
  <span class="nf">xor</span> <span class="no">ebx</span><span class="p">,</span><span class="no">ebx</span>
  <span class="nf">xor</span> <span class="no">ecx</span><span class="p">,</span><span class="no">ecx</span>
  <span class="nf">xor</span> <span class="no">edx</span><span class="p">,</span><span class="no">edx</span>
  <span class="nf">xor</span> <span class="no">edi</span><span class="p">,</span><span class="no">edi</span>
  <span class="nf">xor</span> <span class="no">esi</span><span class="p">,</span><span class="no">esi</span>
  <span class="nf">xor</span> <span class="no">ebp</span><span class="p">,</span><span class="no">ebp</span>
  <span class="nf">xor</span> <span class="no">esp</span><span class="p">,</span><span class="no">esp</span>
  <span class="nf">mov</span> <span class="no">esp</span><span class="p">,</span><span class="mi">0x90000</span> <span class="err">；使得栈底指向了</span><span class="mi">0x90000</span>
  <span class="nf">call</span> <span class="no">ldrkrl_entry</span> <span class="err">；调用</span><span class="no">ldrkrl_entry函数</span>
  <span class="nf">xor</span> <span class="no">ebx</span><span class="p">,</span><span class="no">ebx</span>
  <span class="nf">jmp</span> <span class="mi">0x2000000</span> <span class="err">；跳转到</span><span class="mi">0x2000000</span><span class="err">的内存地址</span>
  <span class="nf">jmp</span> <span class="no">$</span>
<span class="nl">GDT_START:</span>
<span class="nl">knull_dsc:</span> <span class="nf">dq</span> <span class="mi">0</span>
<span class="nl">kcode_dsc:</span> <span class="nf">dq</span> <span class="mi">0x00cf9a000000ffff</span> <span class="c">;a-e
</span><span class="c"></span><span class="no">kdata_dsc</span><span class="p">:</span> <span class="no">dq</span> <span class="mi">0x00cf92000000ffff</span>
<span class="nl">k16cd_dsc:</span> <span class="nf">dq</span> <span class="mi">0x00009a000000ffff</span> <span class="err">；</span><span class="mi">16</span><span class="err">位代码段描述符</span>
<span class="nl">k16da_dsc:</span> <span class="nf">dq</span> <span class="mi">0x000092000000ffff</span> <span class="err">；</span><span class="mi">16</span><span class="err">位数据段描述符</span>
<span class="nl">GDT_END:</span>
<span class="nl">GDT_PTR:</span>
<span class="nf">GDTLEN</span>  <span class="no">dw</span> <span class="no">GDT_END-GDT_START-1</span>  <span class="c">;GDT界限
</span><span class="c"></span><span class="no">GDTBASE</span>  <span class="no">dd</span> <span class="no">GDT_START</span>

<span class="nl">IDT_PTR:</span>
<span class="nf">IDTLEN</span>  <span class="no">dw</span> <span class="mi">0x3ff</span>
<span class="nf">IDTBAS</span>  <span class="no">dd</span> <span class="mi">0</span>  <span class="err">；这是</span><span class="no">BIOS中断表的地址和长度</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="调用bios中断">调用BIOS中断</h2>
<p>因为获取内存布局信息、设置显卡图像 模式等功能需要依赖BIOS的中断服务</p>
<p>可是BIOS中断工作在16位实模式，所以需要上下文切换，大体流程如下：</p>
<ol>
<li>保存C语言环境下的 CPU上线文，即保护模式下的所有通用寄存器、段寄存器、程序指针寄存器和栈寄存器</li>
<li>切换到实模式，调用BIOS中断，把中断结果保存在内存中</li>
<li>切换回保护模式，加载之前保存的寄存器</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm">
<span class="nl">realadr_call_entry:</span>
  <span class="nf">pushad</span>     <span class="c">;保存通用寄存器
</span><span class="c"></span>  <span class="no">push</span>    <span class="no">ds</span>
  <span class="nf">push</span>    <span class="no">es</span>
  <span class="nf">push</span>    <span class="no">fs</span> <span class="c">;保存4个段寄存器
</span><span class="c"></span>  <span class="no">push</span>    <span class="no">gs</span>
  <span class="nf">call</span> <span class="no">save_eip_jmp</span> <span class="err">；调用</span><span class="no">save_eip_jmp</span> 
  <span class="no">pop</span>  <span class="no">gs</span>
  <span class="nf">pop</span>  <span class="no">fs</span>
  <span class="nf">pop</span>  <span class="no">es</span>      <span class="c">;恢复4个段寄存器
</span><span class="c"></span>  <span class="no">pop</span>  <span class="no">ds</span>
  <span class="nf">popad</span>       <span class="c">;恢复通用寄存器
</span><span class="c"></span>  <span class="no">ret</span>
<span class="nl">save_eip_jmp:</span>
  <span class="nf">pop</span> <span class="no">esi</span>  <span class="err">；弹出</span><span class="no">call</span> <span class="no">save_eip_jmp时保存的eip到esi寄存器中</span><span class="err">，</span> 
  <span class="no">mov</span> <span class="p">[</span><span class="no">PM32_EIP_OFF</span><span class="p">],</span><span class="no">esi</span> <span class="err">；把</span><span class="no">eip保存到特定的内存空间中</span>
  <span class="nf">mov</span> <span class="p">[</span><span class="no">PM32_ESP_OFF</span><span class="p">],</span><span class="no">esp</span> <span class="err">；把</span><span class="no">esp保存到特定的内存空间中</span>
  <span class="nf">jmp</span> <span class="no">dword</span> <span class="no">far</span> <span class="p">[</span><span class="no">cpmty_mode</span><span class="p">]</span><span class="err">；长跳转这里表示把</span><span class="no">cpmty_mode处的第一个4字节装入eip</span><span class="err">，把其后的</span><span class="mi">2</span><span class="err">字节装入</span><span class="no">cs</span>
<span class="nl">cpmty_mode:</span>
  <span class="nf">dd</span> <span class="mi">0x1000</span>
  <span class="nf">dw</span> <span class="mi">0x18</span>
  <span class="nf">jmp</span> <span class="no">$</span>
</code></pre></td></tr></table>
</div>
</div><p><code>jmp dword far [cpmty_mode]</code>指令表示把 [cpmty_mode] 处的数据装入 CS: EIP，
即把 0x18: 0x1000 装入  CS: EIP 中，
0x18 是段描述索引，指向GDT中的 16 位代码段描述符，
0x10000 表示段内地址偏移</p>
<p>这个地址起始的代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm">
<span class="err">[</span><span class="nf">bits</span> <span class="mi">16</span><span class="p">]</span>
<span class="nl">_start:</span>
<span class="nl">_16_mode:</span>
  <span class="nf">mov</span>  <span class="no">bp</span><span class="p">,</span><span class="mi">0x20</span> <span class="c">;0x20是指向GDT中的16位数据段描述符 
</span><span class="c"></span>  <span class="no">mov</span>  <span class="no">ds</span><span class="p">,</span> <span class="no">bp</span>
  <span class="nf">mov</span>  <span class="no">es</span><span class="p">,</span> <span class="no">bp</span>
  <span class="nf">mov</span>  <span class="no">ss</span><span class="p">,</span> <span class="no">bp</span>
  <span class="nf">mov</span>  <span class="no">ebp</span><span class="p">,</span> <span class="no">cr0</span>
  <span class="nf">and</span>  <span class="no">ebp</span><span class="p">,</span> <span class="mi">0xfffffffe</span>
  <span class="nf">mov</span>  <span class="no">cr0</span><span class="p">,</span> <span class="no">ebp</span> <span class="err">；</span><span class="no">CR0.P</span><span class="err">=</span><span class="mi">0</span> <span class="err">关闭保护模式</span>
  <span class="nf">jmp</span>  <span class="mi">0</span><span class="p">:</span><span class="no">real_entry</span> <span class="err">；刷新</span><span class="no">CS影子寄存器</span><span class="err">，真正进入实模式</span>
<span class="nl">real_entry:</span>
  <span class="nf">mov</span> <span class="no">bp</span><span class="p">,</span> <span class="no">cs</span>
  <span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span> <span class="no">bp</span>
  <span class="nf">mov</span> <span class="no">es</span><span class="p">,</span> <span class="no">bp</span>
  <span class="nf">mov</span> <span class="no">ss</span><span class="p">,</span> <span class="no">bp</span> <span class="err">；重新设置实模式下的段寄存器</span> <span class="err">都是</span><span class="no">CS中值</span><span class="err">，即为</span><span class="mi">0</span> 
  <span class="no">mov</span> <span class="no">sp</span><span class="p">,</span> <span class="mi">08000</span><span class="no">h</span> <span class="err">；设置栈</span>
  <span class="nf">mov</span> <span class="no">bp</span><span class="p">,</span><span class="no">func_table</span>
  <span class="nf">add</span> <span class="no">bp</span><span class="p">,</span><span class="no">ax</span>
  <span class="nf">call</span> <span class="p">[</span><span class="no">bp</span><span class="p">]</span> <span class="err">；调用函数表中的汇编函数，</span><span class="no">ax是C函数中传递进来的</span>
  <span class="nf">cli</span>
  <span class="nf">call</span> <span class="no">disable_nmi</span>
  <span class="nf">mov</span>  <span class="no">ebp</span><span class="p">,</span> <span class="no">cr0</span>
  <span class="nf">or</span>  <span class="no">ebp</span><span class="p">,</span> <span class="mi">1</span>
  <span class="nf">mov</span>  <span class="no">cr0</span><span class="p">,</span> <span class="no">ebp</span> <span class="err">；</span><span class="no">CR0.P</span><span class="err">=</span><span class="mi">1</span> <span class="err">开启保护模式</span>
  <span class="nf">jmp</span> <span class="no">dword</span> <span class="mi">0x8</span> <span class="p">:</span><span class="no">_32bits_mode</span>
<span class="err">[</span><span class="nf">BITS</span> <span class="mi">32</span><span class="p">]</span>
<span class="nl">_32bits_mode:</span>
  <span class="nf">mov</span> <span class="no">bp</span><span class="p">,</span> <span class="mi">0x10</span>
  <span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span> <span class="no">bp</span>
  <span class="nf">mov</span> <span class="no">ss</span><span class="p">,</span> <span class="no">bp</span><span class="err">；重新设置保护模式下的段寄存器</span><span class="mi">0x10</span><span class="err">是</span><span class="mi">32</span><span class="err">位数据段描述符的索引</span>
  <span class="nf">mov</span> <span class="no">esi</span><span class="p">,[</span><span class="no">PM32_EIP_OFF</span><span class="p">]</span><span class="err">；加载先前保存的</span><span class="no">EIP</span>
  <span class="nf">mov</span> <span class="no">esp</span><span class="p">,[</span><span class="no">PM32_ESP_OFF</span><span class="p">]</span><span class="err">；加载先前保存的</span><span class="no">ESP</span>
  <span class="nf">jmp</span> <span class="no">esi</span> <span class="err">；</span><span class="no">eip</span><span class="err">=</span><span class="no">esi</span> <span class="err">回到了</span><span class="no">realadr_call_entry函数中</span>

<span class="nl">func_table:</span>  <span class="c">;函数表
</span><span class="c"></span>  <span class="nf">dw</span> <span class="no">_getmmap</span> <span class="err">；获取内存布局视图的函数</span>
  <span class="nf">dw</span> <span class="no">_read</span> <span class="err">；读取硬盘的函数</span>
    <span class="nf">dw</span> <span class="no">_getvbemode</span> <span class="err">；获取显卡</span><span class="no">VBE模式</span> 
    <span class="no">dw</span> <span class="no">_getvbeonemodeinfo</span> <span class="err">；获取显卡</span><span class="no">VBE模式的数据</span>
    <span class="nf">dw</span> <span class="no">_setvbemode</span> <span class="err">；设置显卡</span><span class="no">VBE模式</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的代码将其编译成16位的二进制文件，然后放在0x10000开始的内存空间
代码流程如下：</p>
<ol>
<li>从<code>_16_mode</code>进入实模式</li>
<li>在<code>real_entry</code>根据ax寄存器的值找到函数表对应的函数，执行完后再次进入保护模式</li>
<li>加载EIP和ESP寄存器，从而回到<code>realadr_call_entry</code>函数</li>
</ol>
<h2 id="引导器主函数">引导器主函数</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">ldrkrl_entry</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">init_bstartparm</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>ldrkrl_entry</code>函数在<code>initldr32.asm</code>文件中被调用</p>
<h1 id="第十二讲探查和收集信息">第十二讲：探查和收集信息</h1>
<p>入口函数<code>ldrkrl_entry</code>实际调用了<code>init_bstartparm</code></p>
<h2 id="初始化">初始化</h2>
<p>首先在1MB的内存地址处初始化了一个机器信息结构<code>machbstart_t</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//初始化machbstart_t结构体，清0,并设置一个标志
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">machbstart_t_init</span><span class="p">(</span><span class="n">machbstart_t</span><span class="o">*</span> <span class="n">initp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">initp</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">machbstart_t</span><span class="p">));</span>
    <span class="n">initp</span><span class="o">-&gt;</span><span class="n">mb_migc</span><span class="o">=</span><span class="n">MBS_MIGC</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">init_bstartparm</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">machbstart_t</span><span class="o">*</span> <span class="n">mbsp</span> <span class="o">=</span> <span class="n">MBSPADR</span><span class="p">;</span><span class="c1">//1MB的内存地址
</span><span class="c1"></span>    <span class="n">machbstart_t_init</span><span class="p">(</span><span class="n">mbsp</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="检查cpu">检查CPU</h2>
<p>我们需要检查CPU，主要通过两个函数实现：</p>
<ul>
<li>chk_cpuid: 检查CPU是否支持CPUID指令</li>
<li>chk_cpuid: 用CPUID指令检查CPU是否支持64位长模式</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//通过改写Eflags寄存器的第21位，观察其位的变化判断是否支持CPUID
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">chk_cpuid</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">rets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
        <span class="s">&#34;pushfl </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popl %%eax </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;movl %%eax,%%ebx </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;xorl $0x0200000,%%eax </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushl %%eax </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popfl </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushfl </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popl %%eax </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;xorl %%ebx,%%eax </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;jz 1f </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;movl $1,%0 </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;jmp 2f </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;1: movl $0,%0 </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;2: </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="o">:</span> <span class="s">&#34;=c&#34;</span><span class="p">(</span><span class="n">rets</span><span class="p">)</span>
        <span class="o">:</span>
        <span class="o">:</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rets</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//检查CPU是否支持长模式
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">chk_cpu_longmode</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">rets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
        <span class="s">&#34;movl $0x80000000,%%eax </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;cpuid </span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//把eax中放入0x80000000调用CPUID指令
</span><span class="c1"></span>        <span class="s">&#34;cmpl $0x80000001,%%eax </span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//看eax中返回结果
</span><span class="c1"></span>        <span class="s">&#34;setnb %%al </span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//不为0x80000001,则不支持0x80000001号功能
</span><span class="c1"></span>        <span class="s">&#34;jb 1f </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;movl $0x80000001,%%eax </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;cpuid </span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//把eax中放入0x800000001调用CPUID指令，检查edx中的返回数据
</span><span class="c1"></span>        <span class="s">&#34;bt $29,%%edx  </span><span class="se">\n\t</span><span class="s">&#34;</span> <span class="c1">//长模式 支持位  是否为1
</span><span class="c1"></span>        <span class="s">&#34;setcb %%al </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;1: </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;movzx %%al,%%eax </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="o">:</span> <span class="s">&#34;=a&#34;</span><span class="p">(</span><span class="n">rets</span><span class="p">)</span>
        <span class="o">:</span>
        <span class="o">:</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rets</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//检查CPU主函数
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">init_chkcpu</span><span class="p">(</span><span class="n">machbstart_t</span> <span class="o">*</span><span class="n">mbsp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chk_cpuid</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">kerror</span><span class="p">(</span><span class="s">&#34;Your CPU is not support CPUID sys is die!&#34;</span><span class="p">);</span>
        <span class="n">CLI_HALT</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chk_cpu_longmode</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="n">kerror</span><span class="p">(</span><span class="s">&#34;Your CPU is not support 64bits mode sys is die!&#34;</span><span class="p">);</span>
        <span class="n">CLI_HALT</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_cpumode</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span><span class="c1">//如果成功则设置机器信息结构的cpu模式为64位
</span><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="获取内存布局">获取内存布局</h2>
<p>描述内存的数据结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#define RAM_USABLE 1 </span><span class="c1">//可用内存
</span><span class="c1"></span><span class="cp">#define RAM_RESERV 2 </span><span class="c1">//保留内存不可使用
</span><span class="c1"></span><span class="cp">#define RAM_ACPIREC 3 </span><span class="c1">//ACPI表相关的
</span><span class="c1"></span><span class="cp">#define RAM_ACPINVS 4 </span><span class="c1">//ACPI NVS空间
</span><span class="c1"></span><span class="cp">#define RAM_AREACON 5 </span><span class="c1">//包含坏内存
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_e820</span><span class="p">{</span>
    <span class="n">u64_t</span> <span class="n">saddr</span><span class="p">;</span>    <span class="cm">/* 内存开始地址 */</span>
    <span class="n">u64_t</span> <span class="n">lsize</span><span class="p">;</span>    <span class="cm">/* 内存大小 */</span>
    <span class="n">u32_t</span> <span class="n">type</span><span class="p">;</span>    <span class="cm">/* 内存类型 */</span>
<span class="p">}</span><span class="n">e820map_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>获取内存布局信息就是获取这个结构体的数组，具体实现代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="kt">void</span> <span class="nf">mmap</span><span class="p">(</span><span class="n">e820map_t</span> <span class="o">**</span><span class="n">retemp</span><span class="p">,</span> <span class="n">u32_t</span> <span class="o">*</span><span class="n">retemnr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">realadr_call_entry</span><span class="p">(</span><span class="n">RLINTNR</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="o">*</span><span class="n">retemnr</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">u32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">E80MAP_NR</span><span class="p">));</span>
    <span class="o">*</span><span class="n">retemp</span> <span class="o">=</span> <span class="p">(</span><span class="n">e820map_t</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="p">((</span><span class="n">u32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">E80MAP_ADRADR</span><span class="p">)));</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#define ETYBAK_ADR 0x2000
</span><span class="cp">#define PM32_EIP_OFF (ETYBAK_ADR)
</span><span class="cp">#define PM32_ESP_OFF (ETYBAK_ADR+4)
</span><span class="cp">#define E80MAP_NR (ETYBAK_ADR+64)</span><span class="c1">//保存e820map_t结构数组元素个数的地址
</span><span class="c1"></span><span class="cp">#define E80MAP_ADRADR (ETYBAK_ADR+68) </span><span class="c1">//保存e820map_t结构数组的开始地址
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">init_mem</span><span class="p">(</span><span class="n">machbstart_t</span> <span class="o">*</span><span class="n">mbsp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">e820map_t</span> <span class="o">*</span><span class="n">retemp</span><span class="p">;</span>
    <span class="n">u32_t</span> <span class="n">retemnr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">mmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">retemp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retemnr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">retemnr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">kerror</span><span class="p">(</span><span class="s">&#34;no e820map</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//根据e820map_t结构数据检查内存大小
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">chk_memsize</span><span class="p">(</span><span class="n">retemp</span><span class="p">,</span> <span class="n">retemnr</span><span class="p">,</span> <span class="mh">0x100000</span><span class="p">,</span> <span class="mh">0x8000000</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">kerror</span><span class="p">(</span><span class="s">&#34;Your computer is low on memory, the memory cannot be less than 128MB!&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_e820padr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64_t</span><span class="p">)((</span><span class="n">u32_t</span><span class="p">)(</span><span class="n">retemp</span><span class="p">));</span><span class="c1">//把e820map_t结构数组的首地址传给mbsp-&gt;mb_e820padr 
</span><span class="c1"></span>    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_e820nr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64_t</span><span class="p">)</span><span class="n">retemnr</span><span class="p">;</span><span class="c1">//把e820map_t结构数组元素个数传给mbsp-&gt;mb_e820nr 
</span><span class="c1"></span>    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_e820sz</span> <span class="o">=</span> <span class="n">retemnr</span> <span class="o">*</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">e820map_t</span><span class="p">));</span><span class="c1">//把e820map_t结构数组大小传给mbsp-&gt;mb_e820sz 
</span><span class="c1"></span>    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_memsz</span> <span class="o">=</span> <span class="n">get_memsize</span><span class="p">(</span><span class="n">retemp</span><span class="p">,</span> <span class="n">retemnr</span><span class="p">);</span><span class="c1">//根据e820map_t结构数据计算内存大小。
</span><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中<code>mmap</code>通过<code>realadr_call_entry</code>调用实模式下的<code>_getmmap</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm">
<span class="nl">_getmmap:</span>
  <span class="nf">push</span> <span class="no">ds</span>
  <span class="nf">push</span> <span class="no">es</span>
  <span class="nf">push</span> <span class="no">ss</span>
  <span class="nf">mov</span> <span class="no">esi</span><span class="p">,</span><span class="mi">0</span>
  <span class="nf">mov</span> <span class="no">dword</span><span class="p">[</span><span class="no">E80MAP_NR</span><span class="p">],</span><span class="no">esi</span>
  <span class="nf">mov</span> <span class="no">dword</span><span class="p">[</span><span class="no">E80MAP_ADRADR</span><span class="p">],</span><span class="no">E80MAP_ADR</span> <span class="c">;e820map结构体开始地址
</span><span class="c"></span>  <span class="no">xor</span> <span class="no">ebx</span><span class="p">,</span><span class="no">ebx</span>
  <span class="nf">mov</span> <span class="no">edi</span><span class="p">,</span><span class="no">E80MAP_ADR</span>
<span class="nl">loop:</span>
  <span class="nf">mov</span> <span class="no">eax</span><span class="p">,</span><span class="mi">0</span><span class="no">e820h</span> <span class="c">;获取e820map结构参数
</span><span class="c"></span>  <span class="no">mov</span> <span class="no">ecx</span><span class="p">,</span><span class="mi">20</span>    <span class="c">;e820map结构大小
</span><span class="c"></span>  <span class="no">mov</span> <span class="no">edx</span><span class="p">,</span><span class="mi">0534</span><span class="no">d4150h</span> <span class="c">;获取e820map结构参数必须是这个数据
</span><span class="c"></span>  <span class="no">int</span> <span class="mi">15</span><span class="no">h</span>  <span class="c">;BIOS的15h中断
</span><span class="c"></span>  <span class="no">jc</span> <span class="no">.1</span>
  <span class="nf">add</span> <span class="no">edi</span><span class="p">,</span><span class="mi">20</span>
  <span class="nf">cmp</span> <span class="no">edi</span><span class="p">,</span><span class="no">E80MAP_ADR</span><span class="err">+</span><span class="mi">0x1000</span>
  <span class="nf">jg</span> <span class="no">.1</span>
  <span class="nf">inc</span> <span class="no">esi</span>
  <span class="nf">cmp</span> <span class="no">ebx</span><span class="p">,</span><span class="mi">0</span>
  <span class="nf">jne</span> <span class="no">loop</span> <span class="c">;循环获取e820map结构
</span><span class="c"></span>  <span class="no">jmp</span> <span class="no">.2</span>
<span class="nl">.1:</span>
  <span class="nf">mov</span> <span class="no">esi</span><span class="p">,</span><span class="mi">0</span>    <span class="c">;出错处理，e820map结构数组元素个数为0
</span><span class="c"></span><span class="no">.2</span><span class="p">:</span>
  <span class="nf">mov</span> <span class="no">dword</span><span class="p">[</span><span class="no">E80MAP_NR</span><span class="p">],</span><span class="no">esi</span> <span class="c">;e820map结构数组元素个数
</span><span class="c"></span>  <span class="no">pop</span> <span class="no">ss</span>
  <span class="nf">pop</span> <span class="no">es</span>
  <span class="nf">pop</span> <span class="no">ds</span>
  <span class="nf">ret</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="初始化内核栈">初始化内核栈</h2>
<p>因为操作系统使用C语言写的，所以需要有栈</p>
<p>初始化其实就是在机器信息结构<code>machbstart_t</code>中记录一下栈顶地址和栈大小</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#define IKSTACK_PHYADR (0x90000-0x10)
</span><span class="cp">#define IKSTACK_SIZE 0x1000
</span><span class="cp"></span><span class="c1">//初始化内核栈
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">init_krlinitstack</span><span class="p">(</span><span class="n">machbstart_t</span> <span class="o">*</span><span class="n">mbsp</span><span class="p">)</span>
<span class="p">{</span>   
    <span class="c1">// 检查是否 和已经用到的内存空间（0x8f000 ~ 0x8f000_0x1001）冲突
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">move_krlimg</span><span class="p">(</span><span class="n">mbsp</span><span class="p">,</span> <span class="p">(</span><span class="n">u64_t</span><span class="p">)(</span><span class="mh">0x8f000</span><span class="p">),</span> <span class="mh">0x1001</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">kerror</span><span class="p">(</span><span class="s">&#34;iks_moveimg err&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_krlinitstack</span> <span class="o">=</span> <span class="n">IKSTACK_PHYADR</span><span class="p">;</span><span class="c1">//栈顶地址
</span><span class="c1"></span>    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_krlitstacksz</span> <span class="o">=</span> <span class="n">IKSTACK_SIZE</span><span class="p">;</span> <span class="c1">//栈大小是4KB
</span><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="放置内核文件和字库文件">放置内核文件和字库文件</h2>
<p>从映像文件中解析出来放在特定内存空间中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//放置内核文件
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">init_krlfile</span><span class="p">(</span><span class="n">machbstart_t</span> <span class="o">*</span><span class="n">mbsp</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">//在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找kernel.bin文件
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">r_file_to_padr</span><span class="p">(</span><span class="n">mbsp</span><span class="p">,</span> <span class="n">IMGKRNL_PHYADR</span><span class="p">,</span> <span class="s">&#34;kernel.bin&#34;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">sz</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">kerror</span><span class="p">(</span><span class="s">&#34;r_file_to_padr err&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//放置完成后更新机器信息结构中的数据
</span><span class="c1"></span>    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_krlimgpadr</span> <span class="o">=</span> <span class="n">IMGKRNL_PHYADR</span><span class="p">;</span>
    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_krlsz</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span>
    <span class="c1">//mbsp-&gt;mb_nextwtpadr始终要保持指向下一段空闲内存的首地址 
</span><span class="c1"></span>    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_nextwtpadr</span> <span class="o">=</span> <span class="n">P4K_ALIGN</span><span class="p">(</span><span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_krlimgpadr</span> <span class="o">+</span> <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_krlsz</span><span class="p">);</span>
    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_kalldendpadr</span> <span class="o">=</span> <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_krlimgpadr</span> <span class="o">+</span> <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_krlsz</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//放置字库文件
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">init_defutfont</span><span class="p">(</span><span class="n">machbstart_t</span> <span class="o">*</span><span class="n">mbsp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">u64_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">//获取下一段空闲内存空间的首地址 
</span><span class="c1"></span>    <span class="n">u32_t</span> <span class="n">dfadr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32_t</span><span class="p">)</span><span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_nextwtpadr</span><span class="p">;</span>
<span class="c1">//在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找font.fnt文件
</span><span class="c1"></span>    <span class="n">sz</span> <span class="o">=</span> <span class="n">r_file_to_padr</span><span class="p">(</span><span class="n">mbsp</span><span class="p">,</span> <span class="n">dfadr</span><span class="p">,</span> <span class="s">&#34;font.fnt&#34;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">sz</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">kerror</span><span class="p">(</span><span class="s">&#34;r_file_to_padr err&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//放置完成后更新机器信息结构中的数据
</span><span class="c1"></span>    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_bfontpadr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64_t</span><span class="p">)(</span><span class="n">dfadr</span><span class="p">);</span>
    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_bfontsz</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span>
    <span class="c1">//更新机器信息结构中下一段空闲内存的首地址  
</span><span class="c1"></span>    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_nextwtpadr</span> <span class="o">=</span> <span class="n">P4K_ALIGN</span><span class="p">((</span><span class="n">u32_t</span><span class="p">)(</span><span class="n">dfadr</span><span class="p">)</span> <span class="o">+</span> <span class="n">sz</span><span class="p">);</span>
    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_kalldendpadr</span> <span class="o">=</span> <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_bfontpadr</span> <span class="o">+</span> <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_bfontsz</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="建立mmu页表数据">建立MMU页表数据</h2>
<p>Memory Management Unit</p>
<p>内核虚拟地址空间从 0xffff800000000000 开始，大小为 16GB，
所以映射关系为：0xffff800000000000～0xffff800400000000 映射到物理地址空间 0～0x400000000</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#define KINITPAGE_PHYADR 0x1000000
</span><span class="cp"></span><span class="kt">void</span> <span class="nf">init_bstartpages</span><span class="p">(</span><span class="n">machbstart_t</span> <span class="o">*</span><span class="n">mbsp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//顶级页目录
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">KINITPAGE_PHYADR</span><span class="p">);</span><span class="c1">//16MB地址处
</span><span class="c1"></span>    <span class="c1">//页目录指针
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="o">*</span><span class="n">pdpte</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">KINITPAGE_PHYADR</span> <span class="o">+</span> <span class="mh">0x1000</span><span class="p">);</span>
    <span class="c1">//页目录
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="o">*</span><span class="n">pde</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">KINITPAGE_PHYADR</span> <span class="o">+</span> <span class="mh">0x2000</span><span class="p">);</span>
    <span class="c1">//物理地址从0开始
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">adr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">move_krlimg</span><span class="p">(</span><span class="n">mbsp</span><span class="p">,</span> <span class="p">(</span><span class="n">u64_t</span><span class="p">)(</span><span class="n">KINITPAGE_PHYADR</span><span class="p">),</span> <span class="p">(</span><span class="mh">0x1000</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="mh">0x2000</span><span class="p">)))</span>
    <span class="p">{</span>
        <span class="n">kerror</span><span class="p">(</span><span class="s">&#34;move_krlimg err&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//将顶级页目录、页目录指针的空间清0
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">uint_t</span> <span class="n">mi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mi</span> <span class="o">&lt;</span> <span class="n">PGENTY_SIZE</span><span class="p">;</span> <span class="n">mi</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">p</span><span class="p">[</span><span class="n">mi</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">pdpte</span><span class="p">[</span><span class="n">mi</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//映射
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">uint_t</span> <span class="n">pdei</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pdei</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">pdei</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">pdpte</span><span class="p">[</span><span class="n">pdei</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64_t</span><span class="p">)((</span><span class="n">u32_t</span><span class="p">)</span><span class="n">pde</span> <span class="o">|</span> <span class="n">KPDPTE_RW</span> <span class="o">|</span> <span class="n">KPDPTE_P</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">uint_t</span> <span class="n">pdeii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pdeii</span> <span class="o">&lt;</span> <span class="n">PGENTY_SIZE</span><span class="p">;</span> <span class="n">pdeii</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span><span class="c1">//大页KPDE_PS 2MB，可读写KPDE_RW，存在KPDE_P
</span><span class="c1"></span>            <span class="n">pde</span><span class="p">[</span><span class="n">pdeii</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">|</span> <span class="n">adr</span> <span class="o">|</span> <span class="n">KPDE_PS</span> <span class="o">|</span> <span class="n">KPDE_RW</span> <span class="o">|</span> <span class="n">KPDE_P</span><span class="p">;</span>
            <span class="n">adr</span> <span class="o">+=</span> <span class="mh">0x200000</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">pde</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64_t</span> <span class="o">*</span><span class="p">)((</span><span class="n">u32_t</span><span class="p">)</span><span class="n">pde</span> <span class="o">+</span> <span class="mh">0x1000</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//让顶级页目录中第0项和第((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff项，指向同一个页目录指针页  
</span><span class="c1"></span>    <span class="n">p</span><span class="p">[((</span><span class="n">KRNL_VIRTUAL_ADDRESS_START</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">KPML4_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1ff</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64_t</span><span class="p">)((</span><span class="n">u32_t</span><span class="p">)</span><span class="n">pdpte</span> <span class="o">|</span> <span class="n">KPML4_RW</span> <span class="o">|</span> <span class="n">KPML4_P</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64_t</span><span class="p">)((</span><span class="n">u32_t</span><span class="p">)</span><span class="n">pdpte</span> <span class="o">|</span> <span class="n">KPML4_RW</span> <span class="o">|</span> <span class="n">KPML4_P</span><span class="p">);</span>
    <span class="c1">//把页表首地址保存在机器信息结构中
</span><span class="c1"></span>    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_pml4padr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64_t</span><span class="p">)(</span><span class="n">KINITPAGE_PHYADR</span><span class="p">);</span>
    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_subpageslen</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64_t</span><span class="p">)(</span><span class="mh">0x1000</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">+</span> <span class="mh">0x2000</span><span class="p">);</span>
    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_kpmapphymemsz</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64_t</span><span class="p">)(</span><span class="mh">0x400000000</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>为了简化编程，使用了长模式下的 2MB 分页方式</p>
<p>映射的核心逻辑由两重循环控制，外层循环控制页目录指针顶，只有 16 项，其中每一项都指向一个页目录，每个页目录中有 512 个物理页地址</p>
<p>物理地址每次增加 2MB，这是由 26～30 行的内层循环控制，每执行一次外层循环就要执行 512 次内层循环。</p>
<p>最后，顶级页目录中第 0 项和第 ((KRNL_VIRTUAL_ADDRESS_START) &raquo; KPML4_SHIFT) &amp; 0x1ff 项，指向同一个页目录指针页，这样的话就能让虚拟地址：0xffff800000000000～0xffff800400000000 和虚拟地址：0～0x400000000，访问到同一个物理地址空间 0～0x400000000，这样做是有目的，内核在启动初期，虚拟地址和物理地址要保持相同。</p>
<h2 id="设置显卡图形模式">设置显卡图形模式</h2>
<p>显卡默认是文本模式，只能显示ASCII字符，需要切换到图形模式</p>
<p>切换显卡模式需要使用BIOS中断</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">init_graph</span><span class="p">(</span><span class="n">machbstart_t</span><span class="o">*</span> <span class="n">mbsp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//初始化图形数据结构
</span><span class="c1"></span>    <span class="n">graph_t_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_ghparm</span><span class="p">);</span>
    <span class="c1">//获取VBE模式，通过BIOS中断
</span><span class="c1"></span>    <span class="n">get_vbemode</span><span class="p">(</span><span class="n">mbsp</span><span class="p">);</span>
    <span class="c1">//获取一个具体VBE模式的信息，通过BIOS中断
</span><span class="c1"></span>    <span class="n">get_vbemodeinfo</span><span class="p">(</span><span class="n">mbsp</span><span class="p">);</span>
    <span class="c1">//设置VBE模式，通过BIOS中断
</span><span class="c1"></span>    <span class="n">set_vbemodeinfo</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里使用了 VBE 的 118h 模式，该模式屏幕f分辨率为 1024*768，显存大小是 16.8MB</p>
<p>屏幕分辨率为 1024 * 768，即共768行，为行1024个像素点，
每个像素点占32位空间（红、绿、蓝、透明各8位）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_PIXCL</span>
<span class="p">{</span>
    <span class="n">u8_t</span> <span class="n">cl_b</span><span class="p">;</span> <span class="c1">//蓝
</span><span class="c1"></span>    <span class="n">u8_t</span> <span class="n">cl_g</span><span class="p">;</span> <span class="c1">//绿
</span><span class="c1"></span>    <span class="n">u8_t</span> <span class="n">cl_r</span><span class="p">;</span> <span class="c1">//红
</span><span class="c1"></span>    <span class="n">u8_t</span> <span class="n">cl_a</span><span class="p">;</span> <span class="c1">//透明
</span><span class="c1"></span><span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">pixcl_t</span><span class="p">;</span>

<span class="cp">#define BGRA(r,g,b) ((0|(r&lt;&lt;16)|(g&lt;&lt;8)|b))
</span><span class="cp"></span><span class="c1">//通常情况下用pixl_t 和 BGRA宏
</span><span class="c1"></span><span class="k">typedef</span> <span class="n">u32_t</span> <span class="n">pixl_t</span><span class="p">;</span>


<span class="n">u32_t</span><span class="o">*</span> <span class="n">dispmem</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32_t</span><span class="o">*</span><span class="p">)</span><span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_ghparm</span><span class="p">.</span><span class="n">gh_framphyadr</span><span class="p">;</span>
<span class="n">dispmem</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)]</span> <span class="o">=</span> <span class="n">pix</span><span class="p">;</span>
<span class="c1">//x，y是像素的位置
</span></code></pre></td></tr></table>
</div>
</div><h2 id="集成">集成</h2>
<p>在<code>init_bstartparm</code>将上述功能串联起来，设置工作环境</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="kt">void</span> <span class="nf">init_bstartparm</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">machbstart_t</span> <span class="o">*</span><span class="n">mbsp</span> <span class="o">=</span> <span class="n">MBSPADR</span><span class="p">;</span>
    <span class="n">machbstart_t_init</span><span class="p">(</span><span class="n">mbsp</span><span class="p">);</span>
    <span class="c1">//检查CPU
</span><span class="c1"></span>    <span class="n">init_chkcpu</span><span class="p">(</span><span class="n">mbsp</span><span class="p">);</span>
    <span class="c1">//获取内存布局
</span><span class="c1"></span>    <span class="n">init_mem</span><span class="p">(</span><span class="n">mbsp</span><span class="p">);</span>
    <span class="c1">//初始化内核栈
</span><span class="c1"></span>    <span class="n">init_krlinitstack</span><span class="p">(</span><span class="n">mbsp</span><span class="p">);</span>
    <span class="c1">//放置内核文件
</span><span class="c1"></span>    <span class="n">init_krlfile</span><span class="p">(</span><span class="n">mbsp</span><span class="p">);</span>
    <span class="c1">//放置字库文件
</span><span class="c1"></span>    <span class="n">init_defutfont</span><span class="p">(</span><span class="n">mbsp</span><span class="p">);</span>
    <span class="c1">//将e820map结构数组从低地址（0x2068）搬到高地址（0x2000000）
</span><span class="c1"></span>    <span class="n">init_meme820</span><span class="p">(</span><span class="n">mbsp</span><span class="p">);</span>
    <span class="c1">//建立MMU页表
</span><span class="c1"></span>    <span class="n">init_bstartpages</span><span class="p">(</span><span class="n">mbsp</span><span class="p">);</span>
    <span class="c1">//设置图形模式
</span><span class="c1"></span>    <span class="n">init_graph</span><span class="p">(</span><span class="n">mbsp</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="显示logo">显示Logo</h2>
<p>前面已经设置了图形模式，可以展示图片了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="kt">void</span> <span class="nf">logo</span><span class="p">(</span><span class="n">machbstart_t</span><span class="o">*</span> <span class="n">mbsp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">u32_t</span> <span class="n">retadr</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">sz</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="c1">//在映像文件中获取logo.bmp文件
</span><span class="c1"></span>    <span class="n">get_file_rpadrandsz</span><span class="p">(</span><span class="s">&#34;logo.bmp&#34;</span><span class="p">,</span><span class="n">mbsp</span><span class="p">,</span><span class="o">&amp;</span><span class="n">retadr</span><span class="p">,</span><span class="o">&amp;</span><span class="n">sz</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="mi">0</span><span class="o">==</span><span class="n">retadr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">kerror</span><span class="p">(</span><span class="s">&#34;logo getfilerpadrsz err&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//显示logo文件中的图像数据
</span><span class="c1"></span>    <span class="n">bmp_print</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">retadr</span><span class="p">,</span><span class="n">mbsp</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">init_graph</span><span class="p">(</span><span class="n">machbstart_t</span><span class="o">*</span> <span class="n">mbsp</span><span class="p">)</span>
<span class="p">{</span>    
    <span class="c1">//……前面代码省略
</span><span class="c1"></span>    <span class="c1">//显示
</span><span class="c1"></span>    <span class="n">logo</span><span class="p">(</span><span class="n">mbsp</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="切换cpu到长模式">切换CPU到长模式</h2>
<p>切换到长模式（64位）后，寄存器位宽变了，需要重新初始化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="err">[</span><span class="nf">section</span> <span class="no">.start.text</span><span class="p">]</span>
<span class="err">[</span><span class="nf">BITS</span> <span class="mi">32</span><span class="p">]</span>
<span class="nl">_start:</span>
    <span class="nf">cli</span>
    <span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span><span class="mi">0x10</span>
    <span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span><span class="no">ax</span>
    <span class="nf">mov</span> <span class="no">es</span><span class="p">,</span><span class="no">ax</span>
    <span class="nf">mov</span> <span class="no">ss</span><span class="p">,</span><span class="no">ax</span>
    <span class="nf">mov</span> <span class="no">fs</span><span class="p">,</span><span class="no">ax</span>
    <span class="nf">mov</span> <span class="no">gs</span><span class="p">,</span><span class="no">ax</span>
    <span class="nf">lgdt</span> <span class="p">[</span><span class="no">eGdtPtr</span><span class="p">]</span>        
    <span class="c">;开启 PAE
</span><span class="c"></span>    <span class="no">mov</span> <span class="no">eax</span><span class="p">,</span> <span class="no">cr4</span>
    <span class="nf">bts</span> <span class="no">eax</span><span class="p">,</span> <span class="mi">5</span>                      <span class="c">; CR4.PAE = 1
</span><span class="c"></span>    <span class="no">mov</span> <span class="no">cr4</span><span class="p">,</span> <span class="no">eax</span>
    <span class="nf">mov</span> <span class="no">eax</span><span class="p">,</span> <span class="no">PML4T_BADR</span>             <span class="c">;加载MMU顶级页目录
</span><span class="c"></span>    <span class="no">mov</span> <span class="no">cr3</span><span class="p">,</span> <span class="no">eax</span>  
    <span class="c">;开启 64bits long-mode
</span><span class="c"></span>    <span class="no">mov</span> <span class="no">ecx</span><span class="p">,</span> <span class="no">IA32_EFER</span>
    <span class="nf">rdmsr</span>
    <span class="nf">bts</span> <span class="no">eax</span><span class="p">,</span> <span class="mi">8</span>                      <span class="c">; IA32_EFER.LME =1
</span><span class="c"></span>    <span class="no">wrmsr</span>
    <span class="c">;开启 PE 和 paging
</span><span class="c"></span>    <span class="nf">mov</span> <span class="no">eax</span><span class="p">,</span> <span class="no">cr0</span>
    <span class="nf">bts</span> <span class="no">eax</span><span class="p">,</span> <span class="mi">0</span>                      <span class="c">; CR0.PE =1
</span><span class="c"></span>    <span class="no">bts</span> <span class="no">eax</span><span class="p">,</span> <span class="mi">31</span>
    <span class="c">;开启 CACHE       
</span><span class="c"></span>    <span class="nf">btr</span> <span class="no">eax</span><span class="p">,</span><span class="mi">29</span>                    <span class="c">; CR0.NW=0
</span><span class="c"></span>    <span class="no">btr</span> <span class="no">eax</span><span class="p">,</span><span class="mi">30</span>                    <span class="c">; CR0.CD=0  CACHE
</span><span class="c"></span>    <span class="no">mov</span> <span class="no">cr0</span><span class="p">,</span> <span class="no">eax</span>                    <span class="c">; IA32_EFER.LMA = 1
</span><span class="c"></span>    <span class="no">jmp</span> <span class="mi">08</span><span class="p">:</span><span class="no">entry64</span>
<span class="err">[</span><span class="nf">BITS</span> <span class="mi">64</span><span class="p">]</span>
<span class="nl">entry64:</span>
    <span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span><span class="mi">0x10</span>
    <span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span><span class="no">ax</span>
    <span class="nf">mov</span> <span class="no">es</span><span class="p">,</span><span class="no">ax</span>
    <span class="nf">mov</span> <span class="no">ss</span><span class="p">,</span><span class="no">ax</span>
    <span class="nf">mov</span> <span class="no">fs</span><span class="p">,</span><span class="no">ax</span>
    <span class="nf">mov</span> <span class="no">gs</span><span class="p">,</span><span class="no">ax</span>
    <span class="nf">xor</span> <span class="no">rax</span><span class="p">,</span><span class="no">rax</span>
    <span class="nf">xor</span> <span class="no">rbx</span><span class="p">,</span><span class="no">rbx</span>
    <span class="nf">xor</span> <span class="no">rbp</span><span class="p">,</span><span class="no">rbp</span>
    <span class="nf">xor</span> <span class="no">rcx</span><span class="p">,</span><span class="no">rcx</span>
    <span class="nf">xor</span> <span class="no">rdx</span><span class="p">,</span><span class="no">rdx</span>
    <span class="nf">xor</span> <span class="no">rdi</span><span class="p">,</span><span class="no">rdi</span>
    <span class="nf">xor</span> <span class="no">rsi</span><span class="p">,</span><span class="no">rsi</span>
    <span class="nf">xor</span> <span class="no">r8</span><span class="p">,</span><span class="no">r8</span>
    <span class="nf">xor</span> <span class="no">r9</span><span class="p">,</span><span class="no">r9</span>
    <span class="nf">xor</span> <span class="no">r10</span><span class="p">,</span><span class="no">r10</span>
    <span class="nf">xor</span> <span class="no">r11</span><span class="p">,</span><span class="no">r11</span>
    <span class="nf">xor</span> <span class="no">r12</span><span class="p">,</span><span class="no">r12</span>
    <span class="nf">xor</span> <span class="no">r13</span><span class="p">,</span><span class="no">r13</span>
    <span class="nf">xor</span> <span class="no">r14</span><span class="p">,</span><span class="no">r14</span>
    <span class="nf">xor</span> <span class="no">r15</span><span class="p">,</span><span class="no">r15</span>
    <span class="nf">mov</span> <span class="no">rbx</span><span class="p">,</span><span class="no">MBSP_ADR</span>
    <span class="nf">mov</span> <span class="no">rax</span><span class="p">,</span><span class="no">KRLVIRADR</span>
    <span class="nf">mov</span> <span class="no">rcx</span><span class="p">,[</span><span class="no">rbx</span><span class="err">+</span><span class="no">KINITSTACK_OFF</span><span class="p">]</span>
    <span class="nf">add</span> <span class="no">rax</span><span class="p">,</span><span class="no">rcx</span>
    <span class="nf">xor</span> <span class="no">rcx</span><span class="p">,</span><span class="no">rcx</span>
    <span class="nf">xor</span> <span class="no">rbx</span><span class="p">,</span><span class="no">rbx</span>
    <span class="nf">mov</span> <span class="no">rsp</span><span class="p">,</span><span class="no">rax</span>
    <span class="nf">push</span> <span class="mi">0</span>
    <span class="nf">push</span> <span class="mi">0x8</span>
    <span class="nf">mov</span> <span class="no">rax</span><span class="p">,</span><span class="no">hal_start</span>                 <span class="c">;调用内核主函数
</span><span class="c"></span>    <span class="no">push</span> <span class="no">rax</span>
    <span class="nf">dw</span> <span class="mi">0xcb48</span>
    <span class="nf">jmp</span> <span class="no">$</span>
<span class="err">[</span><span class="nf">section</span> <span class="no">.start.data</span><span class="p">]</span>
<span class="err">[</span><span class="nf">BITS</span> <span class="mi">32</span><span class="p">]</span>
<span class="nl">x64_GDT:</span>
<span class="nl">enull_x64_dsc:</span>  <span class="nf">dq</span> <span class="mi">0</span>  
<span class="no">ekrnl_c64_dsc</span><span class="p">:</span>  <span class="no">dq</span> <span class="mi">0x0020980000000000</span>   <span class="c">; 64-bit 内核代码段
</span><span class="c"></span><span class="no">ekrnl_d64_dsc</span><span class="p">:</span>  <span class="no">dq</span> <span class="mi">0x0000920000000000</span>   <span class="c">; 64-bit 内核数据段
</span><span class="c"></span><span class="no">euser_c64_dsc</span><span class="p">:</span>  <span class="no">dq</span> <span class="mi">0x0020f80000000000</span>   <span class="c">; 64-bit 用户代码段
</span><span class="c"></span><span class="no">euser_d64_dsc</span><span class="p">:</span>  <span class="no">dq</span> <span class="mi">0x0000f20000000000</span>   <span class="c">; 64-bit 用户数据段
</span><span class="c"></span><span class="no">eGdtLen</span>      <span class="no">equ</span>  <span class="no">$</span> <span class="p">-</span> <span class="no">enull_x64_dsc</span>   <span class="c">; GDT长度
</span><span class="c"></span><span class="no">eGdtPtr</span><span class="p">:</span>    <span class="no">dw</span> <span class="no">eGdtLen</span> <span class="p">-</span> <span class="mi">1</span>      <span class="c">; GDT界限
</span><span class="c"></span>        <span class="no">dq</span> <span class="no">ex64_GDT</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码具体详情是：</p>
<ul>
<li>1~11行加载70~75行的 GDT</li>
<li>13~17行设置MMU、加载二级引导器中准备好的MMU页表</li>
<li>19~30行开启长模式、打开Cache</li>
<li>34~54行初始化寄存器</li>
<li>55~61行读取二级引导器中准备好的机器信息结构的栈地址存到RSP寄存器</li>
<li>63~66行把8和hal_start函数地址压入栈，利用<code>dw 0xcb48</code>指令将数据弹出到
RIP和CS寄存器</li>
</ul>
<h1 id="第十三讲-实现板级初始化">第十三讲 实现板级初始化</h1>
<h2 id="hal层初始化">hal层初始化</h2>
<p>hal层对硬件相关的操作进行了抽象，对内核提供接口</p>
<h3 id="初始化平台">初始化平台</h3>
<p><code>init_halplaltform</code>主要完成两个任务：</p>
<ul>
<li>复制二级引导器建立的机器信息结构到hal层中的全局变量中，并释放二级引导器对应数据的内存</li>
<li>初始化图形显卡的驱动</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">machbstart_t_init</span><span class="p">(</span><span class="n">machbstart_t</span> <span class="o">*</span><span class="n">initp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//清零
</span><span class="c1"></span>    <span class="n">memset</span><span class="p">(</span><span class="n">initp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">machbstart_t</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">init_machbstart</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">machbstart_t</span> <span class="o">*</span><span class="n">kmbsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kmachbsp</span><span class="p">;</span>
    <span class="n">machbstart_t</span> <span class="o">*</span><span class="n">smbsp</span> <span class="o">=</span> <span class="n">MBSPADR</span><span class="p">;</span><span class="c1">//物理地址1MB处
</span><span class="c1"></span>    <span class="n">machbstart_t_init</span><span class="p">(</span><span class="n">kmbsp</span><span class="p">);</span>
    <span class="c1">//复制，要把地址转换成虚拟地址
</span><span class="c1"></span>    <span class="n">memcopy</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">phyadr_to_viradr</span><span class="p">((</span><span class="n">adr_t</span><span class="p">)</span><span class="n">smbsp</span><span class="p">),</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">kmbsp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">machbstart_t</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//平台初始化函数
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">init_halplaltform</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//复制机器信息结构
</span><span class="c1"></span>    <span class="n">init_machbstart</span><span class="p">();</span>
    <span class="c1">//初始化图形显示驱动
</span><span class="c1"></span>    <span class="n">init_bdvideo</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>kmachbsp</code>是个hal层的全局变量，通过宏声明</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//file: Comos/hal/x86
</span><span class="c1">//全局变量定义变量放在data段
</span><span class="c1"></span><span class="cp">#define  HAL_DEFGLOB_VARIABLE(vartype, varnam) \
</span><span class="cp">EXTERN __attribute__((section(&#34;.data&#34;))) vartype varname
</span><span class="cp"></span>
<span class="n">HAL_DEFGLOB_VARIABLE</span><span class="p">(</span><span class="n">machbstart_t</span><span class="p">,</span> <span class="n">kmachbsp</span><span class="p">);</span> 
</code></pre></td></tr></table>
</div>
</div><p>图形显卡初始化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="kt">void</span> <span class="nf">init_bdvideo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">dftgraph_t</span> <span class="o">*</span><span class="n">kghp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kdftgh</span><span class="p">;</span>
    <span class="c1">//初始化图形数据结构，里面放有图形模式，分辨率，图形驱动函数指针
</span><span class="c1"></span>    <span class="n">init_dftgraph</span><span class="p">();</span>
    <span class="c1">//初始bga图形显卡的函数指针
</span><span class="c1"></span>    <span class="n">init_bga</span><span class="p">();</span>
    <span class="c1">//初始vbe图形显卡的函数指针
</span><span class="c1"></span>    <span class="n">init_vbe</span><span class="p">();</span>
    <span class="c1">//清空屏幕 为黑色
</span><span class="c1"></span>    <span class="n">fill_graph</span><span class="p">(</span><span class="n">kghp</span><span class="p">,</span> <span class="n">BGRA</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="c1">//显示背景图片 
</span><span class="c1"></span>    <span class="n">set_charsdxwflush</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">hal_background</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_DFTGRAPH</span>
<span class="p">{</span>
    <span class="n">u64_t</span> <span class="n">gh_mode</span><span class="p">;</span>         <span class="c1">//图形模式
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_x</span><span class="p">;</span>            <span class="c1">//水平像素点
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_y</span><span class="p">;</span>            <span class="c1">//垂直像素点
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_framphyadr</span><span class="p">;</span>   <span class="c1">//显存物理地址 
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_fvrmphyadr</span><span class="p">;</span>   <span class="c1">//显存虚拟地址
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_fvrmsz</span><span class="p">;</span>       <span class="c1">//显存大小
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_onepixbits</span><span class="p">;</span>   <span class="c1">//一个像素字占用的数据位数
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_onepixbyte</span><span class="p">;</span>
    <span class="n">u64_t</span> <span class="n">gh_vbemodenr</span><span class="p">;</span>    <span class="c1">//vbe模式号
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_bank</span><span class="p">;</span>         <span class="c1">//显存的bank数
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_curdipbnk</span><span class="p">;</span>    <span class="c1">//当前bank
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_nextbnk</span><span class="p">;</span>      <span class="c1">//下一个bank
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_banksz</span><span class="p">;</span>       <span class="c1">//bank大小
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_fontadr</span><span class="p">;</span>      <span class="c1">//字库地址
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_fontsz</span><span class="p">;</span>       <span class="c1">//字库大小
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_fnthight</span><span class="p">;</span>     <span class="c1">//字体高度
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_nxtcharsx</span><span class="p">;</span>    <span class="c1">//下一字符显示的x坐标
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_nxtcharsy</span><span class="p">;</span>    <span class="c1">//下一字符显示的y坐标
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_linesz</span><span class="p">;</span>       <span class="c1">//字符行高
</span><span class="c1"></span>    <span class="n">pixl_t</span> <span class="n">gh_deffontpx</span><span class="p">;</span>   <span class="c1">//默认字体大小
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">gh_chardxw</span><span class="p">;</span>
    <span class="n">u64_t</span> <span class="n">gh_flush</span><span class="p">;</span>
    <span class="n">u64_t</span> <span class="n">gh_framnr</span><span class="p">;</span>
    <span class="n">u64_t</span> <span class="n">gh_fshdata</span><span class="p">;</span>      <span class="c1">//刷新相关的
</span><span class="c1"></span>    <span class="n">dftghops_t</span> <span class="n">gh_opfun</span><span class="p">;</span>   <span class="c1">//图形驱动操作函数指针结构体
</span><span class="c1"></span><span class="p">}</span><span class="n">dftgraph_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_DFTGHOPS</span>
<span class="p">{</span>
    <span class="c1">//读写显存数据
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">dgo_read</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">outp</span><span class="p">,</span><span class="n">size_t</span> <span class="n">rdsz</span><span class="p">);</span>
    <span class="n">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">dgo_write</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">inp</span><span class="p">,</span><span class="n">size_t</span> <span class="n">wesz</span><span class="p">);</span>
    <span class="n">sint_t</span> <span class="p">(</span><span class="o">*</span><span class="n">dgo_ioctrl</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">outp</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">iocode</span><span class="p">);</span>
    <span class="c1">//刷新
</span><span class="c1"></span>    <span class="kt">void</span>   <span class="p">(</span><span class="o">*</span><span class="n">dgo_flush</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">);</span>
    <span class="n">sint_t</span> <span class="p">(</span><span class="o">*</span><span class="n">dgo_set_bank</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">,</span> <span class="n">sint_t</span> <span class="n">bnr</span><span class="p">);</span>
    <span class="c1">//读写像素
</span><span class="c1"></span>    <span class="n">pixl_t</span> <span class="p">(</span><span class="o">*</span><span class="n">dgo_readpix</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">x</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">y</span><span class="p">);</span>
    <span class="kt">void</span>   <span class="p">(</span><span class="o">*</span><span class="n">dgo_writepix</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">,</span><span class="n">pixl_t</span> <span class="n">pix</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">x</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">y</span><span class="p">);</span>
    <span class="c1">//直接读写像素 
</span><span class="c1"></span>    <span class="n">pixl_t</span> <span class="p">(</span><span class="o">*</span><span class="n">dgo_dxreadpix</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">x</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">y</span><span class="p">);</span>
    <span class="kt">void</span>   <span class="p">(</span><span class="o">*</span><span class="n">dgo_dxwritepix</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">,</span><span class="n">pixl_t</span> <span class="n">pix</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">x</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">y</span><span class="p">);</span>
    <span class="c1">//设置x，y坐标和偏移
</span><span class="c1"></span>    <span class="n">sint_t</span> <span class="p">(</span><span class="o">*</span><span class="n">dgo_set_xy</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">x</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">y</span><span class="p">);</span>
    <span class="n">sint_t</span> <span class="p">(</span><span class="o">*</span><span class="n">dgo_set_vwh</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">vwt</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">vhi</span><span class="p">);</span>
    <span class="n">sint_t</span> <span class="p">(</span><span class="o">*</span><span class="n">dgo_set_xyoffset</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">xoff</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">yoff</span><span class="p">);</span>
    <span class="c1">//获取x，y坐标和偏移
</span><span class="c1"></span>    <span class="n">sint_t</span> <span class="p">(</span><span class="o">*</span><span class="n">dgo_get_xy</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">,</span><span class="n">uint_t</span><span class="o">*</span> <span class="n">rx</span><span class="p">,</span><span class="n">uint_t</span><span class="o">*</span> <span class="n">ry</span><span class="p">);</span>
    <span class="n">sint_t</span> <span class="p">(</span><span class="o">*</span><span class="n">dgo_get_vwh</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">,</span><span class="n">uint_t</span><span class="o">*</span> <span class="n">rvwt</span><span class="p">,</span><span class="n">uint_t</span><span class="o">*</span> <span class="n">rvhi</span><span class="p">);</span>
    <span class="n">sint_t</span> <span class="p">(</span><span class="o">*</span><span class="n">dgo_get_xyoffset</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ghpdev</span><span class="p">,</span><span class="n">uint_t</span><span class="o">*</span> <span class="n">rxoff</span><span class="p">,</span><span class="n">uint_t</span><span class="o">*</span> <span class="n">ryoff</span><span class="p">);</span>
<span class="p">}</span><span class="n">dftghops_t</span><span class="p">;</span>
<span class="c1">//刷新显存
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">flush_videoram</span><span class="p">(</span><span class="n">dftgraph_t</span> <span class="o">*</span><span class="n">kghp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">kghp</span><span class="o">-&gt;</span><span class="n">gh_opfun</span><span class="p">.</span><span class="n">dgo_flush</span><span class="p">(</span><span class="n">kghp</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>我们将实际的图形驱动函数填入了<code>dftghops_t</code>结构体，通过结构体就可以调用相应的函数了</p>
<h3 id="初始化内存">初始化内存</h3>
<p>对二级引导器的内存布局信息进行扩展：</p>
<ul>
<li>增加内存保留空间</li>
<li>对布局信息进行排序</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="cp">#define PMR_T_OSAPUSERRAM 1
</span><span class="cp">#define PMR_T_RESERVRAM 2
</span><span class="cp">#define PMR_T_HWUSERRAM 8
</span><span class="cp">#define PMR_T_ARACONRAM 0xf
</span><span class="cp">#define PMR_T_BUGRAM 0xff
</span><span class="cp">#define PMR_F_X86_32 (1&lt;&lt;0)
</span><span class="cp">#define PMR_F_X86_64 (1&lt;&lt;1)
</span><span class="cp">#define PMR_F_ARM_32 (1&lt;&lt;2)
</span><span class="cp">#define PMR_F_ARM_64 (1&lt;&lt;3)
</span><span class="cp">#define PMR_F_HAL_MASK 0xff
</span><span class="cp"></span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_PHYMMARGE</span>
<span class="p">{</span>
    <span class="n">spinlock_t</span> <span class="n">pmr_lock</span><span class="p">;</span><span class="c1">//保护这个结构是自旋锁
</span><span class="c1"></span>    <span class="n">u32_t</span> <span class="n">pmr_type</span><span class="p">;</span>     <span class="c1">//内存地址空间类型
</span><span class="c1"></span>    <span class="n">u32_t</span> <span class="n">pmr_stype</span><span class="p">;</span>
    <span class="n">u32_t</span> <span class="n">pmr_dtype</span><span class="p">;</span>    <span class="c1">//内存地址空间的子类型，见上面的宏
</span><span class="c1"></span>    <span class="n">u32_t</span> <span class="n">pmr_flgs</span><span class="p">;</span>     <span class="c1">//结构的标志与状态
</span><span class="c1"></span>    <span class="n">u32_t</span> <span class="n">pmr_stus</span><span class="p">;</span>
    <span class="n">u64_t</span> <span class="n">pmr_saddr</span><span class="p">;</span>    <span class="c1">//内存空间的开始地址
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">pmr_lsize</span><span class="p">;</span>    <span class="c1">//内存空间的大小
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">pmr_end</span><span class="p">;</span>      <span class="c1">//内存空间的结束地址
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">pmr_rrvmsaddr</span><span class="p">;</span><span class="c1">//内存保留空间的开始地址
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">pmr_rrvmend</span><span class="p">;</span>  <span class="c1">//内存保留空间的结束地址
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">pmr_prip</span><span class="p">;</span>     <span class="c1">//结构的私有数据指针，以后扩展所用
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">pmr_extp</span><span class="p">;</span>     <span class="c1">//结构的扩展数据指针，以后扩展所用
</span><span class="c1"></span><span class="p">}</span><span class="n">phymmarge_t</span><span class="p">;</span>


<span class="n">u64_t</span> <span class="nf">initpmrge_core</span><span class="p">(</span><span class="n">e820map_t</span> <span class="o">*</span><span class="n">e8sp</span><span class="p">,</span> <span class="n">u64_t</span> <span class="n">e8nr</span><span class="p">,</span> <span class="n">phymmarge_t</span> <span class="o">*</span><span class="n">pmargesp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">u64_t</span> <span class="n">retnr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">u64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">e8nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//根据一个e820map_t结构建立一个phymmarge_t结构
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">init_one_pmrge</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e8sp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">pmargesp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">retnr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">retnr</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">retnr</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">init_phymmarge</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">machbstart_t</span> <span class="o">*</span><span class="n">mbsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kmachbsp</span><span class="p">;</span>
    <span class="n">phymmarge_t</span> <span class="o">*</span><span class="n">pmarge_adr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">u64_t</span> <span class="n">pmrgesz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">//根据machbstart_t机器信息结构计算获得phymmarge_t结构的开始地址和大小
</span><span class="c1"></span>    <span class="n">ret_phymmarge_adrandsz</span><span class="p">(</span><span class="n">mbsp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmarge_adr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmrgesz</span><span class="p">);</span>
    <span class="n">u64_t</span> <span class="n">tmppmrphyadr</span> <span class="o">=</span> <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_nextwtpadr</span><span class="p">;</span>
    <span class="n">e820map_t</span> <span class="o">*</span><span class="n">e8p</span> <span class="o">=</span> <span class="p">(</span><span class="n">e820map_t</span> <span class="o">*</span><span class="p">)((</span><span class="n">adr_t</span><span class="p">)(</span><span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_e820padr</span><span class="p">));</span>
    <span class="c1">//建立phymmarge_t结构
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">ipmgnr</span> <span class="o">=</span> <span class="n">initpmrge_core</span><span class="p">(</span><span class="n">e8p</span><span class="p">,</span> <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_e820nr</span><span class="p">,</span> <span class="n">pmarge_adr</span><span class="p">);</span>
    <span class="c1">//把phymmarge_t结构的地址大小个数保存machbstart_t机器信息结构中
</span><span class="c1"></span>    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_e820expadr</span> <span class="o">=</span> <span class="n">tmppmrphyadr</span><span class="p">;</span>
    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_e820exnr</span> <span class="o">=</span> <span class="n">ipmgnr</span><span class="p">;</span>
    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_e820exsz</span> <span class="o">=</span> <span class="n">ipmgnr</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">phymmarge_t</span><span class="p">);</span>
    <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_nextwtpadr</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_e820expadr</span> <span class="o">+</span> <span class="n">mbsp</span><span class="o">-&gt;</span><span class="n">mb_e820exsz</span><span class="p">);</span>
    <span class="c1">//phymmarge_t结构中地址空间从低到高进行排序，我已经帮你写好了
</span><span class="c1"></span>    <span class="n">phymmarge_sort</span><span class="p">(</span><span class="n">pmarge_adr</span><span class="p">,</span> <span class="n">ipmgnr</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="初始化中断">初始化中断</h3>
<p>数据结构为<code>gate_t</code>，最大为256，由IDTR寄存器指向</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_GATE</span>
<span class="p">{</span>
        <span class="n">u16_t</span>   <span class="n">offset_low</span><span class="p">;</span>     <span class="cm">/* 偏移 */</span>
        <span class="n">u16_t</span>   <span class="n">selector</span><span class="p">;</span>       <span class="cm">/* 段选择子 */</span>
        <span class="n">u8_t</span>    <span class="n">dcount</span><span class="p">;</span>         <span class="cm">/* 该字段只在调用门描述符中有效。如果在利用调用门调用子程序时引起特权级的转换和堆栈的改变，需要将外层堆栈中的参数复制到内层堆栈。该双字计数字段就是用于说明这种情况发生时，要复制的双字参数的数量。*/</span>
        <span class="n">u8_t</span>    <span class="n">attr</span><span class="p">;</span>           <span class="cm">/* P(1) DPL(2) DT(1) TYPE(4) */</span>
        <span class="n">u16_t</span>   <span class="n">offset_high</span><span class="p">;</span>    <span class="cm">/* 偏移的高位段 */</span>
        <span class="n">u32_t</span>   <span class="n">offset_high_h</span><span class="p">;</span>
        <span class="n">u32_t</span>   <span class="n">offset_resv</span><span class="p">;</span>
<span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">gate_t</span><span class="p">;</span>
<span class="c1">//定义中断表
</span><span class="c1"></span><span class="n">HAL_DEFGLOB_VARIABLE</span><span class="p">(</span><span class="n">gate_t</span><span class="p">,</span><span class="n">x64_idt</span><span class="p">)[</span><span class="n">IDTMAX</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><p>设置函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//vector 向量也是中断号
</span><span class="c1">//desc_type 中断门类型，中断门，陷阱门
</span><span class="c1">//handler 中断处理程序的入口地址
</span><span class="c1">//privilege 中断门的权限级别
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">set_idt_desc</span><span class="p">(</span><span class="n">u8_t</span> <span class="n">vector</span><span class="p">,</span> <span class="n">u8_t</span> <span class="n">desc_type</span><span class="p">,</span> <span class="n">inthandler_t</span> <span class="n">handler</span><span class="p">,</span> <span class="n">u8_t</span> <span class="n">privilege</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">gate_t</span> <span class="o">*</span><span class="n">p_gate</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x64_idt</span><span class="p">[</span><span class="n">vector</span><span class="p">];</span>
    <span class="n">u64_t</span> <span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64_t</span><span class="p">)</span><span class="n">handler</span><span class="p">;</span>
    <span class="n">p_gate</span><span class="o">-&gt;</span><span class="n">offset_low</span> <span class="o">=</span> <span class="n">base</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">;</span>
    <span class="n">p_gate</span><span class="o">-&gt;</span><span class="n">selector</span> <span class="o">=</span> <span class="n">SELECTOR_KERNEL_CS</span><span class="p">;</span>
    <span class="n">p_gate</span><span class="o">-&gt;</span><span class="n">dcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">p_gate</span><span class="o">-&gt;</span><span class="n">attr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8_t</span><span class="p">)(</span><span class="n">desc_type</span> <span class="o">|</span> <span class="p">(</span><span class="n">privilege</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">));</span>
    <span class="n">p_gate</span><span class="o">-&gt;</span><span class="n">offset_high</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16_t</span><span class="p">)((</span><span class="n">base</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">);</span>
    <span class="n">p_gate</span><span class="o">-&gt;</span><span class="n">offset_high_h</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32_t</span><span class="p">)((</span><span class="n">base</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffff</span><span class="p">);</span>
    <span class="n">p_gate</span><span class="o">-&gt;</span><span class="n">offset_resv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>中断处理程序负责保存CPU寄存器、调用中断程序、恢复CPU寄存器</p>
<p>保存和恢复寄存区汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="err">//保存中断后的寄存器</span>
<span class="err">%</span><span class="nf">macro</span>  <span class="no">SAVEALL</span>  <span class="mi">0</span>
  <span class="nf">push</span> <span class="no">rax</span>
  <span class="nf">push</span> <span class="no">rbx</span>
  <span class="nf">push</span> <span class="no">rcx</span>
  <span class="nf">push</span> <span class="no">rdx</span>
  <span class="nf">push</span> <span class="no">rbp</span>
  <span class="nf">push</span> <span class="no">rsi</span>
  <span class="nf">push</span> <span class="no">rdi</span>
  <span class="nf">push</span> <span class="no">r8</span>
  <span class="nf">push</span> <span class="no">r9</span>
  <span class="nf">push</span> <span class="no">r10</span>
  <span class="nf">push</span> <span class="no">r11</span>
  <span class="nf">push</span> <span class="no">r12</span>
  <span class="nf">push</span> <span class="no">r13</span>
  <span class="nf">push</span> <span class="no">r14</span>
  <span class="nf">push</span> <span class="no">r15</span>
  <span class="nf">xor</span> <span class="no">r14</span><span class="p">,</span><span class="no">r14</span>
  <span class="nf">mov</span> <span class="no">r14w</span><span class="p">,</span><span class="no">ds</span>
  <span class="nf">push</span> <span class="no">r14</span>
  <span class="nf">mov</span> <span class="no">r14w</span><span class="p">,</span><span class="no">es</span>
  <span class="nf">push</span> <span class="no">r14</span>
  <span class="nf">mov</span> <span class="no">r14w</span><span class="p">,</span><span class="no">fs</span>
  <span class="nf">push</span> <span class="no">r14</span>
  <span class="nf">mov</span> <span class="no">r14w</span><span class="p">,</span><span class="no">gs</span>
  <span class="nf">push</span> <span class="no">r14</span>
<span class="err">%</span><span class="nf">endmacro</span>
<span class="err">//恢复中断后寄存器</span>
<span class="err">%</span><span class="nf">macro</span>  <span class="no">RESTOREALL</span>  <span class="mi">0</span>
  <span class="nf">pop</span> <span class="no">r14</span>
  <span class="nf">mov</span> <span class="no">gs</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">pop</span> <span class="no">r14</span> 
  <span class="no">mov</span> <span class="no">fs</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">pop</span> <span class="no">r14</span>
  <span class="nf">mov</span> <span class="no">es</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">pop</span> <span class="no">r14</span>
  <span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">pop</span> <span class="no">r15</span>
  <span class="nf">pop</span> <span class="no">r14</span>
  <span class="nf">pop</span> <span class="no">r13</span>
  <span class="nf">pop</span> <span class="no">r12</span>
  <span class="nf">pop</span> <span class="no">r11</span>
  <span class="nf">pop</span> <span class="no">r10</span>
  <span class="nf">pop</span> <span class="no">r9</span>
  <span class="nf">pop</span> <span class="no">r8</span>
  <span class="nf">pop</span> <span class="no">rdi</span>
  <span class="nf">pop</span> <span class="no">rsi</span>
  <span class="nf">pop</span> <span class="no">rbp</span>
  <span class="nf">pop</span> <span class="no">rdx</span>
  <span class="nf">pop</span> <span class="no">rcx</span>
  <span class="nf">pop</span> <span class="no">rbx</span>
  <span class="nf">pop</span> <span class="no">rax</span>
  <span class="nf">iretq</span>
<span class="err">%</span><span class="nf">endmacro</span>
<span class="err">//保存异常下的寄存器</span>
<span class="err">%</span><span class="nf">macro</span>  <span class="no">SAVEALLFAULT</span> <span class="mi">0</span>
  <span class="nf">push</span> <span class="no">rax</span>
  <span class="nf">push</span> <span class="no">rbx</span>
  <span class="nf">push</span> <span class="no">rcx</span>
  <span class="nf">push</span> <span class="no">rdx</span>
  <span class="nf">push</span> <span class="no">rbp</span>
  <span class="nf">push</span> <span class="no">rsi</span>
  <span class="nf">push</span> <span class="no">rdi</span>
  <span class="nf">push</span> <span class="no">r8</span>
  <span class="nf">push</span> <span class="no">r9</span>
  <span class="nf">push</span> <span class="no">r10</span>
  <span class="nf">push</span> <span class="no">r11</span>
  <span class="nf">push</span> <span class="no">r12</span>
  <span class="nf">push</span> <span class="no">r13</span>
  <span class="nf">push</span> <span class="no">r14</span>
  <span class="nf">push</span> <span class="no">r15</span>
  <span class="nf">xor</span> <span class="no">r14</span><span class="p">,</span><span class="no">r14</span>
  <span class="nf">mov</span> <span class="no">r14w</span><span class="p">,</span><span class="no">ds</span>
  <span class="nf">push</span> <span class="no">r14</span>
  <span class="nf">mov</span> <span class="no">r14w</span><span class="p">,</span><span class="no">es</span>
  <span class="nf">push</span> <span class="no">r14</span>
  <span class="nf">mov</span> <span class="no">r14w</span><span class="p">,</span><span class="no">fs</span>
  <span class="nf">push</span> <span class="no">r14</span>
  <span class="nf">mov</span> <span class="no">r14w</span><span class="p">,</span><span class="no">gs</span>
  <span class="nf">push</span> <span class="no">r14</span>
<span class="err">%</span><span class="nf">endmacro</span>
<span class="err">//恢复异常下寄存器</span>
<span class="err">%</span><span class="nf">macro</span>  <span class="no">RESTOREALLFAULT</span>  <span class="mi">0</span>
  <span class="nf">pop</span> <span class="no">r14</span>
  <span class="nf">mov</span> <span class="no">gs</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">pop</span> <span class="no">r14</span> 
  <span class="no">mov</span> <span class="no">fs</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">pop</span> <span class="no">r14</span>
  <span class="nf">mov</span> <span class="no">es</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">pop</span> <span class="no">r14</span>
  <span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">pop</span> <span class="no">r15</span>
  <span class="nf">pop</span> <span class="no">r14</span>
  <span class="nf">pop</span> <span class="no">r13</span>
  <span class="nf">pop</span> <span class="no">r12</span>
  <span class="nf">pop</span> <span class="no">r11</span>
  <span class="nf">pop</span> <span class="no">r10</span>
  <span class="nf">pop</span> <span class="no">r9</span>
  <span class="nf">pop</span> <span class="no">r8</span>
  <span class="nf">pop</span> <span class="no">rdi</span>
  <span class="nf">pop</span> <span class="no">rsi</span>
  <span class="nf">pop</span> <span class="no">rbp</span>
  <span class="nf">pop</span> <span class="no">rdx</span>
  <span class="nf">pop</span> <span class="no">rcx</span>
  <span class="nf">pop</span> <span class="no">rbx</span>
  <span class="nf">pop</span> <span class="no">rax</span>
  <span class="nf">add</span> <span class="no">rsp</span><span class="p">,</span><span class="mi">8</span>
  <span class="nf">iretq</span>
<span class="err">%</span><span class="nf">endmacro</span>
<span class="err">//没有错误码</span><span class="nf">CPU异常</span>
<span class="err">%</span><span class="nf">macro</span>  <span class="no">SRFTFAULT</span> <span class="mi">1</span>
  <span class="nf">push</span>    <span class="no">_NOERRO_CODE</span>
  <span class="nf">SAVEALLFAULT</span>
  <span class="nf">mov</span> <span class="no">r14w</span><span class="p">,</span><span class="mi">0x10</span>
  <span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">mov</span> <span class="no">es</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">mov</span> <span class="no">fs</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">mov</span> <span class="no">gs</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">mov</span>   <span class="no">rdi</span><span class="p">,</span><span class="err">%</span><span class="mi">1</span> <span class="c">;rdi, rsi
</span><span class="c"></span>  <span class="no">mov</span>   <span class="no">rsi</span><span class="p">,</span><span class="no">rsp</span>
  <span class="nf">call</span>   <span class="no">hal_fault_allocator</span>
  <span class="nf">RESTOREALLFAULT</span>
<span class="err">%</span><span class="nf">endmacro</span>
<span class="err">//</span><span class="nf">CPU异常</span>
<span class="err">%</span><span class="nf">macro</span>  <span class="no">SRFTFAULT_ECODE</span> <span class="mi">1</span>
  <span class="nf">SAVEALLFAULT</span>
  <span class="nf">mov</span> <span class="no">r14w</span><span class="p">,</span><span class="mi">0x10</span>
  <span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">mov</span> <span class="no">es</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">mov</span> <span class="no">fs</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">mov</span> <span class="no">gs</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">mov</span>   <span class="no">rdi</span><span class="p">,</span><span class="err">%</span><span class="mi">1</span>
  <span class="nf">mov</span>   <span class="no">rsi</span><span class="p">,</span><span class="no">rsp</span>
  <span class="nf">call</span>   <span class="no">hal_fault_allocator</span>
  <span class="nf">RESTOREALLFAULT</span>
<span class="err">%</span><span class="nf">endmacro</span>
<span class="err">//硬件中断</span>
<span class="err">%</span><span class="nf">macro</span>  <span class="no">HARWINT</span>  <span class="mi">1</span>
  <span class="nf">SAVEALL</span>
  <span class="nf">mov</span> <span class="no">r14w</span><span class="p">,</span><span class="mi">0x10</span>
  <span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">mov</span> <span class="no">es</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">mov</span> <span class="no">fs</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">mov</span> <span class="no">gs</span><span class="p">,</span><span class="no">r14w</span>
  <span class="nf">mov</span>  <span class="no">rdi</span><span class="p">,</span> <span class="err">%</span><span class="mi">1</span>
  <span class="nf">mov</span>   <span class="no">rsi</span><span class="p">,</span><span class="no">rsp</span>
  <span class="nf">call</span>    <span class="no">hal_intpt_allocator</span>
  <span class="nf">RESTOREALL</span>
<span class="err">%</span><span class="nf">endmacro</span>


<span class="err">//除法错误异常</span> <span class="err">比如除0</span>
<span class="nl">exc_divide_error:</span>
  <span class="nf">SRFTFAULT</span> <span class="mi">0</span>
<span class="err">//单步执行异常</span>
<span class="nl">exc_single_step_exception:</span>
  <span class="nf">SRFTFAULT</span> <span class="mi">1</span>
<span class="nl">exc_nmi:</span>
  <span class="nf">SRFTFAULT</span> <span class="mi">2</span>
<span class="err">//调试断点异常</span>
<span class="nl">exc_breakpoint_exception:</span>
  <span class="nf">SRFTFAULT</span> <span class="mi">3</span>
<span class="err">//溢出异常</span>
<span class="nl">exc_overflow:</span>
  <span class="nf">SRFTFAULT</span> <span class="mi">4</span>
<span class="err">//段不存在异常</span>
<span class="nl">exc_segment_not_present:</span>
  <span class="nf">SRFTFAULT_ECODE</span> <span class="mi">11</span>
<span class="err">//栈异常</span>
<span class="nl">exc_stack_exception:</span>
  <span class="nf">SRFTFAULT_ECODE</span> <span class="mi">12</span>
<span class="err">//通用异常</span>
<span class="nl">exc_general_protection:</span>
  <span class="nf">SRFTFAULT_ECODE</span> <span class="mi">13</span>
<span class="err">//缺页异常</span>
<span class="nl">exc_page_fault:</span>
  <span class="nf">SRFTFAULT_ECODE</span> <span class="mi">14</span>
<span class="nl">hxi_exc_general_intpfault:</span>
  <span class="nf">SRFTFAULT</span> <span class="mi">256</span>
<span class="err">//硬件1～7号中断</span>
<span class="nl">hxi_hwint00:</span>
  <span class="nf">HARWINT</span>  <span class="p">(</span><span class="no">INT_VECTOR_IRQ0</span><span class="err">+</span><span class="mi">0</span><span class="p">)</span>
<span class="nl">hxi_hwint01:</span>
  <span class="nf">HARWINT</span>  <span class="p">(</span><span class="no">INT_VECTOR_IRQ0</span><span class="err">+</span><span class="mi">1</span><span class="p">)</span>
<span class="nl">hxi_hwint02:</span>
  <span class="nf">HARWINT</span>  <span class="p">(</span><span class="no">INT_VECTOR_IRQ0</span><span class="err">+</span><span class="mi">2</span><span class="p">)</span>
<span class="nl">hxi_hwint03:</span>
  <span class="nf">HARWINT</span>  <span class="p">(</span><span class="no">INT_VECTOR_IRQ0</span><span class="err">+</span><span class="mi">3</span><span class="p">)</span>
<span class="nl">hxi_hwint04:</span>
  <span class="nf">HARWINT</span>  <span class="p">(</span><span class="no">INT_VECTOR_IRQ0</span><span class="err">+</span><span class="mi">4</span><span class="p">)</span>
<span class="nl">hxi_hwint05:</span>
  <span class="nf">HARWINT</span>  <span class="p">(</span><span class="no">INT_VECTOR_IRQ0</span><span class="err">+</span><span class="mi">5</span><span class="p">)</span>
<span class="nl">hxi_hwint06:</span>
  <span class="nf">HARWINT</span>  <span class="p">(</span><span class="no">INT_VECTOR_IRQ0</span><span class="err">+</span><span class="mi">6</span><span class="p">)</span>
<span class="nl">hxi_hwint07:</span>
  <span class="nf">HARWINT</span>  <span class="p">(</span><span class="no">INT_VECTOR_IRQ0</span><span class="err">+</span><span class="mi">7</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>初始化函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">init_idt_descriptor</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">//一开始把所有中断的处理程序设置为保留的通用处理程序
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">u16_t</span> <span class="n">intindx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">intindx</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">;</span> <span class="n">intindx</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">set_idt_desc</span><span class="p">((</span><span class="n">u8_t</span><span class="p">)</span><span class="n">intindx</span><span class="p">,</span> <span class="n">DA_386IGate</span><span class="p">,</span> <span class="n">hxi_exc_general_intpfault</span><span class="p">,</span> <span class="n">PRIVILEGE_KRNL</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">set_idt_desc</span><span class="p">(</span><span class="n">INT_VECTOR_DIVIDE</span><span class="p">,</span> <span class="n">DA_386IGate</span><span class="p">,</span> <span class="n">exc_divide_error</span><span class="p">,</span> <span class="n">PRIVILEGE_KRNL</span><span class="p">);</span>
    <span class="n">set_idt_desc</span><span class="p">(</span><span class="n">INT_VECTOR_DEBUG</span><span class="p">,</span> <span class="n">DA_386IGate</span><span class="p">,</span> <span class="n">exc_single_step_exception</span><span class="p">,</span> <span class="n">PRIVILEGE_KRNL</span><span class="p">);</span>
    <span class="n">set_idt_desc</span><span class="p">(</span><span class="n">INT_VECTOR_NMI</span><span class="p">,</span> <span class="n">DA_386IGate</span><span class="p">,</span> <span class="n">exc_nmi</span><span class="p">,</span> <span class="n">PRIVILEGE_KRNL</span><span class="p">);</span>
    <span class="n">set_idt_desc</span><span class="p">(</span><span class="n">INT_VECTOR_BREAKPOINT</span><span class="p">,</span> <span class="n">DA_386IGate</span><span class="p">,</span> <span class="n">exc_breakpoint_exception</span><span class="p">,</span> <span class="n">PRIVILEGE_USER</span><span class="p">);</span>
    <span class="n">set_idt_desc</span><span class="p">(</span><span class="n">INT_VECTOR_OVERFLOW</span><span class="p">,</span> <span class="n">DA_386IGate</span><span class="p">,</span> <span class="n">exc_overflow</span><span class="p">,</span> <span class="n">PRIVILEGE_USER</span><span class="p">);</span>
<span class="c1">//篇幅所限，未全部展示
</span><span class="c1"></span>    <span class="n">set_idt_desc</span><span class="p">(</span><span class="n">INT_VECTOR_PAGE_FAULT</span><span class="p">,</span> <span class="n">DA_386IGate</span><span class="p">,</span> <span class="n">exc_page_fault</span><span class="p">,</span> <span class="n">PRIVILEGE_KRNL</span><span class="p">);</span>
    <span class="n">set_idt_desc</span><span class="p">(</span><span class="n">INT_VECTOR_IRQ0</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="n">DA_386IGate</span><span class="p">,</span> <span class="n">hxi_hwint00</span><span class="p">,</span> <span class="n">PRIVILEGE_KRNL</span><span class="p">);</span>
    <span class="n">set_idt_desc</span><span class="p">(</span><span class="n">INT_VECTOR_IRQ0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DA_386IGate</span><span class="p">,</span> <span class="n">hxi_hwint01</span><span class="p">,</span> <span class="n">PRIVILEGE_KRNL</span><span class="p">);</span>
    <span class="n">set_idt_desc</span><span class="p">(</span><span class="n">INT_VECTOR_IRQ0</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">DA_386IGate</span><span class="p">,</span> <span class="n">hxi_hwint02</span><span class="p">,</span> <span class="n">PRIVILEGE_KRNL</span><span class="p">);</span>
    <span class="n">set_idt_desc</span><span class="p">(</span><span class="n">INT_VECTOR_IRQ0</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">DA_386IGate</span><span class="p">,</span> <span class="n">hxi_hwint03</span><span class="p">,</span> <span class="n">PRIVILEGE_KRNL</span><span class="p">);</span>
    <span class="c1">//篇幅所限，未全部展示
</span><span class="c1"></span>     <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>CPU响应中断后，需要相应的分发器处理，具体的中断处理框架如下图</p>
<p><img src="/image/play_os_in_action/13_1.webp" alt="interrupt-process"></p>
<p>中断异常描述数据结构<code>intfltdsc_t</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_INTFLTDSC</span><span class="p">{</span>    
    <span class="n">spinlock_t</span>  <span class="n">i_lock</span><span class="p">;</span>    
    <span class="n">u32_t</span>       <span class="n">i_flg</span><span class="p">;</span>    
    <span class="n">u32_t</span>       <span class="n">i_stus</span><span class="p">;</span>    
    <span class="n">uint_t</span>      <span class="n">i_prity</span><span class="p">;</span>        <span class="c1">//中断优先级    
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">i_irqnr</span><span class="p">;</span>        <span class="c1">//中断号    
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">i_deep</span><span class="p">;</span>         <span class="c1">//中断嵌套深度    
</span><span class="c1"></span>    <span class="n">u64_t</span>       <span class="n">i_indx</span><span class="p">;</span>         <span class="c1">//中断计数    
</span><span class="c1"></span>    <span class="n">list_h_t</span>    <span class="n">i_serlist</span><span class="p">;</span>      <span class="c1">//也可以使用中断回调函数的方式
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">i_sernr</span><span class="p">;</span>        <span class="c1">//中断回调函数个数   
</span><span class="c1"></span>    <span class="n">list_h_t</span>    <span class="n">i_serthrdlst</span><span class="p">;</span>   <span class="c1">//中断线程链表头    
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">i_serthrdnr</span><span class="p">;</span>    <span class="c1">//中断线程个数    
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span>       <span class="n">i_onethread</span><span class="p">;</span>    <span class="c1">//只有一个中断线程时直接用指针    
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span>       <span class="n">i_rbtreeroot</span><span class="p">;</span>   <span class="c1">//如果中断线程太多则按优先级组成红黑树
</span><span class="c1"></span>    <span class="n">list_h_t</span>    <span class="n">i_serfisrlst</span><span class="p">;</span>      
    <span class="n">uint_t</span>      <span class="n">i_serfisrnr</span><span class="p">;</span>       
    <span class="kt">void</span><span class="o">*</span>       <span class="n">i_msgmpool</span><span class="p">;</span>     <span class="c1">//可能的中断消息池    
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span>       <span class="n">i_privp</span><span class="p">;</span>    
    <span class="kt">void</span><span class="o">*</span>       <span class="n">i_extp</span><span class="p">;</span>
<span class="p">}</span><span class="n">intfltdsc_t</span><span class="p">;</span>

</code></pre></td></tr></table>
</div>
</div><p>中断可以由另一个线程执行 ，也可以是一个回调函数，回调函数存放的结构体</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="nf">drvstus_t</span> <span class="p">(</span><span class="o">*</span><span class="n">intflthandle_t</span><span class="p">)(</span><span class="n">uint_t</span> <span class="n">ift_nr</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">device</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">sframe</span><span class="p">);</span> <span class="c1">//中断处理函数的指针类型
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_INTSERDSC</span><span class="p">{</span>    
    <span class="n">list_h_t</span>    <span class="n">s_list</span><span class="p">;</span>        <span class="c1">//在中断异常描述符中的链表
</span><span class="c1"></span>    <span class="n">list_h_t</span>    <span class="n">s_indevlst</span><span class="p">;</span>    <span class="c1">//在设备描述描述符中的链表
</span><span class="c1"></span>    <span class="n">u32_t</span>       <span class="n">s_flg</span><span class="p">;</span>        
    <span class="n">intfltdsc_t</span><span class="o">*</span> <span class="n">s_intfltp</span><span class="p">;</span>    <span class="c1">//指向中断异常描述符 
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span>       <span class="n">s_device</span><span class="p">;</span>      <span class="c1">//指向设备描述符
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">s_indx</span><span class="p">;</span>    
    <span class="n">intflthandle_t</span> <span class="n">s_handle</span><span class="p">;</span>   <span class="c1">//中断处理的回调函数指针
</span><span class="c1"></span><span class="p">}</span><span class="n">intserdsc_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>当内核或者设备 驱动要安装一个中断处理函数时，先申请一个<code>intserdsc_t</code>结构体，然后
把中断函数的地址写入其中，最后把结构体挂载到对应的<code>intfltdsc_t</code>中的<code>i_serfisrlst</code>链表中
由于中断信号有限，而驱动设备可以有更多，所以发生中断时，对应信号所有的处理函数会依次执行，
如果不是自己设备产生的中断，就会跳过。</p>
<p>分发器函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//中断处理函数
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">hal_do_hwint</span><span class="p">(</span><span class="n">uint_t</span> <span class="n">intnumb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">krnlsframp</span><span class="p">)</span>
<span class="p">{</span>    
    <span class="n">intfltdsc_t</span> <span class="o">*</span><span class="n">ifdscp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>    
    <span class="n">cpuflg_t</span> <span class="n">cpuflg</span><span class="p">;</span>
    <span class="c1">//根据中断号获取中断异常描述符地址    
</span><span class="c1"></span>    <span class="n">ifdscp</span> <span class="o">=</span> <span class="n">hal_retn_intfltdsc</span><span class="p">(</span><span class="n">intnumb</span><span class="p">);</span>
    <span class="c1">//对断异常描述符加锁并中断    
</span><span class="c1"></span>    <span class="n">hal_spinlock_saveflg_cli</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifdscp</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuflg</span><span class="p">);</span>    
    <span class="n">ifdscp</span><span class="o">-&gt;</span><span class="n">i_indx</span><span class="o">++</span><span class="p">;</span>    
    <span class="n">ifdscp</span><span class="o">-&gt;</span><span class="n">i_deep</span><span class="o">++</span><span class="p">;</span>
    <span class="c1">//运行中断处理的回调函数
</span><span class="c1"></span>    <span class="n">hal_run_intflthandle</span><span class="p">(</span><span class="n">intnumb</span><span class="p">,</span> <span class="n">krnlsframp</span><span class="p">);</span>    
    <span class="n">ifdscp</span><span class="o">-&gt;</span><span class="n">i_deep</span><span class="o">--</span><span class="p">;</span>
    <span class="c1">//解锁并恢复中断状态    
</span><span class="c1"></span>    <span class="n">hal_spinunlock_restflg_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ifdscp</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpuflg</span><span class="p">);</span>    
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//异常分发器
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">hal_fault_allocator</span><span class="p">(</span><span class="n">uint_t</span> <span class="n">faultnumb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">krnlsframp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//我们的异常处理回调函数也是放在中断异常描述符中的
</span><span class="c1"></span>    <span class="n">hal_do_hwint</span><span class="p">(</span><span class="n">faultnumb</span><span class="p">,</span> <span class="n">krnlsframp</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//中断分发器
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">hal_hwint_allocator</span><span class="p">(</span><span class="n">uint_t</span> <span class="n">intnumb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">krnlsframp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">hal_do_hwint</span><span class="p">(</span><span class="n">intnumb</span><span class="p">,</span> <span class="n">krnlsframp</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用回调函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">hal_run_intflthandle</span><span class="p">(</span><span class="n">uint_t</span> <span class="n">ifdnr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sframe</span><span class="p">)</span>
<span class="p">{</span>    
    <span class="n">intserdsc_t</span> <span class="o">*</span><span class="n">isdscp</span><span class="p">;</span>    
    <span class="n">list_h_t</span> <span class="o">*</span><span class="n">lst</span><span class="p">;</span>
    <span class="c1">//根据中断号获取中断异常描述符地址    
</span><span class="c1"></span>    <span class="n">intfltdsc_t</span> <span class="o">*</span><span class="n">ifdscp</span> <span class="o">=</span> <span class="n">hal_retn_intfltdsc</span><span class="p">(</span><span class="n">ifdnr</span><span class="p">);</span>
    <span class="c1">//遍历i_serlist链表    
</span><span class="c1"></span>    <span class="n">list_for_each</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ifdscp</span><span class="o">-&gt;</span><span class="n">i_serlist</span><span class="p">)</span>    
    <span class="p">{</span>   
        <span class="c1">//获取i_serlist链表上对象即intserdsc_t结构
</span><span class="c1"></span>        <span class="n">isdscp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">intserdsc_t</span><span class="p">,</span> <span class="n">s_list</span><span class="p">);</span>  
        <span class="c1">//调用中断处理回调函数      
</span><span class="c1"></span>        <span class="n">isdscp</span><span class="o">-&gt;</span><span class="n">s_handle</span><span class="p">(</span><span class="n">ifdnr</span><span class="p">,</span> <span class="n">isdscp</span><span class="o">-&gt;</span><span class="n">s_device</span><span class="p">,</span> <span class="n">sframe</span><span class="p">);</span>    
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="初始化中断控制器">初始化中断控制器</h3>
<p>中断控制器可以屏蔽或启动哪些设备，也可以设定设备之间的优先级
x86平台最开始使用的是8259A控制器，以级联的方式存在，有15个信号源</p>
<p><img src="/image/play_os_in_action/13_2.webp" alt="8259A"></p>
<h1 id="第十四讲-linux初始化上">第十四讲 Linux初始化（上）</h1>
<h2 id="全局流程">全局流程</h2>
<p>机器加电后，BIOS会进行自检，然后加载引导设备中的引导扇区，在安装有Linux
操作系统的环境的引导扇区有GRUB程序，GRUB会加载Linux内核映像vmlinuz
<img src="/image/play_os_in_action/14_1.webp" alt="linux_boot1"></p>
<h2 id="从bios到grub">从BIOS到GRUB</h2>
<p>加电时，会将CS和IP寄存器设置为0XF000和0XFFF0，这个对应物理地址0XFFF0（CS左移4位+IP），
这个 地址连接了主板上的一个小 ROM芯片，这个芯片和内存有相同的访问机制和寻址方式，
只是在断电时也不会丢失数据，BIOS程序就存储在这个芯片上。</p>
<p>BIOS一开始会初始化CPU；然后检查内存，将自己的一部分复制到内存，跳转到内存中运行；
接下来枚举本地设备进行初始化，检查硬件是否损坏；
之后在内存中建立中断表和中断服程序，从0x00000~0x003ff的1KB空间构建中断表，中断表有256个条目，每个条目4字节（CS+IP寄存器），
0x00400~0x004FF的256KBk空间构建BIOSu数据区，其中在0x0e05b的地址加载了8KB大小的和中断表对应的中断服务程序。</p>
<p>当BIOS找到启动区后（设备的0盘0道1扇区，共 512字节，最后两字节为0x55和0xaa，即代表包含GRUB启动程序），将数据复制到
0x7c00起始的内存地址，然后加控制权交给了GRUB</p>
<h2 id="grub启动">GRUB启动</h2>
<p>由于GRUB程序不止512字节，所以会分多次加载。
其中有两个重要的文件，第一个是<code>boot.img</code>，
<code>boot.img</code>会被GRUB程序写到硬盘的启动区，同时在文件中的第一个位置
写入<code>core.img</code>占用的第一个扇区的区号；
第二个文件是<code>core.img</code>，<code>core.img</code>中嵌入了足够多的功能，
可以识别硬盘文件系统 、访问<code>/boot/grub</code>目录、加载启动菜单等</p>
<h2 id="详解vmlinuz文件结构">详解vmlinuz文件结构</h2>
<p><img src="/image/play_os_in_action/14_2.webp" alt="linux_vmlinuz"></p>
<h1 id="第十五讲-linux初始化下">第十五讲 Linux初始化（下）</h1>
<p><img src="/image/play_os_in_action/15_1.webp" alt="linux_start_kernel"></p>
<ol>
<li>
<p>GRUB 加载 vmlinuz 文件之后，会把控制权交给 vmlinuz 文件的 setup.bin 的部分中 _start，它会设置好栈，清空 bss，设置好 setup_header 结构，调用 16 位 main 切换到保护模式，最后跳转到 1MB 处的 vmlinux.bin 文件中。</p>
</li>
<li>
<p>从 vmlinux.bin 文件中 startup32、startup64 函数开始建立新的全局段描述符表和 MMU 页表，切换到长模式下解压 vmlinux.bin.gz。释放出 vmlinux 文件之后，由解析 elf 格式的函数进行解析，释放 vmlinux 中的代码段和数据段到指定的内存。然后调用其中的 startup_64 函数，在这个函数的最后调用 Linux 内核的第一个 C 函数。</p>
</li>
<li>
<p>Linux 内核第一个 C 函数重新设置 MMU 页表，随后便调用了最有名的 start_kernel 函数， start_kernel 函数中调用了大多数 Linux 内核功能性初始化函数，在最后调用 rest_init 函数建立了两个内核线程，在其中的 kernel_init 线程建立了第一个用户态进程。</p>
</li>
</ol>
<h1 id="第十六讲-划分土地上如何划分和组织内存">第十六讲 划分土地（上）：如何划分和组织内存</h1>
<p>由于分段模式难以映射虚拟地址空间，我们使用分页模式管理内存，每页大小为4KB</p>
<h2 id="如何表示一个页">如何表示一个页</h2>
<p><img src="/image/play_os_in_action/16_1.webp" alt="memory_page_view"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="c1">//物理地址和标志  
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_PHYADRFLGS</span>
<span class="p">{</span>
    <span class="n">u64_t</span> <span class="nl">paf_alloc</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>     <span class="c1">//分配位
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="nl">paf_shared</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>    <span class="c1">//共享位
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="nl">paf_swap</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>      <span class="c1">//交换位
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="nl">paf_cache</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>     <span class="c1">//缓存位
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="nl">paf_kmap</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>      <span class="c1">//映射位
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="nl">paf_lock</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>      <span class="c1">//锁定位
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="nl">paf_dirty</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>     <span class="c1">//脏位
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="nl">paf_busy</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>      <span class="c1">//忙位
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="nl">paf_rv2</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>       <span class="c1">//保留位
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="nl">paf_padrs</span><span class="p">:</span><span class="mi">52</span><span class="p">;</span>    <span class="c1">//页物理地址位
</span><span class="c1"></span><span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">phyadrflgs_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>页的物理地址是4KB(0x1000=2**12)对齐的，所以低12位可用作其他标志位</p>
<h2 id="内存区">内存区</h2>
<p><img src="/image/play_os_in_action/16_2.webp" alt="memory_partition"></p>
<p>将物理内存分为三个区： 硬件区、内核区和应用区</p>
<h3 id="硬件区">硬件区</h3>
<p>硬件区占用地址区间为 0~32MB，用于一些不依赖 CPU 直接和内存交换数据的硬件，如 DMA</p>
<h3 id="内核区">内核区</h3>
<p>用于内核</p>
<h3 id="应用区">应用区</h3>
<p>用于用户态程序</p>
<p>按需分配，应用用到一个页，就分配一个页，如果访问到没有和物理内存页建立映射关系的虚拟内存页，
CPU 会产生缺页中断，操作系统会非配一个物理页，并和虚拟也建好映射关系</p>
<h2 id="组织内存页">组织内存页</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c">
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_BAFHLST</span>
<span class="p">{</span>
    <span class="n">spinlock_t</span> <span class="n">af_lock</span><span class="p">;</span>    <span class="c1">//保护自身结构的自旋锁
</span><span class="c1"></span>    <span class="n">u32_t</span> <span class="n">af_stus</span><span class="p">;</span>         <span class="c1">//状态 
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">af_oder</span><span class="p">;</span>        <span class="c1">//页面数的位移量
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">af_oderpnr</span><span class="p">;</span>     <span class="c1">//oder对应的页面数比如 oder为2那就是1&lt;&lt;2=4
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">af_fobjnr</span><span class="p">;</span>      <span class="c1">//多少个空闲msadsc_t结构，即空闲页面
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">af_mobjnr</span><span class="p">;</span>      <span class="c1">//此结构的msadsc_t结构总数，即此结构总页面
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">af_alcindx</span><span class="p">;</span>     <span class="c1">//此结构的分配计数
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">af_freindx</span><span class="p">;</span>     <span class="c1">//此结构的释放计数
</span><span class="c1"></span>    <span class="n">list_h_t</span> <span class="n">af_frelst</span><span class="p">;</span>    <span class="c1">//挂载此结构的空闲msadsc_t结构
</span><span class="c1"></span>    <span class="n">list_h_t</span> <span class="n">af_alclst</span><span class="p">;</span>    <span class="c1">//挂载此结构已经分配的msadsc_t结构
</span><span class="c1"></span><span class="p">}</span><span class="n">bafhlst_t</span><span class="p">;</span>


<span class="cp">#define MDIVMER_ARR_LMAX 52
</span><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_MEMDIVMER</span>
<span class="p">{</span>
    <span class="n">spinlock_t</span> <span class="n">dm_lock</span><span class="p">;</span>      <span class="c1">//保护自身结构的自旋锁
</span><span class="c1"></span>    <span class="n">u32_t</span> <span class="n">dm_stus</span><span class="p">;</span>           <span class="c1">//状态
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">dm_divnr</span><span class="p">;</span>         <span class="c1">//内存分配次数
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">dm_mernr</span><span class="p">;</span>         <span class="c1">//内存合并次数
</span><span class="c1"></span>    <span class="n">bafhlst_t</span> <span class="n">dm_mdmlielst</span><span class="p">[</span><span class="n">MDIVMER_ARR_LMAX</span><span class="p">];</span><span class="c1">//bafhlst_t结构数组
</span><span class="c1"></span>    <span class="n">bafhlst_t</span> <span class="n">dm_onemsalst</span><span class="p">;</span>  <span class="c1">//单个的bafhlst_t结构
</span><span class="c1"></span><span class="p">}</span><span class="n">memdivmer_t</span><span class="p">;</span>

</code></pre></td></tr></table>
</div>
</div><p>dm_mdmlielst第 n个元素挂载 2 ** n  个 物理地址连续的msadsc_t 结构，</p>
<p><img src="/image/play_os_in_action/16_3.jpg" alt="memory_part"></p>
<h1 id="第十七讲-划分土地中如何实现内存页面初始化">第十七讲 划分土地（中）：如何实现内存页面初始化</h1>
<h2 id="内存页结构初始化">内存页结构初始化</h2>
<h2 id="内存区结构构初始化">内存区结构构初始化</h2>
<h2 id="处理内存占用">处理内存占用</h2>
<h2 id="合并内存页到内存区">合并内存页到内存区</h2>
<h2 id="虚实地址映射">虚实地址映射</h2>
<h1 id="第十八讲-划分土地下如何实现内存页的分配和释放">第十八讲 划分土地（下）：如何实现内存页的分配和释放</h1>
<h2 id="内存页的分配">内存页的分配</h2>
<p>比如现在我们要分配一个页面，这个算法将执行如下步骤：</p>
<ol>
<li>根据一个页面的请求，会返回 m_mdmlielst 数组中的第 0 个 bafhlst_t 结构。</li>
<li>如果第 0 个 bafhlst_t 结构中有 msadsc_t 结构就直接返回，若没有 msadsc_t 结构，就会继续查找 m_mdmlielst 数组中的第 1 个 bafhlst_t 结构。</li>
<li>如果第 1 个 bafhlst_t 结构中也没有 msadsc_t 结构，就会继续查找 m_mdmlielst 数组中的第 2 个 bafhlst_t 结构。</li>
<li>如果第 2 个 bafhlst_t 结构中有 msadsc_t 结构，记住第 2 个 bafhlst_t 结构中对应是 4 个连续的 msadsc_t 结构。这时让这 4 个连续的 msadsc_t 结构从第 2 个 bafhlst_t 结构中脱离。</li>
<li>把这 4 个连续的 msadsc_t 结构，对半分割成 2 个双 msadsc_t 结构，把其中一个双 msadsc_t 结构挂载到第 1 个 bafhlst_t 结构中。</li>
<li>把剩下一个双 msadsc_t 结构，继续对半分割成两个单 msadsc_t 结构，把其中一个单 msadsc_t 结构挂载到第 0 个 bafhlst_t 结构中，剩下一个单 msadsc_t 结构返回给请求者，完成内存分配。</li>
</ol>
<p><img src="/image/play_os_in_action/18_1.webp" alt="memory_divide"></p>
<h2 id="内存页的释放">内存页的释放</h2>
<p>比如现在我们要释放一个页面，这个算法将执行如下步骤。</p>
<ol>
<li>释放一个页面，会返回 m_mdmlielst 数组中的第 0 个 bafhlst_t 结构。</li>
<li>设置这个页面对应的 msadsc_t 结构的相关信息，表示已经执行了释放操作。</li>
<li>开始查看第 0 个 bafhlst_t 结构中有没有空闲的 msadsc_t，并且它和要释放的 msadsc_t 对应的物理地址是连续的。没有则把这个释放的 msadsc_t 挂载第 0 个 bafhlst_t 结构中，算法结束，否则进入下一步。</li>
<li>把第 0 个 bafhlst_t 结构中的 msadsc_t 结构拿出来与释放的 msadsc_t 结构，合并成 2 个连续且更大的 msadsc_t。</li>
<li>继续查看第 1 个 bafhlst_t 结构中有没有空闲的 msadsc_t，而且这个空闲 msadsc_t 要和上一步合并的 2 个 msadsc_t 对应的物理地址是连续的。没有则把这个合并的 2 个 msadsc_t 挂载第 1 个 bafhlst_t 结构中，算法结束，否则进入下一步。</li>
<li>把第 1 个 bafhlst_t 结构中的 2 个连续的 msadsc_t 结构，还有合并的 2 个地址连续的 msadsc_t 结构拿出来，合并成 4 个连续且更大的 msadsc_t 结构。</li>
<li>继续查看第 2 个 bafhlst_t 结构，有没有空闲的 msadsc_t 结构，并且它要和上一步合并的 4 个 msadsc_t 结构对应的物理地址是连续的。没有则把这个合并的 4 个 msadsc_t 挂载第 2 个 bafhlst_t 结构中，算法结束。</li>
</ol>
<p><img src="/image/play_os_in_action/18_2.webp" alt="memory_recollect"></p>
<h1 id="第十九讲-如何管理内存对象">第十九讲 如何管理内存对象</h1>
<h1 id="第二十讲-如何表示虚拟内存">第二十讲 如何表示虚拟内存</h1>
<h2 id="空间划分">空间划分</h2>
<h3 id="x86">x86</h3>
<p><img src="/image/play_os_in_action/20_1.webp" alt="x86_virtual_mem"></p>
<p>长模式下地址分成了三段，CPU目前只实现了 48位地址空间，高16位要么全是0，要么全是1</p>
<h1 id="第二十一讲-如何分配和释放虚拟内存">第二十一讲 如何分配和释放虚拟内存</h1>
<h1 id="第二十二讲-linux伙伴系统">第二十二讲 Linux伙伴系统</h1>
<p>Linux使用伙伴系统来管理物理内存页面</p>
<h2 id="如何表示一个页-1">如何表示一个页</h2>
<p>早期 Linux 使用位图，后来使用字节数组，目前使用 page 结构体表示</p>
<h2 id="如何表示一个区">如何表示一个区</h2>
<p>属性相同的物理内存页，归结到同一个区</p>
<p>可使用 <code>cat /proc/zoneinfo | grep  None</code> 查看分区</p>
<p>Linux 使用 zone 结构体表示一个区，其中 <code>free_area[MAX_ORDER]</code>结构体数组分别
表示挂载地址连续的 pages, 可能的数量为 1, 2, 4, &hellip;, 1024</p>
<h2 id="如何表示一个内存节点">如何表示一个内存节点</h2>
<p>在多核服务器中，每个核都会有自己的本地内存，访问自己的本地内存比较快，
访问其他核的本地内存就比较慢，这个结构称之为 Non-Uniform Memory Access (NUMA)</p>
<p><img src="/image/play_os_in_action/22_1.webp" alt="Non-Uniform Memory Access"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="k">enum</span> <span class="p">{</span>
    <span class="n">ZONELIST_FALLBACK</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_NUMA
</span><span class="cp"></span>    <span class="n">ZONELIST_NOFALLBACK</span><span class="p">,</span>
<span class="cp">#endif
</span><span class="cp"></span>    <span class="n">MAX_ZONELISTS</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">zoneref</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span><span class="p">;</span><span class="c1">//内存区指针
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">zone_idx</span><span class="p">;</span>     <span class="c1">//内存区对应的索引
</span><span class="c1"></span><span class="p">};</span>
<span class="k">struct</span> <span class="n">zonelist</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">zoneref</span> <span class="n">_zonerefs</span><span class="p">[</span><span class="n">MAX_ZONES_PER_ZONELIST</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
<span class="c1">//zone枚举类型 从0开始
</span><span class="c1"></span><span class="k">enum</span> <span class="n">zone_type</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_ZONE_DMA
</span><span class="cp"></span>    <span class="n">ZONE_DMA</span><span class="p">,</span>
<span class="cp">#endif
</span><span class="cp">#ifdef CONFIG_ZONE_DMA32
</span><span class="cp"></span>    <span class="n">ZONE_DMA32</span><span class="p">,</span>
<span class="cp">#endif
</span><span class="cp"></span>    <span class="n">ZONE_NORMAL</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_HIGHMEM
</span><span class="cp"></span>    <span class="n">ZONE_HIGHMEM</span><span class="p">,</span>
<span class="cp">#endif
</span><span class="cp"></span>    <span class="n">ZONE_MOVABLE</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_ZONE_DEVICE
</span><span class="cp"></span>    <span class="n">ZONE_DEVICE</span><span class="p">,</span>
<span class="cp">#endif
</span><span class="cp"></span>    <span class="n">__MAX_NR_ZONES</span>

<span class="p">};</span>
<span class="c1">//定义MAX_NR_ZONES为__MAX_NR_ZONES 最大为6
</span><span class="c1"></span><span class="n">DEFINE</span><span class="p">(</span><span class="n">MAX_NR_ZONES</span><span class="p">,</span> <span class="n">__MAX_NR_ZONES</span><span class="p">);</span>
<span class="c1">//内存节点
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">pglist_data</span> <span class="p">{</span>
    <span class="c1">//定一个内存区数组，最大为6个zone元素
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">zone</span> <span class="n">node_zones</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">];</span>
    <span class="c1">//两个zonelist，一个是指向本节点的的内存区，另一个指向由本节点分配不到内存时可选的备用内存区。
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">zonelist</span> <span class="n">node_zonelists</span><span class="p">[</span><span class="n">MAX_ZONELISTS</span><span class="p">];</span>
    <span class="c1">//本节点有多少个内存区
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">nr_zones</span><span class="p">;</span> 
    <span class="c1">//本节点开始的page索引号
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_start_pfn</span><span class="p">;</span>
    <span class="c1">//本节点有多少个可用的页面 
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_present_pages</span><span class="p">;</span>
    <span class="c1">//本节点有多少个可用的页面包含内存空洞 
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_spanned_pages</span><span class="p">;</span>
    <span class="c1">//节点id
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">node_id</span><span class="p">;</span>
    <span class="c1">//交换内存页面相关的字段
</span><span class="c1"></span>    <span class="n">wait_queue_head_t</span> <span class="n">kswapd_wait</span><span class="p">;</span>
    <span class="n">wait_queue_head_t</span> <span class="n">pfmemalloc_wait</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">kswapd</span><span class="p">;</span> 
    <span class="c1">//本节点保留的内存页面
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span>       <span class="n">totalreserve_pages</span><span class="p">;</span>
    <span class="c1">//自旋锁
</span><span class="c1"></span>    <span class="n">spinlock_t</span>      <span class="n">lru_lock</span><span class="p">;</span>
<span class="p">}</span> <span class="n">pg_data_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>pglist_data 结构包含 长度为 2 的 zonelist 数组，第一个 zonelist 指向本节点内的内存区，另一个指向
其他节点内存区，以便本节点内存不足时备用</p>
<p>pglist_data、zonelist、zone、 page之间的关系如下图</p>
<p><img src="/image/play_os_in_action/22_2.webp" alt="summary"></p>
<h2 id="何为伙伴">何为伙伴</h2>
<p><img src="/image/play_os_in_action/22_3.webp" alt="buddy-relationship"></p>
<p>page(0, 1) 是伙伴， page(2, 3) 是伙伴，A 和 B 是伙伴， E 和 F 是伙伴</p>
<h2 id="页面分配流程">页面分配流程</h2>
<p>首先找到内存节点， 接着找到内存区， 然后找到合适的空闲链表 ，最后在其中找到 page, 完成物理内存分配</p>
<h1 id="第二十三讲-linux-slab分配内存">第二十三讲 Linux SLAB分配内存</h1>
<p>对于小对象，使用SLAB分配器分配</p>
<p>SLAB将一组连续的内存页划分成相同大小的块，这种块称之为 SLAB 对象，除此之外，
还有 SLAB 管理头和着色区。</p>
<p><img src="/image/play_os_in_action/23_1.jpg" alt="slab-object"></p>
<p>SLAB管理头用 kmem_cache 结构表示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">array_cache</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">avail</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">entry</span><span class="p">[];</span> 
<span class="p">};</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="p">{</span>
    <span class="c1">//是每个CPU一个array_cache类型的变量，cpu_cache是用于管理空闲对象的 
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">array_cache</span> <span class="n">__percpu</span> <span class="o">*</span><span class="n">cpu_cache</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span> <span class="c1">//cache大小
</span><span class="c1"></span>    <span class="n">slab_flags_t</span> <span class="n">flags</span><span class="p">;</span><span class="c1">//slab标志
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">;</span><span class="c1">//对象个数
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gfporder</span><span class="p">;</span><span class="c1">//分配内存页面的order
</span><span class="c1"></span>    <span class="n">gfp_t</span> <span class="n">allocflags</span><span class="p">;</span>
    <span class="n">size_t</span> <span class="n">colour</span><span class="p">;</span><span class="c1">//着色区大小
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">colour_off</span><span class="p">;</span><span class="c1">//着色区的开始偏移
</span><span class="c1"></span>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="c1">//本SLAB的名字
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span><span class="c1">//所有的SLAB都要链接起来
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">refcount</span><span class="p">;</span><span class="c1">//引用计数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">object_size</span><span class="p">;</span><span class="c1">//对象大小
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">align</span><span class="p">;</span><span class="c1">//对齐大小
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="n">node</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span><span class="c1">//指向管理kmemcache的上层结构
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>不同对象大小会有 不同 的kmem_cache，
一个kmem_cache中，每个CPU都有自己的 array_cache，entry[] 是一个 LIFO 顺序数组 ，avail 和  limit
分别指定了当前可用对象的数目和允许容纳的最大数目</p>
<p><img src="/image/play_os_in_action/23_2.webp" alt="kmem_cache"></p>
<h2 id="第一个kmem_cache">第一个kmem_cache</h2>
<p>第一个kmem_cache是静态定义在代码中的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="n">kmem_cache_boot</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">batchcount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">BOOT_CPUCACHE_ENTRIES</span><span class="p">,</span>
    <span class="p">.</span><span class="n">shared</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span><span class="p">),</span>
    <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&#34;kmem_cache&#34;</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">kmem_cache_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="c1">//指向静态定义的kmem_cache_boot
</span><span class="c1"></span>    <span class="n">kmem_cache</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">kmem_cache_boot</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_INIT_LISTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">kmem_cache_node_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_kmem_cache_node</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="c1">//建立保存kmem_cache结构的kmem_cache
</span><span class="c1"></span>    <span class="n">create_boot_cache</span><span class="p">(</span><span class="n">kmem_cache</span><span class="p">,</span> <span class="s">&#34;kmem_cache&#34;</span><span class="p">,</span>
        <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="o">+</span>
                  <span class="n">nr_node_ids</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache_node</span> <span class="o">*</span><span class="p">),</span>
                  <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">//加入全局slab_caches链表中
</span><span class="c1"></span>    <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem_cache</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slab_caches</span><span class="p">);</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">nid</span><span class="p">;</span>
        <span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">init_list</span><span class="p">(</span><span class="n">kmem_cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_kmem_cache_node</span><span class="p">[</span><span class="n">CACHE_CACHE</span> <span class="o">+</span> <span class="n">nid</span><span class="p">],</span> <span class="n">nid</span><span class="p">);</span>
            <span class="n">init_list</span><span class="p">(</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">KMALLOC_NORMAL</span><span class="p">][</span><span class="n">INDEX_NODE</span><span class="p">],</span>                      <span class="o">&amp;</span><span class="n">init_kmem_cache_node</span><span class="p">[</span><span class="n">SIZE_NODE</span> <span class="o">+</span> <span class="n">nid</span><span class="p">],</span> <span class="n">nid</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//建立kmalloc函数使用的的kmem_cache
</span><span class="c1"></span>    <span class="n">create_kmalloc_caches</span><span class="p">(</span><span class="n">ARCH_KMALLOC_FLAGS</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="管理-kmem_cache">管理 kmem_cache</h2>
<p>使用 kem_cache_node 结构体管理 kmem_cache</p>
<p><img src="/image/play_os_in_action/23_3.jpg" alt="kmem_cache_node"></p>
<h2 id="slab分配对象">SLAB分配对象</h2>
<p><img src="/image/play_os_in_action/23_4.webp" alt="kmem_cache_node"></p>
<h1 id="第二十四讲-什么是进程">第二十四讲 什么是进程</h1>
<h2 id="进程的结构">进程的结构</h2>
<p>进程是一个应用程序运行时刻的实例</p>
<p>每个进程拥有整个CPU虚拟地址空间，
空间分为两部分，上半部分是所有进程共享的内核部分，里面放着放着一份内核代码和数据，
下半部分是应用程序</p>
<p><img src="/image/play_os_in_action/24_1.webp" alt="process_structure"></p>
<p>当 CPU 在 R0 特权级别运行时，就运行在上半部分的内核空间地址，当
CPU 在 R3 特权级别运行时，就运行在下半部分的应用程序地址空间</p>
<p>各进程的虚拟地址空间是相同的，他们之间的物理空间不同，是由 MMU 页表进行隔离的</p>
<p>内核服务机制：通过挺住应用程序的代码运行，进入内核地址空间运行内核代码，然后返回结果。这个过程内核需要记录每个应用程序访问了哪些资源，通过资源描述符表示。</p>
<p><img src="/image/play_os_in_action/24_2.webp" alt="process_structure_detail"></p>
<p>上图中带 * 号的部分每个进程都独有一份</p>
<h2 id="实现进程">实现进程</h2>
<h3 id="如何表示一个进程">如何表示一个进程</h3>
<p>一个进程，通常有状态， id， 运行时间，优先级，应用程序栈，内核栈，机器上下文，资源描述符，地址空间等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_THREAD</span>
<span class="p">{</span>
    <span class="n">spinlock_t</span>  <span class="n">td_lock</span><span class="p">;</span>           <span class="c1">//进程的自旋锁
</span><span class="c1"></span>    <span class="n">list_h_t</span>    <span class="n">td_list</span><span class="p">;</span>           <span class="c1">//进程链表 
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">td_flgs</span><span class="p">;</span>           <span class="c1">//进程的标志
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">td_stus</span><span class="p">;</span>           <span class="c1">//进程的状态
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">td_cpuid</span><span class="p">;</span>          <span class="c1">//进程所在的CPU的id
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">td_id</span><span class="p">;</span>             <span class="c1">//进程的id
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">td_tick</span><span class="p">;</span>           <span class="c1">//进程运行了多少tick
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">td_privilege</span><span class="p">;</span>      <span class="c1">//进程的权限
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">td_priority</span><span class="p">;</span>       <span class="c1">//进程的优先级
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">td_runmode</span><span class="p">;</span>        <span class="c1">//进程的运行模式
</span><span class="c1"></span>    <span class="n">adr_t</span>       <span class="n">td_krlstktop</span><span class="p">;</span>      <span class="c1">//应用程序内核栈顶地址
</span><span class="c1"></span>    <span class="n">adr_t</span>       <span class="n">td_krlstkstart</span><span class="p">;</span>    <span class="c1">//应用程序内核栈开始地址
</span><span class="c1"></span>    <span class="n">adr_t</span>       <span class="n">td_usrstktop</span><span class="p">;</span>      <span class="c1">//应用程序栈顶地址
</span><span class="c1"></span>    <span class="n">adr_t</span>       <span class="n">td_usrstkstart</span><span class="p">;</span>    <span class="c1">//应用程序栈开始地址
</span><span class="c1"></span>    <span class="n">mmadrsdsc_t</span><span class="o">*</span> <span class="n">td_mmdsc</span><span class="p">;</span>         <span class="c1">//地址空间结构
</span><span class="c1"></span>    <span class="n">context_t</span>   <span class="n">td_context</span><span class="p">;</span>        <span class="c1">//机器上下文件结构
</span><span class="c1"></span>    <span class="n">objnode_t</span><span class="o">*</span>  <span class="n">td_handtbl</span><span class="p">[</span><span class="n">TD_HAND_MAX</span><span class="p">];</span><span class="c1">//打开的对象数组
</span><span class="c1"></span><span class="p">}</span><span class="n">thread_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>在 Cosmos 中，我们使用 thread_t 结构表示一个进程
进程的内核栈和应用程序栈是两块内存空间
进程的权限区分进程是用户进程还是系统进程
进程打开的文件对应的资源描述符保存在 td_handtbl 数据中</p>
<h3 id="进程的地址空间">进程的地址空间</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_MMADRSDSC</span>
<span class="p">{</span>
    <span class="n">spinlock_t</span> <span class="n">msd_lock</span><span class="p">;</span>               <span class="c1">//保护自身的自旋锁
</span><span class="c1"></span>    <span class="n">list_h_t</span> <span class="n">msd_list</span><span class="p">;</span>                 <span class="c1">//链表
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">msd_flag</span><span class="p">;</span>                   <span class="c1">//状态和标志
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">msd_stus</span><span class="p">;</span>
    <span class="n">uint_t</span> <span class="n">msd_scount</span><span class="p">;</span>                 <span class="c1">//计数，该结构可能被共享
</span><span class="c1"></span>    <span class="n">sem_t</span>  <span class="n">msd_sem</span><span class="p">;</span>                    <span class="c1">//信号量
</span><span class="c1"></span>    <span class="n">mmudsc_t</span> <span class="n">msd_mmu</span><span class="p">;</span>                  <span class="c1">//MMU页表相关的信息
</span><span class="c1"></span>    <span class="n">virmemadrs_t</span> <span class="n">msd_virmemadrs</span><span class="p">;</span>       <span class="c1">//虚拟地址空间结构
</span><span class="c1"></span>    <span class="n">adr_t</span> <span class="n">msd_stext</span><span class="p">;</span>                   <span class="c1">//应用的指令区的开始、结束地址
</span><span class="c1"></span>    <span class="n">adr_t</span> <span class="n">msd_etext</span><span class="p">;</span>
    <span class="n">adr_t</span> <span class="n">msd_sdata</span><span class="p">;</span>                   <span class="c1">//应用的数据区的开始、结束地址
</span><span class="c1"></span>    <span class="n">adr_t</span> <span class="n">msd_edata</span><span class="p">;</span>
    <span class="n">adr_t</span> <span class="n">msd_sbss</span><span class="p">;</span>                    <span class="c1">//应用初始化为0的区域开始、结束地址
</span><span class="c1"></span>    <span class="n">adr_t</span> <span class="n">msd_ebss</span><span class="p">;</span>
    <span class="n">adr_t</span> <span class="n">msd_sbrk</span><span class="p">;</span>                    <span class="c1">//应用的堆区的开始、结束地址
</span><span class="c1"></span>    <span class="n">adr_t</span> <span class="n">msd_ebrk</span><span class="p">;</span>
<span class="p">}</span><span class="n">mmadrsdsc_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 mmadrsdsc_t 结构体表示一个进程的完整的地址空间</p>
<h3 id="进程的机器上下文">进程的机器上下文</h3>
<p>机器的上下文分为两部分：CPU 寄存器；内核函数调用路径。</p>
<p>中断发生时，CPU 通用寄存器会压入内核栈中</p>
<p>进程切换函数中会保存栈寄存器的值， 用 context_t 结构体表示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_CONTEXT</span>
<span class="p">{</span>  
    <span class="n">uint_t</span>       <span class="n">ctx_nextrip</span><span class="p">;</span> <span class="c1">//保存下一次运行的地址
</span><span class="c1"></span>    <span class="n">uint_t</span>       <span class="n">ctx_nextrsp</span><span class="p">;</span> <span class="c1">//保存下一次运行时内核栈的地址 
</span><span class="c1"></span>    <span class="n">x64tss_t</span><span class="o">*</span>    <span class="n">ctx_nexttss</span><span class="p">;</span> <span class="c1">//指向tss结构
</span><span class="c1"></span><span class="p">}</span><span class="n">context_t</span><span class="p">;</span>


<span class="c1">// cosmos/hal/x86/halglobal.c
</span><span class="c1">// 每个CPU核心一个tss 
</span><span class="c1"></span><span class="n">HAL_DEFGLOB_VARIABLE</span><span class="p">(</span><span class="n">x64tss_t</span><span class="p">,</span><span class="n">x64tss</span><span class="p">)[</span><span class="n">CPUCORE_MAX</span><span class="p">];</span> 

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_X64TSS</span>
<span class="p">{</span>
    <span class="n">u32_t</span> <span class="n">reserv0</span><span class="p">;</span> <span class="c1">//保留
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">rsp0</span><span class="p">;</span>  <span class="c1">//R0特权级的栈地址
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">rsp1</span><span class="p">;</span>  <span class="c1">//R1特权级的栈地址，我们未使用
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">rsp2</span><span class="p">;</span>  <span class="c1">//R2特权级的栈地址，我们未使用
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">reserv28</span><span class="p">;</span><span class="c1">//保留
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">ist</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>  <span class="c1">//我们未使用
</span><span class="c1"></span>    <span class="n">u64_t</span> <span class="n">reserv92</span><span class="p">;</span><span class="c1">//保留
</span><span class="c1"></span>    <span class="n">u16_t</span> <span class="n">reserv100</span><span class="p">;</span><span class="c1">//保留
</span><span class="c1"></span>    <span class="n">u16_t</span> <span class="n">iobase</span><span class="p">;</span>   <span class="c1">//我们未使用
</span><span class="c1"></span><span class="p">}</span><span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">x64tss_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="建立进程">建立进程</h2>
<p>建立进程是会创建 thread_t 结构的变量实例，并建立对应的应用程序栈、内核栈和进程地址空间。</p>
<p>内核进程的的区别在于这个进程只会在内核地址空间中运行，
用户进程会多分配一个应用程序栈，除了十分内核空间页表外，多了一份用户空间页表</p>
<h1 id="第二十五讲--多进程如何调度">第二十五讲  多进程如何调度</h1>
<h2 id="管理进程">管理进程</h2>
<h3 id="进程的生命周期">进程的生命周期</h3>
<p>我们定义进程有如下状态</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#define TDSTUS_RUN 0        </span><span class="c1">//进程运行状态
</span><span class="c1"></span><span class="cp">#define TDSTUS_SLEEP 3      </span><span class="c1">//进程睡眠状态
</span><span class="c1"></span><span class="cp">#define TDSTUS_WAIT 4       </span><span class="c1">//进程等待状态
</span><span class="c1"></span><span class="cp">#define TDSTUS_NEW 5        </span><span class="c1">//进程新建状态
</span><span class="c1"></span><span class="cp">#define TDSTUS_ZOMB 6       </span><span class="c1">//进程僵死状态
</span></code></pre></td></tr></table>
</div>
</div><p>进程状态切换如下</p>
<p><img src="/image/play_os_in_action/25_1.webp" alt="process-status-transfer"></p>
<h3 id="如何组织进程">如何组织进程</h3>
<p>由于进程随时可能创建或退出，我们使用灵活的链表结构组织进程，由于进程有优先级，
我们设计每个优先级对应一个链表头</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_THRDLST</span>
<span class="p">{</span>
    <span class="n">list_h_t</span>    <span class="n">tdl_lsth</span><span class="p">;</span>                <span class="c1">//挂载进程的链表头
</span><span class="c1"></span>    <span class="n">thread_t</span><span class="o">*</span>   <span class="n">tdl_curruntd</span><span class="p">;</span>            <span class="c1">//该链表上正在运行的进程
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">tdl_nr</span><span class="p">;</span>                  <span class="c1">//该链表上进程个数
</span><span class="c1"></span><span class="p">}</span><span class="n">thrdlst_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_SCHDATA</span>
<span class="p">{</span>
    <span class="n">spinlock_t</span>  <span class="n">sda_lock</span><span class="p">;</span>                <span class="c1">//自旋锁
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">sda_cpuid</span><span class="p">;</span>               <span class="c1">//当前CPU id
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">sda_schdflgs</span><span class="p">;</span>            <span class="c1">//标志
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">sda_premptidx</span><span class="p">;</span>           <span class="c1">//进程抢占计数
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">sda_threadnr</span><span class="p">;</span>            <span class="c1">//进程数
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">sda_prityidx</span><span class="p">;</span>            <span class="c1">//当前优先级
</span><span class="c1"></span>    <span class="n">thread_t</span><span class="o">*</span>   <span class="n">sda_cpuidle</span><span class="p">;</span>             <span class="c1">//当前CPU的空转进程
</span><span class="c1"></span>    <span class="n">thread_t</span><span class="o">*</span>   <span class="n">sda_currtd</span><span class="p">;</span>              <span class="c1">//当前正在运行的进程
</span><span class="c1"></span>    <span class="n">thrdlst_t</span>   <span class="n">sda_thdlst</span><span class="p">[</span><span class="n">PRITY_MAX</span><span class="p">];</span>   <span class="c1">//进程链表数组
</span><span class="c1"></span><span class="p">}</span><span class="n">schdata_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_SCHEDCALSS</span>
<span class="p">{</span>
    <span class="n">spinlock_t</span>  <span class="n">scls_lock</span><span class="p">;</span>                <span class="c1">//自旋锁
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">scls_cpunr</span><span class="p">;</span>               <span class="c1">//CPU个数
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">scls_threadnr</span><span class="p">;</span>            <span class="c1">//系统中所有的进程数
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">scls_threadid_inc</span><span class="p">;</span>        <span class="c1">//分配进程id所用
</span><span class="c1"></span>    <span class="n">schdata_t</span>   <span class="n">scls_schda</span><span class="p">[</span><span class="n">CPUCORE_MAX</span><span class="p">];</span>  <span class="c1">//每个CPU调度数据结构
</span><span class="c1"></span><span class="p">}</span><span class="n">schedclass_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="/image/play_os_in_action/25_2.webp" alt="process-organization"></p>
<h2 id="设计进程调度器">设计进程调度器</h2>
<h3 id="进程调度器入口">进程调度器入口</h3>
<p>找到当前运行的进程和下一运行的进程，从当前进程切换到下一进程</p>
<p>为简单起见，我们选择优先级最高的进程为下一运行的进程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">krlschedul</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">thread_t</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">krlsched_retn_currthread</span><span class="p">(),</span><span class="c1">//返回当前运行进程
</span><span class="c1"></span>             <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">krlsched_select_thread</span><span class="p">();</span><span class="c1">//选择下一个运行的进程
</span><span class="c1"></span>    <span class="n">save_to_new_context</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span><span class="c1">//从当前进程切换到下一个进程
</span><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">thread_t</span> <span class="o">*</span><span class="nf">krlsched_retn_currthread</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">uint_t</span> <span class="n">cpuid</span> <span class="o">=</span> <span class="n">hal_retn_cpuid</span><span class="p">();</span>
    <span class="c1">//通过cpuid获取当前cpu的调度数据结构
</span><span class="c1"></span>    <span class="n">schdata_t</span> <span class="o">*</span><span class="n">schdap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">osschedcls</span><span class="p">.</span><span class="n">scls_schda</span><span class="p">[</span><span class="n">cpuid</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_currtd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span><span class="c1">//若调度数据结构中当前运行进程的指针为空，就出错死机
</span><span class="c1"></span>        <span class="n">hal_sysdie</span><span class="p">(</span><span class="s">&#34;schdap-&gt;sda_currtd NULL&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_currtd</span><span class="p">;</span><span class="c1">//返回当前运行的进程
</span><span class="c1"></span><span class="p">}</span>


<span class="n">thread_t</span> <span class="o">*</span><span class="nf">krlsched_select_thread</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">thread_t</span> <span class="o">*</span><span class="n">retthd</span><span class="p">,</span> <span class="o">*</span><span class="n">tdtmp</span><span class="p">;</span>
    <span class="n">cpuflg_t</span> <span class="n">cufg</span><span class="p">;</span>
    <span class="n">uint_t</span> <span class="n">cpuid</span> <span class="o">=</span> <span class="n">hal_retn_cpuid</span><span class="p">();</span>
    <span class="n">schdata_t</span> <span class="o">*</span><span class="n">schdap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">osschedcls</span><span class="p">.</span><span class="n">scls_schda</span><span class="p">[</span><span class="n">cpuid</span><span class="p">];</span>
    <span class="n">krlspinlock_cli</span><span class="p">(</span><span class="o">&amp;</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cufg</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">uint_t</span> <span class="n">pity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pity</span> <span class="o">&lt;</span> <span class="n">PRITY_MAX</span><span class="p">;</span> <span class="n">pity</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span><span class="c1">//从最高优先级开始扫描
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_thdlst</span><span class="p">[</span><span class="n">pity</span><span class="p">].</span><span class="n">tdl_nr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span><span class="c1">//若当前优先级的进程链表不为空
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">list_is_empty_careful</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_thdlst</span><span class="p">[</span><span class="n">pity</span><span class="p">].</span><span class="n">tdl_lsth</span><span class="p">))</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
            <span class="p">{</span><span class="c1">//取出当前优先级进程链表下的第一个进程
</span><span class="c1"></span>                <span class="n">tdtmp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_thdlst</span><span class="p">[</span><span class="n">pity</span><span class="p">].</span><span class="n">tdl_lsth</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">thread_t</span><span class="p">,</span> <span class="n">td_list</span><span class="p">);</span>
                <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tdtmp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span><span class="c1">//脱链
</span><span class="c1"></span>                <span class="k">if</span> <span class="p">(</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_thdlst</span><span class="p">[</span><span class="n">pity</span><span class="p">].</span><span class="n">tdl_curruntd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="p">{</span><span class="c1">//将这sda_thdlst[pity].tdl_curruntd的进程挂入链表尾
</span><span class="c1"></span>                    <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_thdlst</span><span class="p">[</span><span class="n">pity</span><span class="p">].</span><span class="n">tdl_curruntd</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_thdlst</span><span class="p">[</span><span class="n">pity</span><span class="p">].</span><span class="n">tdl_lsth</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_thdlst</span><span class="p">[</span><span class="n">pity</span><span class="p">].</span><span class="n">tdl_curruntd</span> <span class="o">=</span> <span class="n">tdtmp</span><span class="p">;</span>
                <span class="n">retthd</span> <span class="o">=</span> <span class="n">tdtmp</span><span class="p">;</span><span class="c1">//将选择的进程放入sda_thdlst[pity].tdl_curruntd中，并返回
</span><span class="c1"></span>                <span class="k">goto</span> <span class="n">return_step</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_thdlst</span><span class="p">[</span><span class="n">pity</span><span class="p">].</span><span class="n">tdl_curruntd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="p">{</span><span class="c1">//若sda_thdlst[pity].tdl_curruntd不为空就直接返回它
</span><span class="c1"></span>                <span class="n">retthd</span> <span class="o">=</span> <span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_thdlst</span><span class="p">[</span><span class="n">pity</span><span class="p">].</span><span class="n">tdl_curruntd</span><span class="p">;</span>
                <span class="k">goto</span> <span class="n">return_step</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//如果最后也没有找到进程就返回默认的空转进程
</span><span class="c1"></span>    <span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_prityidx</span> <span class="o">=</span> <span class="n">PRITY_MIN</span><span class="p">;</span>
    <span class="n">retthd</span> <span class="o">=</span> <span class="n">krlsched_retn_idlethread</span><span class="p">();</span>
<span class="nl">return_step</span><span class="p">:</span>
    <span class="c1">//解锁并返回进程
</span><span class="c1"></span>    <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cufg</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">retthd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="进程切换">进程切换</h2>
<p>假设进程 P1 调用的函数 A，接着在函数 A 中调用了函数 B，然后函数 B 调用了函数 C，
最后在函数 C 中调用了调度器函数 S，这个函数 A 到函数 S 的路径就是进程 P1 的函数调用路径</p>
<p><img src="/image/play_os_in_action/25_3.webp" alt="function_calling_road"></p>
<ol>
<li>将当前进程的通用寄存器保存到单签进程的内核栈中</li>
<li>保存 CPU 的 RSP 寄存器到当前进程的机器上下文结构中</li>
<li>读取保存在下一进程机器上下文结构中的 RSP 值，保存到 RSP 寄存器中</li>
<li>切换 MMU 页表</li>
<li>从下一个进程的内核栈中恢复通用寄存器</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">save_to_new_context</span><span class="p">(</span><span class="n">thread_t</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="n">thread_t</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span>
        <span class="s">&#34;pushfq </span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//保存当前进程的标志寄存器
</span><span class="c1"></span>        <span class="s">&#34;cli </span><span class="se">\n\t</span><span class="s">&#34;</span>  <span class="c1">//关中断
</span><span class="c1"></span>        <span class="c1">//保存当前进程的通用寄存器
</span><span class="c1"></span>        <span class="s">&#34;pushq %%rax</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushq %%rbx</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushq %%rcx</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushq %%rdx</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushq %%rbp</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushq %%rsi</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushq %%rdi</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushq %%r8</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushq %%r9</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushq %%r10</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushq %%r11</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushq %%r12</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushq %%r13</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushq %%r14</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;pushq %%r15</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="c1">//保存CPU的RSP寄存器到当前进程的机器上下文结构中
</span><span class="c1"></span>        <span class="s">&#34;movq %%rsp,%[PREV_RSP] </span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="c1">//把下一个进程的机器上下文结构中的RSP的值，写入CPU的RSP寄存器中
</span><span class="c1"></span>        <span class="s">&#34;movq %[NEXT_RSP],%%rsp </span><span class="se">\n\t</span><span class="s">&#34;</span><span class="c1">//事实上这里已经切换到下一个进程了，因为切换进程的内核栈    
</span><span class="c1"></span>        <span class="c1">//调用__to_new_context函数切换MMU页表
</span><span class="c1"></span>        <span class="s">&#34;callq __to_new_context</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="c1">//恢复下一个进程的通用寄存器
</span><span class="c1"></span>        <span class="s">&#34;popq %%r15</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popq %%r14</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popq %%r13</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popq %%r12</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popq %%r11</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popq %%r10</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popq %%r9</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popq %%r8</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popq %%rdi</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popq %%rsi</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popq %%rbp</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popq %%rdx</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popq %%rcx</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popq %%rbx</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popq %%rax</span><span class="se">\n\t</span><span class="s">&#34;</span>
        <span class="s">&#34;popfq </span><span class="se">\n\t</span><span class="s">&#34;</span>      <span class="c1">//恢复下一个进程的标志寄存器
</span><span class="c1"></span>        <span class="c1">//输出当前进程的内核栈地址
</span><span class="c1"></span>        <span class="o">:</span> <span class="p">[</span> <span class="n">PREV_RSP</span> <span class="p">]</span> <span class="s">&#34;=m&#34;</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">td_context</span><span class="p">.</span><span class="n">ctx_nextrsp</span><span class="p">)</span>
        <span class="c1">//读取下一个进程的内核栈地址
</span><span class="c1"></span>        <span class="o">:</span> <span class="p">[</span> <span class="n">NEXT_RSP</span> <span class="p">]</span> <span class="s">&#34;m&#34;</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">td_context</span><span class="p">.</span><span class="n">ctx_nextrsp</span><span class="p">),</span> <span class="s">&#34;D&#34;</span><span class="p">(</span><span class="n">next</span><span class="p">),</span> <span class="s">&#34;S&#34;</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span><span class="c1">//为调用__to_new_context函数传递参数
</span><span class="c1"></span>        <span class="o">:</span> <span class="s">&#34;memory&#34;</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="第二十六讲--如何实现进程的等待与唤醒">第二十六讲  如何实现进程的等待与唤醒</h1>
<h2 id="进程的等待和唤醒">进程的等待和唤醒</h2>
<h3 id="等待数据结构">等待数据结构</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_KWLST</span>
<span class="p">{</span>   
    <span class="n">spinlock_t</span> <span class="n">wl_lock</span><span class="p">;</span>  <span class="c1">//自旋锁
</span><span class="c1"></span>    <span class="n">uint_t</span>   <span class="n">wl_tdnr</span><span class="p">;</span>    <span class="c1">//等待进程的个数
</span><span class="c1"></span>    <span class="n">list_h_t</span> <span class="n">wl_list</span><span class="p">;</span>    <span class="c1">//挂载等待进程的链表头
</span><span class="c1"></span><span class="p">}</span><span class="n">kwlst_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="进程等待">进程等待</h3>
<p>设置进程状态为等待状态，从调度系统数据结构中脱离，然后加入到 kwlst_t 等待结构中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">krlsched_wait</span><span class="p">(</span><span class="n">kwlst_t</span> <span class="o">*</span><span class="n">wlst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cpuflg_t</span> <span class="n">cufg</span><span class="p">,</span> <span class="n">tcufg</span><span class="p">;</span>
    <span class="n">uint_t</span> <span class="n">cpuid</span> <span class="o">=</span> <span class="n">hal_retn_cpuid</span><span class="p">();</span>
    <span class="n">schdata_t</span> <span class="o">*</span><span class="n">schdap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">osschedcls</span><span class="p">.</span><span class="n">scls_schda</span><span class="p">[</span><span class="n">cpuid</span><span class="p">];</span>
    <span class="c1">//获取当前正在运行的进程
</span><span class="c1"></span>    <span class="n">thread_t</span> <span class="o">*</span><span class="n">tdp</span> <span class="o">=</span> <span class="n">krlsched_retn_currthread</span><span class="p">();</span>
    <span class="n">uint_t</span> <span class="n">pity</span> <span class="o">=</span> <span class="n">tdp</span><span class="o">-&gt;</span><span class="n">td_priority</span><span class="p">;</span>
    <span class="n">krlspinlock_cli</span><span class="p">(</span><span class="o">&amp;</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cufg</span><span class="p">);</span>
    <span class="n">krlspinlock_cli</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tdp</span><span class="o">-&gt;</span><span class="n">td_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcufg</span><span class="p">);</span>
    <span class="n">tdp</span><span class="o">-&gt;</span><span class="n">td_stus</span> <span class="o">=</span> <span class="n">TDSTUS_WAIT</span><span class="p">;</span><span class="c1">//设置进程状态为等待状态
</span><span class="c1"></span>    <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tdp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">);</span><span class="c1">//脱链
</span><span class="c1"></span>    <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tdp</span><span class="o">-&gt;</span><span class="n">td_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcufg</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_thdlst</span><span class="p">[</span><span class="n">pity</span><span class="p">].</span><span class="n">tdl_curruntd</span> <span class="o">==</span> <span class="n">tdp</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_thdlst</span><span class="p">[</span><span class="n">pity</span><span class="p">].</span><span class="n">tdl_curruntd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_thdlst</span><span class="p">[</span><span class="n">pity</span><span class="p">].</span><span class="n">tdl_nr</span><span class="o">--</span><span class="p">;</span>
    <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cufg</span><span class="p">);</span>
    <span class="n">krlwlst_add_thread</span><span class="p">(</span><span class="n">wlst</span><span class="p">,</span> <span class="n">tdp</span><span class="p">);</span><span class="c1">//将进程加入等待结构中
</span><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="进程唤醒">进程唤醒</h3>
<p>从等待数据结构中获取进程，设置状态为运行状态，最后加到到进程调度数据结构中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">krlsched_up</span><span class="p">(</span><span class="n">kwlst_t</span> <span class="o">*</span><span class="n">wlst</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cpuflg_t</span> <span class="n">cufg</span><span class="p">,</span> <span class="n">tcufg</span><span class="p">;</span>
    <span class="n">uint_t</span> <span class="n">cpuid</span> <span class="o">=</span> <span class="n">hal_retn_cpuid</span><span class="p">();</span>
    <span class="n">schdata_t</span> <span class="o">*</span><span class="n">schdap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">osschedcls</span><span class="p">.</span><span class="n">scls_schda</span><span class="p">[</span><span class="n">cpuid</span><span class="p">];</span>
    <span class="n">thread_t</span> <span class="o">*</span><span class="n">tdp</span><span class="p">;</span>
    <span class="n">uint_t</span> <span class="n">pity</span><span class="p">;</span>
    <span class="c1">//取出等待数据结构第一个进程并从等待数据结构中删除
</span><span class="c1"></span>    <span class="n">tdp</span> <span class="o">=</span> <span class="n">krlwlst_del_thread</span><span class="p">(</span><span class="n">wlst</span><span class="p">);</span>
    <span class="n">pity</span> <span class="o">=</span> <span class="n">tdp</span><span class="o">-&gt;</span><span class="n">td_priority</span><span class="p">;</span><span class="c1">//获取进程的优先级
</span><span class="c1"></span>    <span class="n">krlspinlock_cli</span><span class="p">(</span><span class="o">&amp;</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cufg</span><span class="p">);</span>
    <span class="n">krlspinlock_cli</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tdp</span><span class="o">-&gt;</span><span class="n">td_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcufg</span><span class="p">);</span>
    <span class="n">tdp</span><span class="o">-&gt;</span><span class="n">td_stus</span> <span class="o">=</span> <span class="n">TDSTUS_RUN</span><span class="p">;</span><span class="c1">//设置进程的状态为运行状态
</span><span class="c1"></span>    <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tdp</span><span class="o">-&gt;</span><span class="n">td_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcufg</span><span class="p">);</span>
    <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tdp</span><span class="o">-&gt;</span><span class="n">td_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_thdlst</span><span class="p">[</span><span class="n">pity</span><span class="p">].</span><span class="n">tdl_lsth</span><span class="p">));</span><span class="c1">//加入进程优先级链表
</span><span class="c1"></span>    <span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_thdlst</span><span class="p">[</span><span class="n">pity</span><span class="p">].</span><span class="n">tdl_nr</span><span class="o">++</span><span class="p">;</span>
    <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cufg</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="空转进程">空转进程</h2>
<p>当没有任何进程可以调度的时候，需要调度空转进程来运行</p>
<h3 id="建立空转进程">建立空转进程</h3>
<p>空转进程是一个内核进程，不加入调度系统，使用一个专门的指针指向它</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span><span class="lnt">99
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="n">thread_t</span> <span class="o">*</span><span class="nf">new_cpuidle_thread</span><span class="p">()</span>
<span class="p">{</span>

    <span class="n">thread_t</span> <span class="o">*</span><span class="n">ret_td</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">bool_t</span> <span class="n">acs</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="n">adr_t</span> <span class="n">krlstkadr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">uint_t</span> <span class="n">cpuid</span> <span class="o">=</span> <span class="n">hal_retn_cpuid</span><span class="p">();</span>
    <span class="n">schdata_t</span> <span class="o">*</span><span class="n">schdap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">osschedcls</span><span class="p">.</span><span class="n">scls_schda</span><span class="p">[</span><span class="n">cpuid</span><span class="p">];</span>
    <span class="n">krlstkadr</span> <span class="o">=</span> <span class="n">krlnew</span><span class="p">(</span><span class="n">DAFT_TDKRLSTKSZ</span><span class="p">);</span><span class="c1">//分配进程的内核栈
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">krlstkadr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//分配thread_t结构体变量
</span><span class="c1"></span>    <span class="n">ret_td</span> <span class="o">=</span> <span class="n">krlnew_thread_dsc</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret_td</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">acs</span> <span class="o">=</span> <span class="n">krldelete</span><span class="p">(</span><span class="n">krlstkadr</span><span class="p">,</span> <span class="n">DAFT_TDKRLSTKSZ</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">acs</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//设置进程具有系统权限
</span><span class="c1"></span>    <span class="n">ret_td</span><span class="o">-&gt;</span><span class="n">td_privilege</span> <span class="o">=</span> <span class="n">PRILG_SYS</span><span class="p">;</span>
    <span class="n">ret_td</span><span class="o">-&gt;</span><span class="n">td_priority</span> <span class="o">=</span> <span class="n">PRITY_MIN</span><span class="p">;</span>
    <span class="c1">//设置进程的内核栈顶和内核栈开始地址
</span><span class="c1"></span>    <span class="n">ret_td</span><span class="o">-&gt;</span><span class="n">td_krlstktop</span> <span class="o">=</span> <span class="n">krlstkadr</span> <span class="o">+</span> <span class="p">(</span><span class="n">adr_t</span><span class="p">)(</span><span class="n">DAFT_TDKRLSTKSZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">ret_td</span><span class="o">-&gt;</span><span class="n">td_krlstkstart</span> <span class="o">=</span> <span class="n">krlstkadr</span><span class="p">;</span>
    <span class="c1">//初始化进程的内核栈
</span><span class="c1"></span>    <span class="n">krlthread_kernstack_init</span><span class="p">(</span><span class="n">ret_td</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">krlcpuidle_main</span><span class="p">,</span> <span class="n">KMOD_EFLAGS</span><span class="p">);</span>
    <span class="c1">//设置调度系统数据结构的空转进程和当前进程为ret_td
</span><span class="c1"></span>    <span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_cpuidle</span> <span class="o">=</span> <span class="n">ret_td</span><span class="p">;</span>
    <span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_currtd</span> <span class="o">=</span> <span class="n">ret_td</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ret_td</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//新建空转进程
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">new_cpuidle</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">thread_t</span> <span class="o">*</span><span class="n">thp</span> <span class="o">=</span> <span class="n">new_cpuidle_thread</span><span class="p">();</span><span class="c1">//建立空转进程
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">thp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span><span class="c1">//失败则主动死机
</span><span class="c1"></span>        <span class="n">hal_sysdie</span><span class="p">(</span><span class="s">&#34;newcpuilde err&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">kprint</span><span class="p">(</span><span class="s">&#34;CPUIDLETASK: %x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="n">uint_t</span><span class="p">)</span><span class="n">thp</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="n">thread_t</span> <span class="o">*</span><span class="nf">new_cpuidle_thread</span><span class="p">()</span>
<span class="p">{</span>

    <span class="n">thread_t</span> <span class="o">*</span><span class="n">ret_td</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">bool_t</span> <span class="n">acs</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="n">adr_t</span> <span class="n">krlstkadr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">uint_t</span> <span class="n">cpuid</span> <span class="o">=</span> <span class="n">hal_retn_cpuid</span><span class="p">();</span>
    <span class="n">schdata_t</span> <span class="o">*</span><span class="n">schdap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">osschedcls</span><span class="p">.</span><span class="n">scls_schda</span><span class="p">[</span><span class="n">cpuid</span><span class="p">];</span>
    <span class="n">krlstkadr</span> <span class="o">=</span> <span class="n">krlnew</span><span class="p">(</span><span class="n">DAFT_TDKRLSTKSZ</span><span class="p">);</span><span class="c1">//分配进程的内核栈
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">krlstkadr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//分配thread_t结构体变量
</span><span class="c1"></span>    <span class="n">ret_td</span> <span class="o">=</span> <span class="n">krlnew_thread_dsc</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret_td</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">acs</span> <span class="o">=</span> <span class="n">krldelete</span><span class="p">(</span><span class="n">krlstkadr</span><span class="p">,</span> <span class="n">DAFT_TDKRLSTKSZ</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">acs</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//设置进程具有系统权限
</span><span class="c1"></span>    <span class="n">ret_td</span><span class="o">-&gt;</span><span class="n">td_privilege</span> <span class="o">=</span> <span class="n">PRILG_SYS</span><span class="p">;</span>
    <span class="n">ret_td</span><span class="o">-&gt;</span><span class="n">td_priority</span> <span class="o">=</span> <span class="n">PRITY_MIN</span><span class="p">;</span>
    <span class="c1">//设置进程的内核栈顶和内核栈开始地址
</span><span class="c1"></span>    <span class="n">ret_td</span><span class="o">-&gt;</span><span class="n">td_krlstktop</span> <span class="o">=</span> <span class="n">krlstkadr</span> <span class="o">+</span> <span class="p">(</span><span class="n">adr_t</span><span class="p">)(</span><span class="n">DAFT_TDKRLSTKSZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">ret_td</span><span class="o">-&gt;</span><span class="n">td_krlstkstart</span> <span class="o">=</span> <span class="n">krlstkadr</span><span class="p">;</span>
    <span class="c1">//初始化进程的内核栈
</span><span class="c1"></span>    <span class="n">krlthread_kernstack_init</span><span class="p">(</span><span class="n">ret_td</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">krlcpuidle_main</span><span class="p">,</span> <span class="n">KMOD_EFLAGS</span><span class="p">);</span>
    <span class="c1">//设置调度系统数据结构的空转进程和当前进程为ret_td
</span><span class="c1"></span>    <span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_cpuidle</span> <span class="o">=</span> <span class="n">ret_td</span><span class="p">;</span>
    <span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_currtd</span> <span class="o">=</span> <span class="n">ret_td</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ret_td</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//新建空转进程
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">new_cpuidle</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">thread_t</span> <span class="o">*</span><span class="n">thp</span> <span class="o">=</span> <span class="n">new_cpuidle_thread</span><span class="p">();</span><span class="c1">//建立空转进程
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">thp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span><span class="c1">//失败则主动死机
</span><span class="c1"></span>        <span class="n">hal_sysdie</span><span class="p">(</span><span class="s">&#34;newcpuilde err&#34;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">kprint</span><span class="p">(</span><span class="s">&#34;CPUIDLETASK: %x</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="p">(</span><span class="n">uint_t</span><span class="p">)</span><span class="n">thp</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="空转进程运行">空转进程运行</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">krlcpuidle_start</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">uint_t</span> <span class="n">cpuid</span> <span class="o">=</span> <span class="n">hal_retn_cpuid</span><span class="p">();</span>
    <span class="n">schdata_t</span> <span class="o">*</span><span class="n">schdap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">osschedcls</span><span class="p">.</span><span class="n">scls_schda</span><span class="p">[</span><span class="n">cpuid</span><span class="p">];</span>
    <span class="c1">//取得空转进程
</span><span class="c1"></span>    <span class="n">thread_t</span> <span class="o">*</span><span class="n">tdp</span> <span class="o">=</span> <span class="n">schdap</span><span class="o">-&gt;</span><span class="n">sda_cpuidle</span><span class="p">;</span>
    <span class="c1">//设置空转进程的tss和R0特权级的栈
</span><span class="c1"></span>    <span class="n">tdp</span><span class="o">-&gt;</span><span class="n">td_context</span><span class="p">.</span><span class="n">ctx_nexttss</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x64tss</span><span class="p">[</span><span class="n">cpuid</span><span class="p">];</span>
    <span class="n">tdp</span><span class="o">-&gt;</span><span class="n">td_context</span><span class="p">.</span><span class="n">ctx_nexttss</span><span class="o">-&gt;</span><span class="n">rsp0</span> <span class="o">=</span> <span class="n">tdp</span><span class="o">-&gt;</span><span class="n">td_krlstktop</span><span class="p">;</span>
    <span class="c1">//设置空转进程的状态为运行状态
</span><span class="c1"></span>    <span class="n">tdp</span><span class="o">-&gt;</span><span class="n">td_stus</span> <span class="o">=</span> <span class="n">TDSTUS_RUN</span><span class="p">;</span>
    <span class="c1">//启动进程运行
</span><span class="c1"></span>    <span class="n">retnfrom_first_sched</span><span class="p">(</span><span class="n">tdp</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="第二十七讲--linux如何实现进程和进程调度">第二十七讲  Linux如何实现进程和进程调度</h1>
<h2 id="进程">进程</h2>
<h3 id="进程数据结构">进程数据结构</h3>
<p>使用 task_struct 表示一个运行中的应用程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">thread_info</span> <span class="n">thread_info</span><span class="p">;</span><span class="c1">//处理器特有数据 
</span><span class="c1"></span>    <span class="k">volatile</span> <span class="kt">long</span>   <span class="n">state</span><span class="p">;</span>       <span class="c1">//进程状态 
</span><span class="c1"></span>    <span class="kt">void</span>            <span class="o">*</span><span class="n">stack</span><span class="p">;</span>      <span class="c1">//进程内核栈地址 
</span><span class="c1"></span>    <span class="n">refcount_t</span>      <span class="n">usage</span><span class="p">;</span>       <span class="c1">//进程使用计数
</span><span class="c1"></span>    <span class="kt">int</span>             <span class="n">on_rq</span><span class="p">;</span>       <span class="c1">//进程是否在运行队列上
</span><span class="c1"></span>    <span class="kt">int</span>             <span class="n">prio</span><span class="p">;</span>        <span class="c1">//动态优先级
</span><span class="c1"></span>    <span class="kt">int</span>             <span class="n">static_prio</span><span class="p">;</span> <span class="c1">//静态优先级
</span><span class="c1"></span>    <span class="kt">int</span>             <span class="n">normal_prio</span><span class="p">;</span> <span class="c1">//取决于静态优先级和调度策略
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span>    <span class="n">rt_priority</span><span class="p">;</span> <span class="c1">//实时优先级
</span><span class="c1"></span>    <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span>    <span class="o">*</span><span class="n">sched_class</span><span class="p">;</span><span class="c1">//指向其所在的调度类
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">sched_entity</span>         <span class="n">se</span><span class="p">;</span><span class="c1">//普通进程的调度实体
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">sched_rt_entity</span>      <span class="n">rt</span><span class="p">;</span><span class="c1">//实时进程的调度实体
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">sched_dl_entity</span>      <span class="n">dl</span><span class="p">;</span><span class="c1">//采用EDF算法调度实时进程的调度实体
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">sched_info</span>       <span class="n">sched_info</span><span class="p">;</span><span class="c1">//用于调度器统计进程的运行信息 
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span>        <span class="n">tasks</span><span class="p">;</span><span class="c1">//所有进程的链表
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">mm_struct</span>        <span class="o">*</span><span class="n">mm</span><span class="p">;</span>  <span class="c1">//指向进程内存结构
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">mm_struct</span>        <span class="o">*</span><span class="n">active_mm</span><span class="p">;</span>
    <span class="n">pid_t</span>               <span class="n">pid</span><span class="p">;</span>            <span class="c1">//进程id
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">task_struct</span> <span class="n">__rcu</span>    <span class="o">*</span><span class="n">parent</span><span class="p">;</span><span class="c1">//指向其父进程
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span>        <span class="n">children</span><span class="p">;</span> <span class="c1">//链表中的所有元素都是它的子进程
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span>        <span class="n">sibling</span><span class="p">;</span>  <span class="c1">//用于把当前进程插入到兄弟链表中
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">task_struct</span>      <span class="o">*</span><span class="n">group_leader</span><span class="p">;</span><span class="c1">//指向其所在进程组的领头进程
</span><span class="c1"></span>    <span class="n">u64</span>             <span class="n">utime</span><span class="p">;</span>   <span class="c1">//用于记录进程在用户态下所经过的节拍数
</span><span class="c1"></span>    <span class="n">u64</span>             <span class="n">stime</span><span class="p">;</span>   <span class="c1">//用于记录进程在内核态下所经过的节拍数
</span><span class="c1"></span>    <span class="n">u64</span>             <span class="n">gtime</span><span class="p">;</span>   <span class="c1">//用于记录作为虚拟机进程所经过的节拍数
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">min_flt</span><span class="p">;</span><span class="c1">//缺页统计 
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">maj_flt</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">fs_struct</span>        <span class="o">*</span><span class="n">fs</span><span class="p">;</span>    <span class="c1">//进程相关的文件系统信息
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">files_struct</span>     <span class="o">*</span><span class="n">files</span><span class="p">;</span><span class="c1">//进程打开的所有文件
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">vm_struct</span>        <span class="o">*</span><span class="n">stack_vm_area</span><span class="p">;</span><span class="c1">//内核栈的内存区
</span><span class="c1"></span>  <span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="创建-task_struct-实例">创建 task_struct 实例</h3>
<p>早期 task_struct 结构和内核栈放在一起，首先分配两个连续的页面
作为进程的内核栈，再把 task_struct 结构体实例放在栈底。
将 RSP 寄存器的值低 13 位清零，就可以得到实例地址</p>
<p><img src="/image/play_os_in_action/27_1.webp" alt="task_struct1"></p>
<p>后期随着 task_struct 结构体 越来越大，和内核栈分开了，使用 stack 字段指向内核栈地址</p>
<h3 id="进程地址空间">进程地址空间</h3>
<p>进程地址空间使用 mm_struct 结构表示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">mm_struct</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">mmap</span><span class="p">;</span> <span class="c1">//虚拟地址区间链表VMAs
</span><span class="c1"></span>        <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">mm_rb</span><span class="p">;</span>   <span class="c1">//组织vm_area_struct结构的红黑树的根
</span><span class="c1"></span>        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">task_size</span><span class="p">;</span>    <span class="c1">//进程虚拟地址空间大小
</span><span class="c1"></span>        <span class="n">pgd_t</span> <span class="o">*</span> <span class="n">pgd</span><span class="p">;</span>        <span class="c1">//指向MMU页表
</span><span class="c1"></span>        <span class="n">atomic_t</span> <span class="n">mm_users</span><span class="p">;</span> <span class="c1">//多个进程共享这个mm_struct
</span><span class="c1"></span>        <span class="n">atomic_t</span> <span class="n">mm_count</span><span class="p">;</span> <span class="c1">//mm_struct结构本身计数 
</span><span class="c1"></span>        <span class="n">atomic_long_t</span> <span class="n">pgtables_bytes</span><span class="p">;</span><span class="c1">//页表占用了多个页
</span><span class="c1"></span>        <span class="kt">int</span> <span class="n">map_count</span><span class="p">;</span>      <span class="c1">//多少个VMA
</span><span class="c1"></span>        <span class="n">spinlock_t</span> <span class="n">page_table_lock</span><span class="p">;</span> <span class="c1">//保护页表的自旋锁
</span><span class="c1"></span>        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">mmlist</span><span class="p">;</span> <span class="c1">//挂入mm_struct结构的链表
</span><span class="c1"></span>        <span class="c1">//进程应用程序代码开始、结束地址，应用程序数据的开始、结束地址 
</span><span class="c1"></span>        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_code</span><span class="p">,</span> <span class="n">end_code</span><span class="p">,</span> <span class="n">start_data</span><span class="p">,</span> <span class="n">end_data</span><span class="p">;</span>
        <span class="c1">//进程应用程序堆区的开始、当前地址、栈开始地址 
</span><span class="c1"></span>        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_brk</span><span class="p">,</span> <span class="n">brk</span><span class="p">,</span> <span class="n">start_stack</span><span class="p">;</span>
        <span class="c1">//进程应用程序参数区开始、结束地址
</span><span class="c1"></span>        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg_start</span><span class="p">,</span> <span class="n">arg_end</span><span class="p">,</span> <span class="n">env_start</span><span class="p">,</span> <span class="n">env_end</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="进程文件表">进程文件表</h3>
<p>进程打开的文件表使用 files_struct 结构表示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">files_struct</span> <span class="p">{</span>
 
    <span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span><span class="c1">//自动计数
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">fdtable</span> <span class="n">__rcu</span> <span class="o">*</span><span class="n">fdt</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">fdtable</span> <span class="n">fdtab</span><span class="p">;</span>
    <span class="n">spinlock_t</span> <span class="n">file_lock</span><span class="p">;</span> <span class="c1">//自旋锁
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_fd</span><span class="p">;</span><span class="c1">//下一个文件句柄
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">close_on_exec_init</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="c1">//执行exec()时要关闭的文件句柄
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">open_fds_init</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">full_fds_bits_init</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">file</span> <span class="n">__rcu</span> <span class="o">*</span> <span class="n">fd_array</span><span class="p">[</span><span class="n">NR_OPEN_DEFAULT</span><span class="p">];</span><span class="c1">//默认情况下打开文件的指针数组
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>当使用如 <code>int fd = open(&quot;/tmp/test.txt&quot;)</code> 打开一个文件时，会建立一个 <code>struct file</code>实例与之对应，并加入 fd_array 数组中</p>
<p>Linux在新建一个进程时，会复制当前进程的files_struct结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_files</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">oldf</span><span class="p">,</span> <span class="o">*</span><span class="n">newf</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">oldf</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span><span class="c1">//获取当前进程的files_struct的指针
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oldf</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>


    <span class="k">if</span> <span class="p">(</span><span class="n">clone_flags</span> <span class="o">&amp;</span> <span class="n">CLONE_FILES</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oldf</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//分配新files_struct结构的实例变量，并复制当前的files_struct结构
</span><span class="c1"></span>    <span class="n">newf</span> <span class="o">=</span> <span class="n">dup_fd</span><span class="p">(</span><span class="n">oldf</span><span class="p">,</span> <span class="n">NR_OPEN_MAX</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newf</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>


    <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">files</span> <span class="o">=</span> <span class="n">newf</span><span class="p">;</span><span class="c1">//新进程的files_struct结构指针指向新的files_struct结构
</span><span class="c1"></span>    <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">error</span><span class="p">;</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="进程调度">进程调度</h2>
<p>Linux 有多种调度算法，我们具体介绍完全公平调度算法 （CFQ）</p>
<h3 id="进程调度实体数据结构">进程调度实体数据结构</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="k">struct</span> <span class="n">sched_entity</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">load_weight</span> <span class="n">load</span><span class="p">;</span><span class="c1">//表示当前调度实体的权重
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">rb_node</span> <span class="n">run_node</span><span class="p">;</span><span class="c1">//红黑树的数据节点
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">group_node</span><span class="p">;</span><span class="c1">// 链表节点，被链接到 percpu 的 rq-&gt;cfs_tasks
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">on_rq</span><span class="p">;</span> <span class="c1">//当前调度实体是否在就绪队列上
</span><span class="c1"></span>    <span class="n">u64</span> <span class="n">exec_start</span><span class="p">;</span><span class="c1">//当前实体上次被调度执行的时间
</span><span class="c1"></span>    <span class="n">u64</span> <span class="n">sum_exec_runtime</span><span class="p">;</span><span class="c1">//当前实体总执行时间
</span><span class="c1"></span>    <span class="n">u64</span> <span class="n">prev_sum_exec_runtime</span><span class="p">;</span><span class="c1">//截止到上次统计，进程执行的时间
</span><span class="c1"></span>    <span class="n">u64</span> <span class="n">vruntime</span><span class="p">;</span><span class="c1">//当前实体的虚拟时间
</span><span class="c1"></span>    <span class="n">u64</span> <span class="n">nr_migrations</span><span class="p">;</span><span class="c1">//实体执行迁移的次数 
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">sched_statistics</span> <span class="n">statistics</span><span class="p">;</span><span class="c1">//统计信息包含进程的睡眠统计、等待延迟统计、CPU迁移统计、唤醒统计等。
</span><span class="c1"></span><span class="cp">#ifdef CONFIG_FAIR_GROUP_SCHED
</span><span class="cp"></span>    <span class="kt">int</span> <span class="n">depth</span><span class="p">;</span><span class="c1">// 表示当前实体处于调度组中的深度
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span><span class="c1">//指向父级调度实体
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span><span class="c1">//当前调度实体属于的 cfs_rq.
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">my_q</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cp">#ifdef CONFIG_SMP
</span><span class="cp"></span>    <span class="k">struct</span> <span class="n">sched_avg</span> <span class="n">avg</span> <span class="p">;</span><span class="c1">// 记录当前实体对于CPU的负载
</span><span class="c1"></span><span class="cp">#endif
</span><span class="cp"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>在 task_struct 结构中 ，会包含至少一个 sched_entity 结构的变量，
可以通过 sched_entity结构地址偏移访问 task_struct 结构</p>
<p><img src="/image/play_os_in_action/27_2.webp" alt="sched_entity"></p>
<h3 id="进程运行队列">进程运行队列</h3>
<p>每个 CPU 分配一个进程运行队列，队列包含多重调度算法的队列</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="k">struct</span> <span class="n">rq</span> <span class="p">{</span>
    <span class="n">raw_spinlock_t</span>      <span class="n">lock</span><span class="p">;</span><span class="c1">//自旋锁
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span>        <span class="n">nr_running</span><span class="p">;</span><span class="c1">//多个就绪运行进程
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">cfs_rq</span>       <span class="n">cfs</span><span class="p">;</span> <span class="c1">//作用于完全公平调度算法的运行队列
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">rt_rq</span>        <span class="n">rt</span><span class="p">;</span><span class="c1">//作用于实时调度算法的运行队列
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">dl_rq</span>        <span class="n">dl</span><span class="p">;</span><span class="c1">//作用于EDF调度算法的运行队列
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">task_struct</span> <span class="n">__rcu</span>    <span class="o">*</span><span class="n">curr</span><span class="p">;</span><span class="c1">//这个运行队列当前正在运行的进程
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">task_struct</span>  <span class="o">*</span><span class="n">idle</span><span class="p">;</span><span class="c1">//这个运行队列的空转进程
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">task_struct</span>  <span class="o">*</span><span class="n">stop</span><span class="p">;</span><span class="c1">//这个运行队列的停止进程
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">mm_struct</span>    <span class="o">*</span><span class="n">prev_mm</span><span class="p">;</span><span class="c1">//这个运行队列上一次运行进程的mm_struct
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span>        <span class="n">clock_update_flags</span><span class="p">;</span><span class="c1">//时钟更新标志
</span><span class="c1"></span>    <span class="n">u64</span>         <span class="n">clock</span><span class="p">;</span> <span class="c1">//运行队列的时间 
</span><span class="c1"></span>    <span class="c1">//后面的代码省略
</span><span class="c1"></span><span class="p">};</span>

<span class="k">struct</span> <span class="n">rb_root_cached</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">rb_root</span><span class="p">;</span>   <span class="c1">//红黑树的根
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">rb_leftmost</span><span class="p">;</span><span class="c1">//红黑树最左子节点
</span><span class="c1"></span><span class="p">};</span>
<span class="k">struct</span> <span class="n">cfs_rq</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">load_weight</span>  <span class="n">load</span><span class="p">;</span><span class="c1">//cfs_rq上所有调度实体的负载总和
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_running</span><span class="p">;</span><span class="c1">//cfs_rq上所有的调度实体不含调度组中的调度实体
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">h_nr_running</span><span class="p">;</span><span class="c1">//cfs_rq上所有的调度实体包含调度组中所有调度实体
</span><span class="c1"></span>    <span class="n">u64</span>         <span class="n">exec_clock</span><span class="p">;</span><span class="c1">//当前 cfs_rq 上执行的时间 
</span><span class="c1"></span>    <span class="n">u64</span>         <span class="n">min_vruntime</span><span class="p">;</span><span class="c1">//最小虚拟运行时间
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">rb_root_cached</span>   <span class="n">tasks_timeline</span><span class="p">;</span><span class="c1">//所有调度实体的根
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span><span class="c1">//当前调度实体
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="c1">//下一个调度实体
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span><span class="c1">//上次执行过的调度实体
</span><span class="c1"></span>    <span class="c1">//省略不关注的代码
</span><span class="c1"></span><span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="调度实体和运行队列的关系">调度实体和运行队列的关系</h3>
<p><img src="/image/play_os_in_action/27_3.webp" alt="running_queue"></p>
<p>task_struct 结构中 包含 sched_entity 结构，sched_entity 通过红黑树
组织起来，红黑树的根在 cfs_rq 结构中， cfs_rq 结构又被 包含在 rq 结构中</p>
<h3 id="调度器类">调度器类</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">sched_class</span> <span class="p">{</span>
    <span class="c1">//向运行队列中添加一个进程，入队
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">enqueue_task</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
    <span class="c1">//向运行队列中删除一个进程，出队
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dequeue_task</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
    <span class="c1">//检查当前进程是否可抢占
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">check_preempt_curr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
    <span class="c1">//从运行队列中返回可以投入运行的一个进程
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">pick_next_task</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span> <span class="p">;</span>

</code></pre></td></tr></table>
</div>
</div><p>Linux 定义了五个 sched_class 结构的实变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="c1">//定义在链接脚本文件中
</span><span class="c1"></span><span class="k">extern</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">__begin_sched_classes</span><span class="p">[];</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">__end_sched_classes</span><span class="p">[];</span>

<span class="cp">#define sched_class_highest (__end_sched_classes - 1)
</span><span class="cp">#define sched_class_lowest  (__begin_sched_classes - 1)
</span><span class="cp"></span>
<span class="cp">#define for_class_range(class, _from, _to) \
</span><span class="cp">    for (class = (_from); class != (_to); class--)
</span><span class="cp"></span><span class="c1">//遍历每个调度类
</span><span class="c1"></span><span class="cp">#define for_each_class(class) \
</span><span class="cp">    for_class_range(class, sched_class_highest, sched_class_lowest)
</span><span class="cp"></span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">stop_sched_class</span><span class="p">;</span><span class="c1">//停止调度类
</span><span class="c1"></span><span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">dl_sched_class</span><span class="p">;</span><span class="c1">//Deadline调度类
</span><span class="c1"></span><span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">rt_sched_class</span><span class="p">;</span><span class="c1">//实时调度类
</span><span class="c1"></span><span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">fair_sched_class</span><span class="p">;</span><span class="c1">//CFS调度类
</span><span class="c1"></span><span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">idle_sched_class</span><span class="p">;</span><span class="c1">//空转调度类
</span></code></pre></td></tr></table>
</div>
</div><p>它们的优先级是：stop_sched_class &gt; dl_sched_class &gt; rt_sched_class &gt; fair_sched_class &gt; idle_sched_class</p>
<p>CFS 调度器对应的类</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="n">fair_sched_class</span>
    <span class="nf">__section</span><span class="p">(</span><span class="s">&#34;__fair_sched_class&#34;</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">enqueue_task</span>       <span class="o">=</span> <span class="n">enqueue_task_fair</span><span class="p">,</span>
    <span class="p">.</span><span class="n">dequeue_task</span>       <span class="o">=</span> <span class="n">dequeue_task_fair</span><span class="p">,</span>
    <span class="p">.</span><span class="n">check_preempt_curr</span> <span class="o">=</span> <span class="n">check_preempt_wakeup</span><span class="p">,</span>
    <span class="p">.</span><span class="n">pick_next_task</span>     <span class="o">=</span> <span class="n">__pick_next_task_fair</span><span class="p">,</span>
<span class="p">};</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="cfs调度器">CFS调度器</h3>
<p>CFS没有时间片的概念，分配的是CPU时间比例。</p>
<p>举个例子，现在有 A、B 两个进程。进程 A 的权重是 1024，进程 B 的权重是 2048。
那么进程 A 获得 CPU 的时间比例是 1024/(1024+2048) = 33.3%。
进程 B 获得的 CPU 时间比例是 2048/(1024+2048)=66.7%。</p>
<p>进程的时间 = CPU 总时间 * 进程的权重 / 就绪队列所有进程权重之和</p>
<p>通过 nice 值设置进程权重，数据越小，权重越大</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">const</span> <span class="kt">int</span> <span class="n">sched_prio_to_weight</span><span class="p">[</span><span class="mi">40</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
 <span class="cm">/* -20 */</span>     <span class="mi">88761</span><span class="p">,</span>     <span class="mi">71755</span><span class="p">,</span>     <span class="mi">56483</span><span class="p">,</span>     <span class="mi">46273</span><span class="p">,</span>     <span class="mi">36291</span><span class="p">,</span>
 <span class="cm">/* -15 */</span>     <span class="mi">29154</span><span class="p">,</span>     <span class="mi">23254</span><span class="p">,</span>     <span class="mi">18705</span><span class="p">,</span>     <span class="mi">14949</span><span class="p">,</span>     <span class="mi">11916</span><span class="p">,</span>
 <span class="cm">/* -10 */</span>      <span class="mi">9548</span><span class="p">,</span>      <span class="mi">7620</span><span class="p">,</span>      <span class="mi">6100</span><span class="p">,</span>      <span class="mi">4904</span><span class="p">,</span>      <span class="mi">3906</span><span class="p">,</span>
 <span class="cm">/*  -5 */</span>      <span class="mi">3121</span><span class="p">,</span>      <span class="mi">2501</span><span class="p">,</span>      <span class="mi">1991</span><span class="p">,</span>      <span class="mi">1586</span><span class="p">,</span>      <span class="mi">1277</span><span class="p">,</span>
 <span class="cm">/*   0 */</span>      <span class="mi">1024</span><span class="p">,</span>       <span class="mi">820</span><span class="p">,</span>       <span class="mi">655</span><span class="p">,</span>       <span class="mi">526</span><span class="p">,</span>       <span class="mi">423</span><span class="p">,</span>
 <span class="cm">/*   5 */</span>       <span class="mi">335</span><span class="p">,</span>       <span class="mi">272</span><span class="p">,</span>       <span class="mi">215</span><span class="p">,</span>       <span class="mi">172</span><span class="p">,</span>       <span class="mi">137</span><span class="p">,</span>
 <span class="cm">/*  10 */</span>       <span class="mi">110</span><span class="p">,</span>        <span class="mi">87</span><span class="p">,</span>        <span class="mi">70</span><span class="p">,</span>        <span class="mi">56</span><span class="p">,</span>        <span class="mi">45</span><span class="p">,</span>
 <span class="cm">/*  15 */</span>        <span class="mi">36</span><span class="p">,</span>        <span class="mi">29</span><span class="p">,</span>        <span class="mi">23</span><span class="p">,</span>        <span class="mi">18</span><span class="p">,</span>        <span class="mi">15</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="进程调度延迟">进程调度延迟</h3>
<p>调度延迟指的是保证每个可运行的进程都至少运行一次的时间间隔</p>
<p>当可运行的进程少于等于 8 个时，调度延迟固定为 6ms；超过8个，
就要保证每个进程至少运行一段时间才被调度，这个一段时间叫做 最小调度粒度时间。</p>
<p>CFS 调度器 的默认最小调度粒度时间是 0.75ms</p>
<h3 id="虚拟时间">虚拟时间</h3>
<p>CFS引入了虚拟时间，保证每个进程允许的虚拟时间相等，
nice 为 0 的进程的虚拟时间和实际时间是相等的<br>
在选择下一个运行的进程时，只需要找到虚拟时间最小的进程就行了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="n">vruntime</span> <span class="o">=</span> <span class="n">wtime</span><span class="o">*</span><span class="p">(</span> <span class="n">NICE_0_LOAD</span><span class="o">/</span><span class="n">weight</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="定时周期调度">定时周期调度</h3>
<p>Linux会启动定时器，来更新进程的虚拟时间</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">static</span> <span class="kt">void</span> <span class="nf">update_curr</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">now</span> <span class="o">=</span> <span class="n">rq_clock_task</span><span class="p">(</span><span class="n">rq_of</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">));</span><span class="c1">//获取当前时间 
</span><span class="c1"></span>    <span class="n">u64</span> <span class="n">delta_exec</span><span class="p">;</span>
    <span class="n">delta_exec</span> <span class="o">=</span> <span class="n">now</span> <span class="o">-</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">exec_start</span><span class="p">;</span><span class="c1">//间隔时间 
</span><span class="c1"></span>    <span class="n">curr</span><span class="o">-&gt;</span><span class="n">exec_start</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
    <span class="n">curr</span><span class="o">-&gt;</span><span class="n">sum_exec_runtime</span> <span class="o">+=</span> <span class="n">delta_exec</span><span class="p">;</span><span class="c1">//累计运行时间 
</span><span class="c1"></span>    <span class="n">curr</span><span class="o">-&gt;</span><span class="n">vruntime</span> <span class="o">+=</span> <span class="n">calc_delta_fair</span><span class="p">(</span><span class="n">delta_exec</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span><span class="c1">//计算进程的虚拟时间 
</span><span class="c1"></span>    <span class="n">update_min_vruntime</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span><span class="c1">//更新运行队列中的最小虚拟时间，这是新建进程的虚拟时间，避免一个新建进程因为虚拟时间太小而长时间占用CPU
</span><span class="c1"></span><span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">entity_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queued</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">update_curr</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span><span class="c1">//更新当前运行进程和运行队列相关的时间
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">nr_running</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="c1">//当运行进程数量大于1就检查是否可抢占
</span><span class="c1"></span>        <span class="n">check_preempt_tick</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#define for_each_sched_entity(se) \
</span><span class="cp">        for (; se; se = NULL)
</span><span class="cp"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">task_tick_fair</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queued</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">cfs_rq</span> <span class="o">*</span><span class="n">cfs_rq</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sched_entity</span> <span class="o">*</span><span class="n">se</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">se</span><span class="p">;</span><span class="c1">//获取当前进程的调度实体 
</span><span class="c1"></span>    <span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span> <span class="p">{</span><span class="c1">//仅对当前进程的调度实体
</span><span class="c1"></span>        <span class="n">cfs_rq</span> <span class="o">=</span> <span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span><span class="c1">//获取当前进程的调度实体对应运行队列
</span><span class="c1"></span>        <span class="n">entity_tick</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">queued</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">scheduler_tick</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
    <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span><span class="c1">//获取运行CPU运行进程队列
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span><span class="c1">//获取当进程
</span><span class="c1"></span>    <span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span><span class="c1">//更新运行队列的时间等数据
</span><span class="c1"></span>    <span class="n">curr</span><span class="o">-&gt;</span><span class="n">sched_class</span><span class="o">-&gt;</span><span class="n">task_tick</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">curr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">//更新当前时间的虚拟时间
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="第二十八讲--如何管理设备">第二十八讲  如何管理设备</h1>
<h2 id="计算机的结构">计算机的结构</h2>
<p><img src="/image/play_os_in_action/28_1.webp" alt="computer_structure"></p>
<p>各种设备通过总线相连</p>
<h2 id="设备分类">设备分类</h2>
<p>操作系统内核感知的设备并不需要和物理设备对应，这取决于
设备控制代码的自身行为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">#define NOT_DEVICE 0               //不表示任何设备
#define BRIDGE_DEVICE 4            //总线桥接器设备
#define CPUCORE_DEVICE 5           //CPU设备，CPU也是设备
#define RAMCONTER_DEVICE 6        //内存控制器设备
#define RAM_DEVICE 7              //内存设备
#define USBHOSTCONTER_DEVICE 8    //USB主控制设备
#define INTUPTCONTER_DEVICE 9     //中断控制器设备
#define DMA_DEVICE 10             //DMA设备
#define CLOCKPOWER_DEVICE 11      //时钟电源设备
#define LCDCONTER_DEVICE 12        //LCD控制器设备
#define NANDFLASH_DEVICE 13       //nandflash设备
#define CAMERA_DEVICE 14          //摄像头设备
#define UART_DEVICE 15             //串口设备
#define TIMER_DEVICE 16            //定时器设备
#define USB_DEVICE 17              //USB设备
#define WATCHDOG_DEVICE 18        //看门狗设备
#define RTC_DEVICE 22              //实时时钟设备
#define SD_DEVICE 25               //SD卡设备
#define AUDIO_DEVICE 26            //音频设备
#define TOUCH_DEVICE 27           //触控设备
#define NETWORK_DEVICE 28         //网络设备
#define VIR_DEVICE 29               //虚拟设备
#define FILESYS_DEVICE 30            //文件系统设备
#define SYSTICK_DEVICE 31           //系统TICK设备
#define UNKNOWN_DEVICE 32        //未知设备，也是设备
#define HD_DEVICE 33        //硬盘设备
</code></pre></td></tr></table>
</div>
</div><h2 id="设备驱动">设备驱动</h2>
<h3 id="设备">设备</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_DEVID</span>
<span class="p">{</span>
    <span class="n">uint_t</span>  <span class="n">dev_mtype</span><span class="p">;</span><span class="c1">//设备类型号
</span><span class="c1"></span>    <span class="n">uint_t</span>  <span class="n">dev_stype</span><span class="p">;</span> <span class="c1">//设备子类型号
</span><span class="c1"></span>    <span class="n">uint_t</span>  <span class="n">dev_nr</span><span class="p">;</span> <span class="c1">//设备序号
</span><span class="c1"></span><span class="p">}</span><span class="n">devid_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_DEVICE</span>
<span class="p">{</span>
    <span class="n">list_h_t</span>    <span class="n">dev_list</span><span class="p">;</span><span class="c1">//设备链表
</span><span class="c1"></span>    <span class="n">list_h_t</span>    <span class="n">dev_indrvlst</span><span class="p">;</span> <span class="c1">//设备在驱动程序数据结构中对应的挂载链表
</span><span class="c1"></span>    <span class="n">list_h_t</span>    <span class="n">dev_intbllst</span><span class="p">;</span> <span class="c1">//设备在设备表数据结构中对应的挂载链表
</span><span class="c1"></span>    <span class="n">spinlock_t</span>  <span class="n">dev_lock</span><span class="p">;</span> <span class="c1">//设备自旋锁
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">dev_count</span><span class="p">;</span> <span class="c1">//设备计数
</span><span class="c1"></span>    <span class="n">sem_t</span>       <span class="n">dev_sem</span><span class="p">;</span> <span class="c1">//设备信号量
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">dev_stus</span><span class="p">;</span> <span class="c1">//设备状态
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">dev_flgs</span><span class="p">;</span> <span class="c1">//设备标志
</span><span class="c1"></span>    <span class="n">devid_t</span>      <span class="n">dev_id</span><span class="p">;</span> <span class="c1">//设备ID
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">dev_intlnenr</span><span class="p">;</span> <span class="c1">//设备中断服务例程的个数
</span><span class="c1"></span>    <span class="n">list_h_t</span>    <span class="n">dev_intserlst</span><span class="p">;</span> <span class="c1">//设备中断服务例程的链表
</span><span class="c1"></span>    <span class="n">list_h_t</span>    <span class="n">dev_rqlist</span><span class="p">;</span> <span class="c1">//对设备的请求服务链表
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">dev_rqlnr</span><span class="p">;</span> <span class="c1">//对设备的请求服务个数
</span><span class="c1"></span>    <span class="n">sem_t</span>       <span class="n">dev_waitints</span><span class="p">;</span> <span class="c1">//用于等待设备的信号量
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">s_DRIVER</span><span class="o">*</span> <span class="n">dev_drv</span><span class="p">;</span> <span class="c1">//设备对应的驱动程序数据结构的指针
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">dev_attrb</span><span class="p">;</span> <span class="c1">//设备属性指针
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">dev_privdata</span><span class="p">;</span> <span class="c1">//设备私有数据指针
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">dev_userdata</span><span class="p">;</span><span class="c1">//将来扩展所用
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">dev_extdata</span><span class="p">;</span><span class="c1">//将来扩展所用
</span><span class="c1"></span>    <span class="n">char_t</span><span class="o">*</span> <span class="n">dev_name</span><span class="p">;</span> <span class="c1">//设备名
</span><span class="c1"></span><span class="p">}</span><span class="n">device_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>设备 ID 表示设备的类型和设备号，指向驱动程序的指针用于访问设备时调用设备驱动程序。</p>
<h3 id="驱动程序">驱动程序</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_DRIVER</span>
<span class="p">{</span>
    <span class="n">spinlock_t</span> <span class="n">drv_lock</span><span class="p">;</span> <span class="c1">//保护驱动程序数据结构的自旋锁
</span><span class="c1"></span>    <span class="n">list_h_t</span> <span class="n">drv_list</span><span class="p">;</span><span class="c1">//挂载驱动程序数据结构的链表
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">drv_stuts</span><span class="p">;</span> <span class="c1">//驱动程序的相关状态
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">drv_flg</span><span class="p">;</span> <span class="c1">//驱动程序的相关标志
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">drv_id</span><span class="p">;</span> <span class="c1">//驱动程序ID
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">drv_count</span><span class="p">;</span> <span class="c1">//驱动程序的计数器
</span><span class="c1"></span>    <span class="n">sem_t</span> <span class="n">drv_sem</span><span class="p">;</span> <span class="c1">//驱动程序的信号量
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">drv_safedsc</span><span class="p">;</span> <span class="c1">//驱动程序的安全体
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">drv_attrb</span><span class="p">;</span> <span class="c1">//LMOSEM内核要求的驱动程序属性体
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">drv_privdata</span><span class="p">;</span> <span class="c1">//驱动程序私有数据的指针
</span><span class="c1"></span>    <span class="n">drivcallfun_t</span> <span class="n">drv_dipfun</span><span class="p">[</span><span class="n">IOIF_CODE_MAX</span><span class="p">];</span> <span class="c1">//驱动程序功能派发函数指针数组
</span><span class="c1"></span>    <span class="n">list_h_t</span> <span class="n">drv_alldevlist</span><span class="p">;</span> <span class="c1">//挂载驱动程序所管理的所有设备的链表
</span><span class="c1"></span>    <span class="n">drventyexit_t</span> <span class="n">drv_entry</span><span class="p">;</span> <span class="c1">//驱动程序的入口函数指针
</span><span class="c1"></span>    <span class="n">drventyexit_t</span> <span class="n">drv_exit</span><span class="p">;</span> <span class="c1">//驱动程序的退出函数指针
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">drv_userdata</span><span class="p">;</span><span class="c1">//用于将来扩展
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">drv_extdata</span><span class="p">;</span> <span class="c1">//用于将来扩展
</span><span class="c1"></span>    <span class="n">char_t</span><span class="o">*</span> <span class="n">drv_name</span><span class="p">;</span> <span class="c1">//驱动程序的名字
</span><span class="c1"></span><span class="p">}</span><span class="n">driver_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>驱动程序实例化的时候会建立设备的数据结构</p>
<h3 id="组织设备">组织设备</h3>
<p>我们使用设备表来组织驱动和设备</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#define DEVICE_MAX 34
</span><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_DEVTLST</span>
<span class="p">{</span>
    <span class="n">uint_t</span> <span class="n">dtl_type</span><span class="p">;</span><span class="c1">//设备类型
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">dtl_nr</span><span class="p">;</span><span class="c1">//设备计数
</span><span class="c1"></span>    <span class="n">list_h_t</span> <span class="n">dtl_list</span><span class="p">;</span><span class="c1">//挂载设备device_t结构的链表
</span><span class="c1"></span><span class="p">}</span><span class="n">devtlst_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_DEVTABLE</span>
<span class="p">{</span>
    <span class="n">list_h_t</span> <span class="n">devt_list</span><span class="p">;</span> <span class="c1">//设备表自身的链表
</span><span class="c1"></span>    <span class="n">spinlock_t</span> <span class="n">devt_lock</span><span class="p">;</span> <span class="c1">//设备表自旋锁
</span><span class="c1"></span>    <span class="n">list_h_t</span> <span class="n">devt_devlist</span><span class="p">;</span> <span class="c1">//全局设备链表
</span><span class="c1"></span>    <span class="n">list_h_t</span> <span class="n">devt_drvlist</span><span class="p">;</span> <span class="c1">//全局驱动程序链表，驱动程序不需要分类，一个链表就行
</span><span class="c1"></span>    <span class="n">uint_t</span>   <span class="n">devt_devnr</span><span class="p">;</span> <span class="c1">//全局设备计数
</span><span class="c1"></span>    <span class="n">uint_t</span>   <span class="n">devt_drvnr</span><span class="p">;</span> <span class="c1">//全局驱动程序计数
</span><span class="c1"></span>    <span class="n">devtlst_t</span> <span class="n">devt_devclsl</span><span class="p">[</span><span class="n">DEVICE_MAX</span><span class="p">];</span> <span class="c1">//分类存放设备数据结构的devtlst_t结构数组
</span><span class="c1"></span><span class="p">}</span><span class="n">devtable_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="/image/play_os_in_action/28_2.jpg" alt="device_structure"></p>
<h3 id="驱动程序功能">驱动程序功能</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//驱动程序入口和退出函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">device_entry</span><span class="p">(</span><span class="n">driver_t</span><span class="o">*</span> <span class="n">drvp</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">val</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>
<span class="n">drvstus_t</span> <span class="nf">device_exit</span><span class="p">(</span><span class="n">driver_t</span><span class="o">*</span> <span class="n">drvp</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">val</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>
<span class="c1">//设备中断处理函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">device_handle</span><span class="p">(</span><span class="n">uint_t</span> <span class="n">ift_nr</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">sframe</span><span class="p">);</span>
<span class="c1">//打开、关闭设备函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">device_open</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">);</span>
<span class="n">drvstus_t</span> <span class="nf">device_close</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">);</span>
<span class="c1">//读、写设备数据函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">device_read</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">);</span>
<span class="n">drvstus_t</span> <span class="nf">device_write</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">);</span>
<span class="c1">//调整读写设备数据位置函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">device_lseek</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">);</span>
<span class="c1">//控制设备函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">device_ioctrl</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">);</span>
<span class="c1">//开启、停止设备函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">device_dev_start</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">);</span>
<span class="n">drvstus_t</span> <span class="nf">device_dev_stop</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">);</span>
<span class="c1">//设置设备电源函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">device_set_powerstus</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">);</span>
<span class="c1">//枚举设备函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">device_enum_dev</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">);</span>
<span class="c1">//刷新设备缓存函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">device_flush</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">);</span>
<span class="c1">//设备关机函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">device_shutdown</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>driver_t 结构体中 的 drv_dipfunc 函数指针数组存放了上述12个
驱动函数的指针</p>
<h1 id="第二十九讲--如何注册设备">第二十九讲  如何注册设备</h1>
<h2 id="注册流程">注册流程</h2>
<p>电脑插入一个 USB 鼠标时，会有如下步骤</p>
<ol>
<li>操作系统收到一个中断</li>
<li>USB总线驱动的中断处理程序会执行</li>
<li>调用内核相关服务，查找 USB 鼠标对应的驱动程序</li>
<li>操作系统加载驱动程序</li>
<li>驱动程序执行，向内核注册一个鼠标设备</li>
</ol>
<h2 id="驱动程序表">驱动程序表</h2>
<p>加载驱动时，将驱动程序的入口函数加入驱动程序表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//cosmos/kernel/krlglobal.c
</span><span class="c1"></span><span class="n">KRL_DEFGLOB_VARIABLE</span><span class="p">(</span><span class="n">drventyexit_t</span><span class="p">,</span><span class="n">osdrvetytabl</span><span class="p">)[]</span><span class="o">=</span><span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">init_krldriver</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//遍历驱动程序表中的每个驱动程序入口函数
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">uint_t</span> <span class="n">ei</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">osdrvetytabl</span><span class="p">[</span><span class="n">ei</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">ei</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>    <span class="c1">//运行一个驱动程序入口
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">krlrun_driverentry</span><span class="p">(</span><span class="n">osdrvetytabl</span><span class="p">[</span><span class="n">ei</span><span class="p">])</span> <span class="o">==</span> <span class="n">DFCERRSTUS</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">hal_sysdie</span><span class="p">(</span><span class="s">&#34;init driver err&#34;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">init_krl</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">init_krlmm</span><span class="p">();</span>
    <span class="n">init_krldevice</span><span class="p">();</span>
    <span class="n">init_krldriver</span><span class="p">();</span>
    <span class="c1">//……
</span><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="运行驱动程序">运行驱动程序</h2>
<h3 id="调用驱动程序入口函数">调用驱动程序入口函数</h3>
<p>建立一个 driver_t结构实例，将其作为参数传入驱动程序入口函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">init_krldriver</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//遍历驱动程序表中的每个驱动程序入口函数
</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="n">uint_t</span> <span class="n">ei</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">osdrvetytabl</span><span class="p">[</span><span class="n">ei</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">ei</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>    <span class="c1">//运行一个驱动程序入口
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">krlrun_driverentry</span><span class="p">(</span><span class="n">osdrvetytabl</span><span class="p">[</span><span class="n">ei</span><span class="p">])</span> <span class="o">==</span> <span class="n">DFCERRSTUS</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">hal_sysdie</span><span class="p">(</span><span class="s">&#34;init driver err&#34;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">init_krl</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">init_krlmm</span><span class="p">();</span>
    <span class="n">init_krldevice</span><span class="p">();</span>
    <span class="n">init_krldriver</span><span class="p">();</span>
    <span class="c1">//……
</span><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h3 id="挂载设备到驱动上">挂载设备到驱动上</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="n">drvstus_t</span> <span class="nf">krldev_add_driver</span><span class="p">(</span><span class="n">device_t</span> <span class="o">*</span><span class="n">devp</span><span class="p">,</span> <span class="n">driver_t</span> <span class="o">*</span><span class="n">drvp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">list_h_t</span> <span class="o">*</span><span class="n">lst</span><span class="p">;</span>
    <span class="n">device_t</span> <span class="o">*</span><span class="n">fdevp</span><span class="p">;</span>
    <span class="c1">//遍历这个驱动上所有设备
</span><span class="c1"></span>    <span class="n">list_for_each</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drvp</span><span class="o">-&gt;</span><span class="n">drv_alldevlist</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">fdevp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">device_t</span><span class="p">,</span> <span class="n">dev_indrvlst</span><span class="p">);</span>
        <span class="c1">//比较设备ID有相同的则返回错误
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">krlcmp_devid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devp</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdevp</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">)</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//将设备挂载到驱动上
</span><span class="c1"></span>    <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devp</span><span class="o">-&gt;</span><span class="n">dev_indrvlst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drvp</span><span class="o">-&gt;</span><span class="n">drv_alldevlist</span><span class="p">);</span>
    <span class="n">devp</span><span class="o">-&gt;</span><span class="n">dev_drv</span> <span class="o">=</span> <span class="n">drvp</span><span class="p">;</span><span class="c1">//让设备中dev_drv字段指向管理自己的驱动
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">DFCOKSTUS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="向内核注册设备">向内核注册设备</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="n">drvstus_t</span> <span class="nf">krlnew_device</span><span class="p">(</span><span class="n">device_t</span> <span class="o">*</span><span class="n">devp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">device_t</span> <span class="o">*</span><span class="n">findevp</span><span class="p">;</span>
    <span class="n">drvstus_t</span> <span class="n">rets</span> <span class="o">=</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="n">cpuflg_t</span> <span class="n">cpufg</span><span class="p">;</span>
    <span class="n">list_h_t</span> <span class="o">*</span><span class="n">lstp</span><span class="p">;</span>
    <span class="n">devtable_t</span> <span class="o">*</span><span class="n">dtbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">osdevtable</span><span class="p">;</span>
    <span class="n">uint_t</span> <span class="n">devmty</span> <span class="o">=</span> <span class="n">devp</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">.</span><span class="n">dev_mtype</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">devp</span><span class="o">-&gt;</span><span class="n">dev_drv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span><span class="c1">//没有驱动的设备不行
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">krlspinlock_cli</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dtbp</span><span class="o">-&gt;</span><span class="n">devt_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span><span class="c1">//加锁
</span><span class="c1"></span>    <span class="c1">//遍历设备类型链表上的所有设备
</span><span class="c1"></span>    <span class="n">list_for_each</span><span class="p">(</span><span class="n">lstp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dtbp</span><span class="o">-&gt;</span><span class="n">devt_devclsl</span><span class="p">[</span><span class="n">devmty</span><span class="p">].</span><span class="n">dtl_list</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">findevp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">lstp</span><span class="p">,</span> <span class="n">device_t</span><span class="p">,</span> <span class="n">dev_intbllst</span><span class="p">);</span>
        <span class="c1">//不能有设备ID相同的设备，如果有则出错
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">krlcmp_devid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devp</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">findevp</span><span class="o">-&gt;</span><span class="n">dev_id</span><span class="p">)</span> <span class="o">==</span> <span class="n">TRUE</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">rets</span> <span class="o">=</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">return_step</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//先把设备加入设备表的全局设备链表
</span><span class="c1"></span>    <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devp</span><span class="o">-&gt;</span><span class="n">dev_intbllst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dtbp</span><span class="o">-&gt;</span><span class="n">devt_devclsl</span><span class="p">[</span><span class="n">devmty</span><span class="p">].</span><span class="n">dtl_list</span><span class="p">);</span>
    <span class="c1">//将设备加入对应设备类型的链表中
</span><span class="c1"></span>    <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devp</span><span class="o">-&gt;</span><span class="n">dev_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dtbp</span><span class="o">-&gt;</span><span class="n">devt_devlist</span><span class="p">);</span>
    <span class="n">dtbp</span><span class="o">-&gt;</span><span class="n">devt_devclsl</span><span class="p">[</span><span class="n">devmty</span><span class="p">].</span><span class="n">dtl_nr</span><span class="o">++</span><span class="p">;</span><span class="c1">//设备计数加一
</span><span class="c1"></span>    <span class="n">dtbp</span><span class="o">-&gt;</span><span class="n">devt_devnr</span><span class="o">++</span><span class="p">;</span><span class="c1">//总的设备数加一
</span><span class="c1"></span>    <span class="n">rets</span> <span class="o">=</span> <span class="n">DFCOKSTUS</span><span class="p">;</span>
<span class="nl">return_step</span><span class="p">:</span>
    <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dtbp</span><span class="o">-&gt;</span><span class="n">devt_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span><span class="c1">//解锁
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">rets</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="安装中断回调函数">安装中断回调函数</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//中断回调函数类型
</span><span class="c1"></span><span class="k">typedef</span> <span class="nf">drvstus_t</span> <span class="p">(</span><span class="o">*</span><span class="n">intflthandle_t</span><span class="p">)(</span><span class="n">uint_t</span> <span class="n">ift_nr</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">device</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">sframe</span><span class="p">);</span>
<span class="c1">//安装中断回调函数接口
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">krlnew_devhandle</span><span class="p">(</span><span class="n">device_t</span> <span class="o">*</span><span class="n">devp</span><span class="p">,</span> <span class="n">intflthandle_t</span> <span class="n">handle</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">phyiline</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//调用内核层中断框架接口函数
</span><span class="c1"></span>    <span class="n">intserdsc_t</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">krladd_irqhandle</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">phyiline</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sdp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cpuflg_t</span> <span class="n">cpufg</span><span class="p">;</span>
    <span class="n">krlspinlock_cli</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devp</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span>
    <span class="c1">//将中断服务描述符结构挂入这个设备结构中
</span><span class="c1"></span>    <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">s_indevlst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devp</span><span class="o">-&gt;</span><span class="n">dev_intserlst</span><span class="p">);</span>
    <span class="n">devp</span><span class="o">-&gt;</span><span class="n">dev_intlnenr</span><span class="o">++</span><span class="p">;</span>
    <span class="n">krlspinunlock_sti</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devp</span><span class="o">-&gt;</span><span class="n">dev_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cpufg</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">DFCOKSTUS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="第三十讲--如何处理内核io">第三十讲  如何处理内核I/O</h1>
<h2 id="io-包">I/O 包</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_OBJNODE</span>
<span class="p">{</span>
    <span class="n">spinlock_t</span>  <span class="n">on_lock</span><span class="p">;</span>        <span class="c1">//自旋锁
</span><span class="c1"></span>    <span class="n">list_h_t</span>    <span class="n">on_list</span><span class="p">;</span>        <span class="c1">//链表
</span><span class="c1"></span>    <span class="n">sem_t</span>       <span class="n">on_complesem</span><span class="p">;</span>   <span class="c1">//完成信号量
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">on_flgs</span><span class="p">;</span>        <span class="c1">//标志
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">on_stus</span><span class="p">;</span>        <span class="c1">//状态
</span><span class="c1"></span>    <span class="n">sint_t</span>      <span class="n">on_opercode</span><span class="p">;</span>    <span class="c1">//操作码
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">on_objtype</span><span class="p">;</span>     <span class="c1">//对象类型
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span>       <span class="n">on_objadr</span><span class="p">;</span>      <span class="c1">//对象地址
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">on_acsflgs</span><span class="p">;</span>     <span class="c1">//访问设备、文件标志
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">on_acsstus</span><span class="p">;</span>     <span class="c1">//访问设备、文件状态
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">on_currops</span><span class="p">;</span>     <span class="c1">//对应于读写数据的当前位置
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">on_len</span><span class="p">;</span>         <span class="c1">//对应于读写数据的长度
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">on_ioctrd</span><span class="p">;</span>      <span class="c1">//IO控制码
</span><span class="c1"></span>    <span class="n">buf_t</span>       <span class="n">on_buf</span><span class="p">;</span>         <span class="c1">//对应于读写数据的缓冲区
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">on_bufcurops</span><span class="p">;</span>   <span class="c1">//对应于读写数据的缓冲区的当前位置
</span><span class="c1"></span>    <span class="n">size_t</span>      <span class="n">on_bufsz</span><span class="p">;</span>       <span class="c1">//对应于读写数据的缓冲区的大小
</span><span class="c1"></span>    <span class="n">uint_t</span>      <span class="n">on_count</span><span class="p">;</span>       <span class="c1">//对应于对象节点的计数
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span>       <span class="n">on_safedsc</span><span class="p">;</span>     <span class="c1">//对应于对象节点的安全描述符
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span>       <span class="n">on_fname</span><span class="p">;</span>       <span class="c1">//对应于访问数据文件的名称
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span>       <span class="n">on_finode</span><span class="p">;</span>      <span class="c1">//对应于访问数据文件的结点
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span>       <span class="n">on_extp</span><span class="p">;</span>        <span class="c1">//用于扩展
</span><span class="c1"></span><span class="p">}</span><span class="n">objnode_t</span><span class="p">;</span>


<span class="cp">##  创建和删除
</span><span class="cp"></span>
<span class="err">```</span><span class="n">C</span>
<span class="c1">//建立objnode_t结构
</span><span class="c1"></span><span class="n">objnode_t</span> <span class="o">*</span><span class="n">krlnew_objnode</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">objnode_t</span> <span class="o">*</span><span class="n">ondp</span> <span class="o">=</span> <span class="p">(</span><span class="n">objnode_t</span> <span class="o">*</span><span class="p">)</span><span class="n">krlnew</span><span class="p">((</span><span class="n">size_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">objnode_t</span><span class="p">));</span><span class="c1">//分配objnode_t结构的内存空间
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">ondp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">objnode_t_init</span><span class="p">(</span><span class="n">ondp</span><span class="p">);</span><span class="c1">//初始化objnode_t结构
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">ondp</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//删除objnode_t结构
</span><span class="c1"></span><span class="n">bool_t</span> <span class="n">krldel_objnode</span><span class="p">(</span><span class="n">objnode_t</span> <span class="o">*</span><span class="n">onodep</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">krldelete</span><span class="p">((</span><span class="n">adr_t</span><span class="p">)</span><span class="n">onodep</span><span class="p">,</span> <span class="p">(</span><span class="n">size_t</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">objnode_t</span><span class="p">))</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span><span class="c1">//删除objnode_t结构的内存空间
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">hal_sysdie</span><span class="p">(</span><span class="s">&#34;krldel_objnode err&#34;</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="发送-io-包">发送 I/O 包</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//发送设备IO
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">krldev_io</span><span class="p">(</span><span class="n">objnode_t</span> <span class="o">*</span><span class="n">nodep</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//获取设备对象 
</span><span class="c1"></span>    <span class="n">device_t</span> <span class="o">*</span><span class="n">devp</span> <span class="o">=</span> <span class="p">(</span><span class="n">device_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">nodep</span><span class="o">-&gt;</span><span class="n">on_objadr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">nodep</span><span class="o">-&gt;</span><span class="n">on_objtype</span> <span class="o">!=</span> <span class="n">OBJN_TY_DEV</span> <span class="o">&amp;&amp;</span> <span class="n">nodep</span><span class="o">-&gt;</span><span class="n">on_objtype</span> <span class="o">!=</span> <span class="n">OBJN_TY_FIL</span><span class="p">)</span> <span class="o">||</span> <span class="n">nodep</span><span class="o">-&gt;</span><span class="n">on_objadr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span><span class="c1">//检查操作对象类型是不是文件或者设备，对象地址是不是为空
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nodep</span><span class="o">-&gt;</span><span class="n">on_opercode</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">nodep</span><span class="o">-&gt;</span><span class="n">on_opercode</span> <span class="o">&gt;=</span> <span class="n">IOIF_CODE_MAX</span><span class="p">)</span>
    <span class="p">{</span><span class="c1">//检查IO操作码是不是合乎要求
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">krldev_call_driver</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">nodep</span><span class="o">-&gt;</span><span class="n">on_opercode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">nodep</span><span class="p">);</span><span class="c1">//调用设备驱动
</span><span class="c1"></span><span class="p">}</span>
<span class="c1">//调用设备驱动
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">krldev_call_driver</span><span class="p">(</span><span class="n">device_t</span> <span class="o">*</span><span class="n">devp</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">iocode</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">val1</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">val2</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">driver_t</span> <span class="o">*</span><span class="n">drvp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">devp</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">iocode</span> <span class="o">&gt;=</span> <span class="n">IOIF_CODE_MAX</span><span class="p">)</span>
    <span class="p">{</span><span class="c1">//检查设备和IO操作码
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">drvp</span> <span class="o">=</span> <span class="n">devp</span><span class="o">-&gt;</span><span class="n">dev_drv</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">drvp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span><span class="c1">//检查设备是否有驱动程序
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//用IO操作码为索引调用驱动程序功能分派函数数组中的函数
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">drvp</span><span class="o">-&gt;</span><span class="n">drv_dipfun</span><span class="p">[</span><span class="n">iocode</span><span class="p">](</span><span class="n">devp</span><span class="p">,</span> <span class="n">p2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="实现systick设备驱动">实现systick设备驱动</h2>
<p>systick 设备的主要功能是每各1ms产生一个中断，更新当前进程的运行时间</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="n">drvstus_t</span> <span class="nf">systick_handle</span><span class="p">(</span><span class="n">uint_t</span> <span class="n">ift_nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">devp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">sframe</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">krlthd_inc_tick</span><span class="p">(</span><span class="n">krlsched_retn_currthread</span><span class="p">());</span><span class="c1">//更新当前进程的tick
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">DFCOKSTUS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="第三十一讲--linux如何获取所有设备信息">第三十一讲  Linux如何获取所有设备信息</h1>
<h2 id="linux的设备信息">Linux的设备信息</h2>
<p>可以在 <code>/sys/bus</code> 目录下查看总线下所有设备</p>
<h1 id="第三十二讲--如何组织文件">第三十二讲  如何组织文件</h1>
<h2 id="文件系统">文件系统</h2>
<h3 id="文件系统设计">文件系统设计</h3>
<p>因为文件系统有各种格式，所以文件系统组件应该和内核分开，且可以动态加载和删除不同的文件系统组件</p>
<p><img src="/image/play_os_in_action/32_1.webp" alt="file_system"></p>
<h3 id="文件格式和存储块">文件格式和存储块</h3>
<p>逻辑上文件就是一个可以动态增减的线性字节数组，而存储设备都是以块为单位存储数据的，
不同的存储设的存储卡大小不同，我们先将字节数组整合成文件数据逻辑块，然后将这个逻辑块映射到
一个或多个物理储存块</p>
<p><img src="/image/play_os_in_action/32_2.webp" alt="file_system_chunk"></p>
<h2 id="组织文件">组织文件</h2>
<p>整个文件层次结构就像一个倒挂的树</p>
<h3 id="文件系统数据结构">文件系统数据结构</h3>
<h4 id="超级块">超级块</h4>
<p>包含文件系统标识、版本信息、逻辑存储块大小等新的数据结构叫做文件系统的
超级块或描述块</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_RFSSUBLK</span>
<span class="p">{</span>
    <span class="n">spinlock_t</span> <span class="n">rsb_lock</span><span class="p">;</span><span class="c1">//超级块在内存中使用的自旋锁
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">rsb_mgic</span><span class="p">;</span><span class="c1">//文件系统标识
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">rsb_vec</span><span class="p">;</span><span class="c1">//文件系统版本
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">rsb_flg</span><span class="p">;</span><span class="c1">//标志
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">rsb_stus</span><span class="p">;</span><span class="c1">//状态
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">rsb_sz</span><span class="p">;</span><span class="c1">//该数据结构本身的大小
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">rsb_sblksz</span><span class="p">;</span><span class="c1">//超级块大小
</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">rsb_dblksz</span><span class="p">;</span><span class="c1">//文件系统逻辑储存块大小，我们这里用的是4KB
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">rsb_bmpbks</span><span class="p">;</span><span class="c1">//位图的开始逻辑储存块
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">rsb_bmpbknr</span><span class="p">;</span><span class="c1">//位图占用多少个逻辑储存块
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">rsb_fsysallblk</span><span class="p">;</span><span class="c1">//文件系统有多少个逻辑储存块
</span><span class="c1"></span>    <span class="n">rfsdir_t</span> <span class="n">rsb_rootdir</span><span class="p">;</span><span class="c1">//根目录，后面会看到这个数据结构的
</span><span class="c1"></span><span class="p">}</span><span class="n">rfssublk_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>超级块存储在设备的第一个逻辑存储块中</p>
<h4 id="位图">位图</h4>
<p>我们使用位图来表示逻辑存储块的分配状态，如果某个位的值是0，那么对应的逻辑块是空闲的。</p>
<p><img src="/image/play_os_in_action/32_3.webp" alt="file_system_bit_block"></p>
<p>位图并不需要实际的数据结构，将位图块当做一个字节数组就可以</p>
<h4 id="目录">目录</h4>
<p>目录也是一种数据，也包含了目录类型、状态、指向文件数据管理头的块号、名称等信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#define DR_NM_MAX (128-(sizeof(uint_t)*3))
</span><span class="cp">#define RDR_NUL_TYPE 0
</span><span class="cp">#define RDR_DIR_TYPE 1
</span><span class="cp">#define RDR_FIL_TYPE 2
</span><span class="cp">#define RDR_DEL_TYPE 5
</span><span class="cp"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_RFSDIR</span>
<span class="p">{</span>
    <span class="n">uint_t</span> <span class="n">rdr_stus</span><span class="p">;</span><span class="c1">//目录状态
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">rdr_type</span><span class="p">;</span><span class="c1">//目录类型，可以是空类型、目录类型、文件类型、已删除的类型
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">rdr_blknr</span><span class="p">;</span><span class="c1">//指向文件数据管理头的块号，不像内存可以用指针，只能按块访问
</span><span class="c1"></span>    <span class="n">char_t</span> <span class="n">rdr_name</span><span class="p">[</span><span class="n">DR_NM_MAX</span><span class="p">];</span><span class="c1">//名称数组，大小为DR_NM_MAX
</span><span class="c1"></span><span class="p">}</span><span class="n">rfsdir_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="/image/play_os_in_action/32_4.webp" alt="file_system_dir"></p>
<h4 id="文件管理头">文件管理头</h4>
<p>文件管理头记录了文件信息，如类型、创建时间、大小、占用哪些逻辑存储块等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#define FBLKS_MAX 32
</span><span class="cp">#define FMD_NUL_TYPE 0
</span><span class="cp">#define FMD_DIR_TYPE 1
</span><span class="cp">#define FMD_FIL_TYPE 2
</span><span class="cp">#define FMD_DEL_TYPE 5</span><span class="c1">//文件管理头也需要表明它管理的是目录文件还是普通文件
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_FILBLKS</span>
<span class="p">{</span>    
    <span class="n">uint_t</span> <span class="n">fb_blkstart</span><span class="p">;</span><span class="c1">//开始的逻辑储存块号
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fb_blknr</span><span class="p">;</span><span class="c1">//逻辑储存块的块数，从blkstart开始的连续块数
</span><span class="c1"></span><span class="p">}</span><span class="n">filblks_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_fimgrhd</span>
<span class="p">{</span>
    <span class="n">uint_t</span> <span class="n">fmd_stus</span><span class="p">;</span><span class="c1">//文件状态
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fmd_type</span><span class="p">;</span><span class="c1">//文件类型：可以是目录文件、普通文件、空文件、已删除的文件
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fmd_flg</span><span class="p">;</span><span class="c1">//文件标志
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fmd_sfblk</span><span class="p">;</span><span class="c1">//文件管理头自身所在的逻辑储存块
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fmd_acss</span><span class="p">;</span><span class="c1">//文件访问权限
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fmd_newtime</span><span class="p">;</span><span class="c1">//文件的创建时间，换算成秒
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fmd_acstime</span><span class="p">;</span><span class="c1">//文件的访问时间，换算成秒
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fmd_fileallbk</span><span class="p">;</span><span class="c1">//文件一共占用多少个逻辑储存块
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fmd_filesz</span><span class="p">;</span><span class="c1">//文件大小
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fmd_fileifstbkoff</span><span class="p">;</span><span class="c1">//文件数据在第一块逻辑储存块中的偏移
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fmd_fileiendbkoff</span><span class="p">;</span><span class="c1">//文件数据在最后一块逻辑储存块中的偏移
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fmd_curfwritebk</span><span class="p">;</span><span class="c1">//文件数据当前将要写入的逻辑储存块
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fmd_curfinwbkoff</span><span class="p">;</span><span class="c1">//文件数据当前将要写入的逻辑储存块中的偏移
</span><span class="c1"></span>    <span class="n">filblks_t</span> <span class="n">fmd_fleblk</span><span class="p">[</span><span class="n">FBLKS_MAX</span><span class="p">];</span><span class="c1">//文件占用逻辑储存块的数组，一共32个filblks_t结构
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fmd_linkpblk</span><span class="p">;</span><span class="c1">//指向文件的上一个文件管理头的逻辑储存块
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fmd_linknblk</span><span class="p">;</span><span class="c1">//指向文件的下一个文件管理头的逻辑储存块
</span><span class="c1"></span><span class="p">}</span><span class="n">fimgrhd_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>fmd_fleblk 数据存放的是逻辑块占用信息，比如一个文件占用 4~8、10~15、30~40 的逻辑存储块时，那么
fmd_fleblk[0] 保存 4 和 4，fmd_fleblk[1] 保存 10 和 5，fmd_fleblk[2] 保存 30 和 10 。</p>
<p>如果文件比较大，使用 fmd_linkpblk  和  fmd_linknblk 来扩展</p>
<p><img src="/image/play_os_in_action/32_5.webp" alt="file_system_file_head"></p>
<h1 id="第三十三讲--文件系统格式化">第三十三讲  文件系统格式化</h1>
<h2 id="文件系统设备">文件系统设备</h2>
<p>文件系统是 一个设备，需要编写相应的驱动程序</p>
<h2 id="建立超级块">建立超级块</h2>
<p>建立超级块就是初始化超级块的数据结构，然后写入存储设备的第一块逻辑存储块</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="o">*</span><span class="nf">new_buf</span><span class="p">(</span><span class="n">size_t</span> <span class="n">bufsz</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">krlnew</span><span class="p">(</span><span class="n">bufsz</span><span class="p">);</span><span class="c1">//分配缓冲区
</span><span class="c1"></span><span class="p">}</span>
<span class="kt">void</span> <span class="nf">del_buf</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">bufsz</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">krldelete</span><span class="p">((</span><span class="n">adr_t</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">bufsz</span><span class="p">)</span><span class="c1">//释放缓冲区
</span><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">rfssublk_t_init</span><span class="p">(</span><span class="n">rfssublk_t</span><span class="o">*</span> <span class="n">initp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">krlspinlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">initp</span><span class="o">-&gt;</span><span class="n">rsb_lock</span><span class="p">);</span>
    <span class="n">initp</span><span class="o">-&gt;</span><span class="n">rsb_mgic</span> <span class="o">=</span> <span class="mh">0x142422</span><span class="p">;</span><span class="c1">//标志就是一个数字而已，无其它意义
</span><span class="c1"></span>    <span class="n">initp</span><span class="o">-&gt;</span><span class="n">rsb_vec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//文件系统版本为1
</span><span class="c1"></span>    <span class="n">initp</span><span class="o">-&gt;</span><span class="n">rsb_flg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">initp</span><span class="o">-&gt;</span><span class="n">rsb_stus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">initp</span><span class="o">-&gt;</span><span class="n">rsb_sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rfssublk_t</span><span class="p">);</span><span class="c1">//超级块本身的大小
</span><span class="c1"></span>    <span class="n">initp</span><span class="o">-&gt;</span><span class="n">rsb_sblksz</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="c1">//超级块占用多少个逻辑储存块
</span><span class="c1"></span>    <span class="n">initp</span><span class="o">-&gt;</span><span class="n">rsb_dblksz</span> <span class="o">=</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">;</span><span class="c1">//逻辑储存块的大小为4KB
</span><span class="c1"></span>    <span class="c1">//位图块从第1个逻辑储存块开始，超级块占用第0个逻辑储存块
</span><span class="c1"></span>    <span class="n">initp</span><span class="o">-&gt;</span><span class="n">rsb_bmpbks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">initp</span><span class="o">-&gt;</span><span class="n">rsb_bmpbknr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">initp</span><span class="o">-&gt;</span><span class="n">rsb_fsysallblk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">rfsdir_t_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">initp</span><span class="o">-&gt;</span><span class="n">rsb_rootdir</span><span class="p">);</span><span class="c1">//初始化根目录
</span><span class="c1"></span>    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">bool_t</span> <span class="nf">create_superblk</span><span class="p">(</span><span class="n">device_t</span> <span class="o">*</span><span class="n">devp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">new_buf</span><span class="p">(</span><span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span><span class="c1">//分配4KB大小的缓冲区，清零
</span><span class="c1"></span>    <span class="n">hal_memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span>
    <span class="c1">//使rfssublk_t结构的指针指向缓冲区并进行初始化
</span><span class="c1"></span>    <span class="n">rfssublk_t</span> <span class="o">*</span><span class="n">sbp</span> <span class="o">=</span> <span class="p">(</span><span class="n">rfssublk_t</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
    <span class="n">rfssublk_t_init</span><span class="p">(</span><span class="n">sbp</span><span class="p">);</span>
    <span class="c1">//获取储存设备的逻辑储存块数并保存到超级块中
</span><span class="c1"></span>    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">rsb_fsysallblk</span> <span class="o">=</span> <span class="n">ret_rfsdevmaxblknr</span><span class="p">(</span><span class="n">devp</span><span class="p">);</span>
    <span class="c1">//把缓冲区中超级块的数据写入到储存设备的第0个逻辑储存块中
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">write_rfsdevblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">DFCERRSTUS</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">del_buf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span><span class="c1">//释放缓冲区
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="建立位图">建立位图</h2>
<p>我们使用一个逻辑存储块作为位图块记录所有存储块的状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//把逻辑储存块中的数据，读取到4KB大小的缓冲区中
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">read_rfsdevblk</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">rdadr</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">blknr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//获取逻辑储存块地址
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">p</span><span class="o">=</span><span class="n">ret_rfsdevblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span><span class="n">blknr</span><span class="p">);</span>
    <span class="c1">//把逻辑储存块中的数据复制到缓冲区中
</span><span class="c1"></span>    <span class="n">hal_memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">rdadr</span><span class="p">,</span><span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">DFCOKSTUS</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//获取超级块
</span><span class="c1"></span><span class="n">rfssublk_t</span><span class="o">*</span> <span class="nf">get_superblk</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//分配4KB大小的缓冲区
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="o">=</span><span class="n">new_buf</span><span class="p">(</span><span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span>
    <span class="c1">//清零缓冲区
</span><span class="c1"></span>    <span class="n">hal_memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">FSYS_ALCBLKSZ</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="c1">//读取第0个逻辑储存块中的数据到缓冲区中，如果读取失败则释放缓冲区
</span><span class="c1"></span>    <span class="n">read_rfsdevblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>

    <span class="c1">//返回超级块数据结构的地址，即缓冲区的首地址
</span><span class="c1"></span>    <span class="k">return</span> <span class="p">(</span><span class="n">rfssublk_t</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//释放超级块
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">del_superblk</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="n">rfssublk_t</span><span class="o">*</span> <span class="n">sbp</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="c1">//回写超级块，因为超级块中的数据可能已经发生了改变，如果出错则死机
</span><span class="c1"></span>    <span class="n">write_rfsdevblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">sbp</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//释放先前分配的4KB大小的缓冲区
</span><span class="c1"></span>    <span class="n">del_buf</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">sbp</span><span class="p">,</span><span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//建立位图
</span><span class="c1"></span><span class="n">bool_t</span> <span class="nf">create_bitmap</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bool_t</span> <span class="n">rets</span><span class="o">=</span><span class="n">FALSE</span><span class="p">;</span>
    <span class="c1">//获取超级块，失败则返回FALSE
</span><span class="c1"></span>    <span class="n">rfssublk_t</span><span class="o">*</span> <span class="n">sbp</span> <span class="o">=</span> <span class="n">get_superblk</span><span class="p">(</span><span class="n">devp</span><span class="p">);</span>
    <span class="c1">//分配4KB大小的缓冲区
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">new_buf</span><span class="p">(</span><span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span> 
      <span class="c1">//获取超级块中位图块的开始块号
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">bitmapblk</span><span class="o">=</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">rsb_bmpbks</span><span class="p">;</span>
    <span class="c1">//获取超级块中储存介质的逻辑储存块总数
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">devmaxblk</span><span class="o">=</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">rsb_fsysallblk</span><span class="p">;</span>
    <span class="c1">//如果逻辑储存块总数大于4096，就认为出错了
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">devmaxblk</span><span class="o">&gt;</span><span class="n">FSYS_ALCBLKSZ</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">rets</span><span class="o">=</span><span class="n">FALSE</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">errlable</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//把缓冲区中每个字节都置成1
</span><span class="c1"></span>    <span class="n">hal_memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">FSYS_ALCBLKSZ</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">u8_t</span><span class="o">*</span> <span class="n">bitmap</span><span class="o">=</span><span class="p">(</span><span class="n">u8_t</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
    <span class="c1">//把缓冲区中的第3个字节到第devmaxblk个字节都置成0
</span><span class="c1"></span>    <span class="c1">//前面两个字节分别代表超级块和位图块
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="n">uint_t</span> <span class="n">bi</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="n">bi</span><span class="o">&lt;</span><span class="n">devmaxblk</span><span class="p">;</span><span class="n">bi</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">bitmap</span><span class="p">[</span><span class="n">bi</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//把缓冲区中的数据写入到储存介质中的第bitmapblk个逻辑储存块中，即位图块中
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">write_rfsdevblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">bitmapblk</span><span class="p">)</span><span class="o">==</span><span class="n">DFCERRSTUS</span><span class="p">){</span>
        <span class="n">rets</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">errlable</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//设置返回状态
</span><span class="c1"></span>    <span class="n">rets</span><span class="o">=</span><span class="n">TRUE</span><span class="p">;</span>
<span class="nl">errlable</span><span class="p">:</span>
<span class="c1">//释放超级块
</span><span class="c1"></span>    <span class="n">del_superblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span><span class="n">sbp</span><span class="p">);</span>
<span class="c1">//释放缓冲区
</span><span class="c1"></span>    <span class="n">del_buf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">rets</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="建立根目录">建立根目录</h2>
<p>一切目录和文件都是存放在根目录下。
根目录也是一种文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//分配新的空闲逻辑储存块
</span><span class="c1"></span><span class="n">uint_t</span> <span class="nf">rfs_new_blk</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">)</span> 
<span class="p">{</span>
    <span class="n">uint_t</span> <span class="n">retblk</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="c1">//获取位图块
</span><span class="c1"></span>    <span class="n">u8_t</span><span class="o">*</span> <span class="n">bitmap</span> <span class="o">=</span> <span class="n">get_bitmapblk</span><span class="p">(</span><span class="n">devp</span><span class="p">);</span>        
    <span class="k">if</span><span class="p">(</span><span class="n">bitmap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>    
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="n">uint_t</span> <span class="n">blknr</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">blknr</span> <span class="o">&lt;</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">;</span> <span class="n">blknr</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//找到一个为0的字节就置为1，并返回该字节对应的空闲块号
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">bitmap</span><span class="p">[</span><span class="n">blknr</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">bitmap</span><span class="p">[</span><span class="n">blknr</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">retblk</span> <span class="o">=</span> <span class="n">blknr</span><span class="p">;</span>
            <span class="k">goto</span> <span class="n">retl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//如果到这里就说明没有空闲块了，所以返回0
</span><span class="c1"></span>    <span class="n">retblk</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="nl">retl</span><span class="p">:</span>
    <span class="c1">//释放位图块
</span><span class="c1"></span>    <span class="n">del_bitmapblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span><span class="n">bitmap</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">retblk</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//建立根目录
</span><span class="c1"></span><span class="n">bool_t</span> <span class="nf">create_rootdir</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">bool_t</span> <span class="n">rets</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="c1">//获取超级块
</span><span class="c1"></span>    <span class="n">rfssublk_t</span><span class="o">*</span> <span class="n">sbp</span> <span class="o">=</span> <span class="n">get_superblk</span><span class="p">(</span><span class="n">devp</span><span class="p">);</span>
    <span class="c1">//分配4KB大小的缓冲区
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">new_buf</span><span class="p">(</span><span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span>
    <span class="c1">//缓冲区清零
</span><span class="c1"></span>    <span class="n">hal_memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="n">FSYS_ALCBLKSZ</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="c1">//分配一个空闲的逻辑储存块
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">blk</span> <span class="o">=</span> <span class="n">rfs_new_blk</span><span class="p">(</span><span class="n">devp</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">blk</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rets</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">errlable</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//设置超级块中的rfsdir_t结构中的名称为“/”
</span><span class="c1"></span>    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">rsb_rootdir</span><span class="p">.</span><span class="n">rdr_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>
    <span class="c1">//设置超级块中的rfsdir_t结构中的类型为目录类型
</span><span class="c1"></span>    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">rsb_rootdir</span><span class="p">.</span><span class="n">rdr_type</span> <span class="o">=</span> <span class="n">RDR_DIR_TYPE</span><span class="p">;</span>
    <span class="c1">//设置超级块中的rfsdir_t结构中的块号为新分配的空闲逻辑储存块的块号
</span><span class="c1"></span>    <span class="n">sbp</span><span class="o">-&gt;</span><span class="n">rsb_rootdir</span><span class="p">.</span><span class="n">rdr_blknr</span> <span class="o">=</span> <span class="n">blk</span><span class="p">;</span>
    <span class="n">fimgrhd_t</span><span class="o">*</span> <span class="n">fmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">fimgrhd_t</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
    <span class="c1">//初始化fimgrhd_t结构
</span><span class="c1"></span>    <span class="n">fimgrhd_t_init</span><span class="p">(</span><span class="n">fmp</span><span class="p">);</span>
    <span class="c1">//因为这是目录文件所以fimgrhd_t结构的类型设置为目录类型
</span><span class="c1"></span>    <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_type</span> <span class="o">=</span> <span class="n">FMD_DIR_TYPE</span><span class="p">;</span>
    <span class="c1">//fimgrhd_t结构自身所在的块设置为新分配的空闲逻辑储存块
</span><span class="c1"></span>    <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_sfblk</span> <span class="o">=</span> <span class="n">blk</span><span class="p">;</span>
    <span class="c1">//fimgrhd_t结构中正在写入的块设置为新分配的空闲逻辑储存块
</span><span class="c1"></span>    <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfwritebk</span> <span class="o">=</span> <span class="n">blk</span><span class="p">;</span>
    <span class="c1">//fimgrhd_t结构中正在写入的块的偏移设置为512字节
</span><span class="c1"></span>    <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfinwbkoff</span> <span class="o">=</span> <span class="mh">0x200</span><span class="p">;</span>
    <span class="c1">//设置文件数据占有块数组的第0个元素
</span><span class="c1"></span>    <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fleblk</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fb_blkstart</span> <span class="o">=</span> <span class="n">blk</span><span class="p">;</span>
    <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fleblk</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fb_blknr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">//把缓冲区中的数据写入到新分配的空闲逻辑储存块中，其中包含已经设置好的      fimgrhd_t结构
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">write_rfsdevblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">blk</span><span class="p">)</span> <span class="o">==</span> <span class="n">DFCERRSTUS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rets</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="k">goto</span> <span class="n">errlable</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">rets</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="nl">errlable</span><span class="p">:</span>
    <span class="c1">//释放缓冲区
</span><span class="c1"></span>    <span class="n">del_buf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span>
<span class="nl">errlable1</span><span class="p">:</span>
    <span class="c1">//释放超级块
</span><span class="c1"></span>    <span class="n">del_superblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">sbp</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">rets</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="第三十四讲--实现文件的六大基本操作">第三十四讲  实现文件的六大基本操作</h1>
<h2 id="辅助操作">辅助操作</h2>
<p>文件操作需要大量辅助函数</p>
<h3 id="操作根目录文件">操作根目录文件</h3>
<p>在我们的文件系统中，一个文件的 rfsdir_t 结构存储在根目录文件中，所欲
首先需要获取和释放根目录文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//获取根目录文件
</span><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">get_rootdirfile_blk</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">retptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  
    <span class="n">rfsdir_t</span><span class="o">*</span> <span class="n">rtdir</span> <span class="o">=</span> <span class="n">get_rootdir</span><span class="p">(</span><span class="n">devp</span><span class="p">);</span><span class="c1">//获取根目录文件的rfsdir_t结构
</span><span class="c1"></span>    <span class="c1">//分配4KB大小的缓冲区并清零
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">new_buf</span><span class="p">(</span><span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span>
    <span class="n">hal_memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">//读取根目录文件的逻辑储存块到缓冲区中
</span><span class="c1"></span>    <span class="n">read_rfsdevblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">rtdir</span><span class="o">-&gt;</span><span class="n">rdr_blknr</span><span class="p">)</span>
    <span class="n">retptr</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span><span class="c1">//设置缓冲区的首地址为返回值
</span><span class="c1"></span>    <span class="k">goto</span> <span class="n">errl1</span><span class="p">;</span>
<span class="nl">errl</span><span class="p">:</span>
    <span class="n">del_buf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span>
<span class="nl">errl1</span><span class="p">:</span>
    <span class="n">del_rootdir</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">rtdir</span><span class="p">);</span><span class="c1">//释放根目录文件的rfsdir_t结构
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">retptr</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//释放根目录文件
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">del_rootdirfile_blk</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">blkp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//因为逻辑储存块的头512字节的空间中，保存的就是fimgrhd_t结构
</span><span class="c1"></span>    <span class="n">fimgrhd_t</span><span class="o">*</span> <span class="n">fmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">fimgrhd_t</span><span class="o">*</span><span class="p">)</span><span class="n">blkp</span><span class="p">;</span>
    <span class="c1">//把根目录文件回写到储存设备中去，块号为fimgrhd_t结构自身所在的块号
</span><span class="c1"></span>    <span class="n">write_rfsdevblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">blkp</span><span class="p">,</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_sfblk</span><span class="p">)</span>
    <span class="c1">//释放缓冲区
</span><span class="c1"></span>    <span class="n">del_buf</span><span class="p">(</span><span class="n">blkp</span><span class="p">,</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span> 
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="获取文件名">获取文件名</h3>
<p>简单起见，我们以 &ldquo;/xxx&rdquo; 格式举例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//检查文件路径名
</span><span class="c1"></span><span class="n">sint_t</span> <span class="nf">rfs_chkfilepath</span><span class="p">(</span><span class="n">char_t</span><span class="o">*</span> <span class="n">fname</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">char_t</span><span class="o">*</span> <span class="n">chp</span> <span class="o">=</span> <span class="n">fname</span><span class="p">;</span>
    <span class="c1">//检查文件路径名的第一个字符是否为“/”，不是则返回2
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">chp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="n">uint_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//检查除第1个字符外其它字符中还有没有为“/”的，有就返回3
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">chp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">3</span><span class="p">;</span> <span class="p">}</span>
        <span class="c1">//如果这里i大于等于文件名称的最大长度，就返回4
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">DR_NM_MAX</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">4</span><span class="p">;</span> <span class="p">}</span>
        <span class="c1">//到文件路径字符串的末尾就跳出循环
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">chp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//返回0表示正确
</span><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//提取纯文件名
</span><span class="c1"></span><span class="n">sint_t</span> <span class="nf">rfs_ret_fname</span><span class="p">(</span><span class="n">char_t</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span><span class="n">char_t</span><span class="o">*</span> <span class="n">fpath</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//检查文件路径名是不是“/xxxx”的形式
</span><span class="c1"></span>    <span class="n">sint_t</span> <span class="n">stus</span> <span class="o">=</span> <span class="n">rfs_chkfilepath</span><span class="p">(</span><span class="n">fpath</span><span class="p">);</span>
    <span class="c1">//如果不为0就直接返回这个状态值表示错误
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">stus</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">stus</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">//从路径名字符串的第2个字符开始复制字符到buf中
</span><span class="c1"></span>    <span class="n">rfs_strcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fpath</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">buf</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="判断文件是否存在">判断文件是否存在</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="n">sint_t</span> <span class="nf">rfs_chkfileisindev</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="n">char_t</span><span class="o">*</span> <span class="n">fname</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">sint_t</span> <span class="n">rets</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="n">sint_t</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">rfs_strlen</span><span class="p">(</span><span class="n">fname</span><span class="p">);</span><span class="c1">//获取文件名的长度，注意不是文件路径名
</span><span class="c1"></span>    <span class="c1">//检查文件名的长度是不是合乎要求
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">ch</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">ch</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">sint_t</span><span class="p">)</span><span class="n">DR_NM_MAX</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">4</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">rdblkp</span> <span class="o">=</span> <span class="n">get_rootdirfile_blk</span><span class="p">(</span><span class="n">devp</span><span class="p">);</span>
    <span class="n">fimgrhd_t</span><span class="o">*</span> <span class="n">fmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">fimgrhd_t</span><span class="o">*</span><span class="p">)</span><span class="n">rdblkp</span><span class="p">;</span>
    <span class="c1">//检查该fimgrhd_t结构的类型是不是FMD_DIR_TYPE，即这个文件是不是目录文件
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_type</span> <span class="o">!=</span> <span class="n">FMD_DIR_TYPE</span><span class="p">)</span> <span class="p">{</span> <span class="n">rets</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">//检查根目录文件是不是为空，即没有写入任何数据，所以返回0，表示根目录下没有对应的文件
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfwritebk</span> <span class="o">==</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fleblk</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fb_blkstart</span> <span class="o">&amp;&amp;</span>
 <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfinwbkoff</span> <span class="o">==</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fileifstbkoff</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">rfsdir_t</span><span class="o">*</span> <span class="n">dirp</span> <span class="o">=</span> <span class="p">(</span><span class="n">rfsdir_t</span><span class="o">*</span><span class="p">)((</span><span class="n">uint_t</span><span class="p">)(</span><span class="n">fmp</span><span class="p">)</span> <span class="o">+</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fileifstbkoff</span><span class="p">);</span><span class="c1">//指向根目录文件的第一个字节
</span><span class="c1"></span>    <span class="c1">//指向根目录文件的结束地址
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">maxchkp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)((</span><span class="n">uint_t</span><span class="p">)</span><span class="n">rdblkp</span> <span class="o">+</span> <span class="n">FSYS_ALCBLKSZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">//当前的rfsdir_t结构的指针比根目录文件的结束地址小，就继续循环    
</span><span class="c1"></span>    <span class="k">for</span><span class="p">(;(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">dirp</span> <span class="o">&lt;</span> <span class="n">maxchkp</span><span class="p">;)</span> <span class="p">{</span>
        <span class="c1">//如果这个rfsdir_t结构的类型是RDR_FIL_TYPE，说明它对应的是文件而不是目录，所以下面就继续比较其文件名
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">dirp</span><span class="o">-&gt;</span><span class="n">rdr_type</span> <span class="o">==</span> <span class="n">RDR_FIL_TYPE</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">rfs_strcmp</span><span class="p">(</span><span class="n">dirp</span><span class="o">-&gt;</span><span class="n">rdr_name</span><span class="p">,</span><span class="n">fname</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="c1">//比较其文件名
</span><span class="c1"></span>                <span class="n">rets</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">dirp</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">rets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//到了这里说明没有找到相同的文件
</span><span class="c1"></span><span class="nl">err</span><span class="p">:</span>
    <span class="n">del_rootdirfile_blk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span><span class="n">rdblkp</span><span class="p">);</span><span class="c1">//释放根目录文件
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">rets</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="文件相关操作">文件相关操作</h2>
<h3 id="新建文件">新建文件</h3>
<p>新建文件分成4步：</p>
<ol>
<li>提取纯文件名，检查文件是否已存在</li>
<li>分配一个空间的逻辑存储块，并在根目录末尾写入这个文件对应的 rfsdir_t 结构</li>
<li>在一个新的 4KB 的缓冲区初始化文件对应的 fimgrhd_t 结构</li>
<li>把第 3 步对应的缓冲区数据写入到第 2 步分配的空间逻辑块中</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//新建文件的接口函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">rfs_new_file</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span> <span class="n">char_t</span><span class="o">*</span> <span class="n">fname</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">flg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//在栈中分配一个字符缓冲区并清零
</span><span class="c1"></span>    <span class="n">char_t</span> <span class="n">fne</span><span class="p">[</span><span class="n">DR_NM_MAX</span><span class="p">];</span>
    <span class="n">hal_memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">fne</span><span class="p">,</span> <span class="n">DR_NM_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">//从文件路径名中提取出纯文件名
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">rfs_ret_fname</span><span class="p">(</span><span class="n">fne</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">//检查储存介质上是否已经存在这个新建的文件，如果是则返回错误
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">rfs_chkfileisindev</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">fne</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">//调用实际建立文件的函数
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">rfs_new_dirfileblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">fne</span><span class="p">,</span> <span class="n">RDR_FIL_TYPE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="n">drvstus_t</span> <span class="nf">rfs_new_dirfileblk</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="n">char_t</span><span class="o">*</span> <span class="n">fname</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">flgtype</span><span class="p">,</span><span class="n">uint_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">drvstus_t</span> <span class="n">rets</span> <span class="o">=</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">new_buf</span><span class="p">(</span><span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span><span class="c1">//分配一个4KB大小的缓冲区    
</span><span class="c1"></span>    <span class="n">hal_memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span><span class="c1">//清零该缓冲区
</span><span class="c1"></span>    <span class="n">uint_t</span> <span class="n">fblk</span> <span class="o">=</span> <span class="n">rfs_new_blk</span><span class="p">(</span><span class="n">devp</span><span class="p">);</span><span class="c1">//分配一个新的空闲逻辑储存块
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">rdirblk</span> <span class="o">=</span> <span class="n">get_rootdirfile_blk</span><span class="p">(</span><span class="n">devp</span><span class="p">);</span><span class="c1">//获取根目录文件
</span><span class="c1"></span>    <span class="n">fimgrhd_t</span><span class="o">*</span> <span class="n">fmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">fimgrhd_t</span><span class="o">*</span><span class="p">)</span><span class="n">rdirblk</span><span class="p">;</span>
    <span class="c1">//指向文件当前的写入地址，因为根目录文件已经被读取到内存中了
</span><span class="c1"></span>    <span class="n">rfsdir_t</span><span class="o">*</span> <span class="n">wrdirp</span> <span class="o">=</span> <span class="p">(</span><span class="n">rfsdir_t</span><span class="o">*</span><span class="p">)((</span><span class="n">uint_t</span><span class="p">)</span><span class="n">rdirblk</span> <span class="o">+</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfinwbkoff</span><span class="p">);</span>
    <span class="c1">//对文件当前的写入地址进行检查
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(((</span><span class="n">uint_t</span><span class="p">)</span><span class="n">wrdirp</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">((</span><span class="n">uint_t</span><span class="p">)</span><span class="n">rdirblk</span> <span class="o">+</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">rets</span><span class="o">=</span><span class="n">DFCERRSTUS</span><span class="p">;</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">wrdirp</span><span class="o">-&gt;</span><span class="n">rdr_stus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">wrdirp</span><span class="o">-&gt;</span><span class="n">rdr_type</span> <span class="o">=</span> <span class="n">flgtype</span><span class="p">;</span><span class="c1">//设为文件类型
</span><span class="c1"></span>    <span class="n">wrdirp</span><span class="o">-&gt;</span><span class="n">rdr_blknr</span> <span class="o">=</span> <span class="n">fblk</span><span class="p">;</span><span class="c1">//设为刚刚分配的空闲逻辑储存块
</span><span class="c1"></span>    <span class="n">rfs_strcpy</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">wrdirp</span><span class="o">-&gt;</span><span class="n">rdr_name</span><span class="p">);</span><span class="c1">//把文件名复制到rfsdir_t结构
</span><span class="c1"></span>    <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_filesz</span> <span class="o">+=</span> <span class="p">(</span><span class="n">uint_t</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">rfsdir_t</span><span class="p">));</span><span class="c1">//增加根目录文件的大小
</span><span class="c1"></span>    <span class="c1">//增加根目录文件当前的写入地址，保证下次不被覆盖
</span><span class="c1"></span>    <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfinwbkoff</span> <span class="o">+=</span> <span class="p">(</span><span class="n">uint_t</span><span class="p">)(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">rfsdir_t</span><span class="p">));</span>
    <span class="n">fimgrhd_t</span><span class="o">*</span> <span class="n">ffmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">fimgrhd_t</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span><span class="c1">//指向新分配的缓冲区
</span><span class="c1"></span>    <span class="n">fimgrhd_t_init</span><span class="p">(</span><span class="n">ffmp</span><span class="p">);</span><span class="c1">//调用fimgrhd_t结构默认的初始化函数
</span><span class="c1"></span>    <span class="n">ffmp</span><span class="o">-&gt;</span><span class="n">fmd_type</span> <span class="o">=</span> <span class="n">FMD_FIL_TYPE</span><span class="p">;</span><span class="c1">//因为建立的是文件，所以设为文件类型
</span><span class="c1"></span>    <span class="n">ffmp</span><span class="o">-&gt;</span><span class="n">fmd_sfblk</span> <span class="o">=</span> <span class="n">fblk</span><span class="p">;</span><span class="c1">//把自身所在的块，设为分配的逻辑储存块
</span><span class="c1"></span>    <span class="n">ffmp</span><span class="o">-&gt;</span><span class="n">fmd_curfwritebk</span> <span class="o">=</span> <span class="n">fblk</span><span class="p">;</span><span class="c1">//把当前写入的块，设为分配的逻辑储存块
</span><span class="c1"></span>    <span class="n">ffmp</span><span class="o">-&gt;</span><span class="n">fmd_curfinwbkoff</span> <span class="o">=</span> <span class="mh">0x200</span><span class="p">;</span><span class="c1">//把当前写入块的写入偏移量设为512
</span><span class="c1"></span>    <span class="c1">//把文件储存块数组的第1个元素的开始块，设为刚刚分配的空闲逻辑储存块
</span><span class="c1"></span>    <span class="n">ffmp</span><span class="o">-&gt;</span><span class="n">fmd_fleblk</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fb_blkstart</span> <span class="o">=</span> <span class="n">fblk</span><span class="p">;</span>
    <span class="c1">//因为只分配了一个逻辑储存块，所以设为1
</span><span class="c1"></span>    <span class="n">ffmp</span><span class="o">-&gt;</span><span class="n">fmd_fleblk</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fb_blknr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">//把缓冲区中的数据写入到刚刚分配的空闲逻辑储存块中
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">write_rfsdevblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">fblk</span><span class="p">)</span> <span class="o">==</span> <span class="n">DFCERRSTUS</span><span class="p">)</span> <span class="p">{</span>       
        <span class="n">rets</span> <span class="o">=</span> <span class="n">DFCERRSTUS</span><span class="p">;</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">rets</span> <span class="o">=</span> <span class="n">DFCOKSTUS</span><span class="p">;</span>
<span class="nl">err</span><span class="p">:</span>
    <span class="n">del_rootdirfile_blk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">rdirblk</span><span class="p">);</span><span class="c1">//释放根目录文件
</span><span class="c1"></span><span class="nl">err1</span><span class="p">:</span>
    <span class="n">del_buf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span><span class="c1">//释放缓冲区
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">rets</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="删除文件">删除文件</h3>
<p>删除文件分成4步：</p>
<ol>
<li>提取纯文件名</li>
<li>获取根目录文件，在根目录文件中查找待删除文件的 rfsdir_t 结构，然后释放该文件占用的逻辑存储块</li>
<li>将 rfsdir_t结构的类型设置为 RDR_DEL_TYPE</li>
<li>释放根目录文件</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//文件删除的接口函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">rfs_del_file</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span> <span class="n">char_t</span><span class="o">*</span> <span class="n">fname</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">flg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">flg</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">rfs_del_dirfileblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">RDR_FIL_TYPE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">drvstus_t</span> <span class="nf">rfs_del_dirfileblk</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span> <span class="n">char_t</span><span class="o">*</span> <span class="n">fname</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">flgtype</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">flgtype</span> <span class="o">!=</span> <span class="n">RDR_FIL_TYPE</span> <span class="o">||</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">char_t</span> <span class="n">fne</span><span class="p">[</span><span class="n">DR_NM_MAX</span><span class="p">];</span>
    <span class="n">hal_memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">fne</span><span class="p">,</span> <span class="n">DR_NM_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="c1">//提取纯文件名
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">rfs_ret_fname</span><span class="p">(</span><span class="n">fne</span><span class="p">,</span><span class="n">fname</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span> <span class="p">}</span>
    <span class="c1">//调用删除文件的核心函数
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">del_dirfileblk_core</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">fne</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">DFCOKSTUS</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">//删除文件的核心函数
</span><span class="c1"></span><span class="n">sint_t</span> <span class="nf">del_dirfileblk_core</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span> <span class="n">char_t</span><span class="o">*</span> <span class="n">fname</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">sint_t</span> <span class="n">rets</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">rblkp</span><span class="o">=</span><span class="n">get_rootdirfile_blk</span><span class="p">(</span><span class="n">devp</span><span class="p">);</span><span class="c1">//获取根目录文件
</span><span class="c1"></span>    <span class="n">fimgrhd_t</span><span class="o">*</span> <span class="n">fmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">fimgrhd_t</span><span class="o">*</span><span class="p">)</span><span class="n">rblkp</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_type</span><span class="o">!=</span><span class="n">FMD_DIR_TYPE</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//检查根目录文件的类型
</span><span class="c1"></span>        <span class="n">rets</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfwritebk</span> <span class="o">==</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fleblk</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fb_blkstart</span> <span class="o">&amp;&amp;</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfinwbkoff</span> <span class="o">==</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fileifstbkoff</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//检查根目录文件中有没有数据
</span><span class="c1"></span>        <span class="n">rets</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">rfsdir_t</span><span class="o">*</span> <span class="n">dirp</span> <span class="o">=</span> <span class="p">(</span><span class="n">rfsdir_t</span><span class="o">*</span><span class="p">)((</span><span class="n">uint_t</span><span class="p">)(</span><span class="n">fmp</span><span class="p">)</span> <span class="o">+</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fileifstbkoff</span><span class="p">);</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">maxchkp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)((</span><span class="n">uint_t</span><span class="p">)</span><span class="n">rblkp</span> <span class="o">+</span> <span class="n">FSYS_ALCBLKSZ</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(;(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">dirp</span> <span class="o">&lt;</span> <span class="n">maxchkp</span><span class="p">;)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">dirp</span><span class="o">-&gt;</span><span class="n">rdr_type</span> <span class="o">==</span> <span class="n">RDR_FIL_TYPE</span><span class="p">)</span> <span class="p">{</span><span class="c1">//检查其类型是否为文件类型
</span><span class="c1"></span>            <span class="c1">//如果文件名相同，就执行以下删除动作
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">rfs_strcmp</span><span class="p">(</span><span class="n">dirp</span><span class="o">-&gt;</span><span class="n">rdr_name</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//释放rfsdir_t结构的rdr_blknr中指向的逻辑储存块
</span><span class="c1"></span>                <span class="n">rfs_del_blk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">dirp</span><span class="o">-&gt;</span><span class="n">rdr_blknr</span><span class="p">);</span>
                <span class="c1">//初始化rfsdir_t结构，实际上是清除其中的数据
</span><span class="c1"></span>                <span class="n">rfsdir_t_init</span><span class="p">(</span><span class="n">dirp</span><span class="p">);</span>
                <span class="c1">//设置rfsdir_t结构的类型为删除类型，表示它已经删除
</span><span class="c1"></span>                <span class="n">dirp</span><span class="o">-&gt;</span><span class="n">rdr_type</span> <span class="o">=</span> <span class="n">RDR_DEL_TYPE</span><span class="p">;</span>
                <span class="n">rets</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">dirp</span><span class="o">++</span><span class="p">;</span><span class="c1">//下一个rfsdir_t
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="n">rets</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="nl">err</span><span class="p">:</span>
    <span class="n">del_rootdirfile_blk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span><span class="n">rblkp</span><span class="p">);</span><span class="c1">//释放根目录文件
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">rets</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="打开文件">打开文件</h3>
<p>打开的文件会记录到 objnode_t 结构中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="cp">#define OBJN_TY_DEV 1</span><span class="c1">//设备类型
</span><span class="c1"></span><span class="cp">#define OBJN_TY_FIL 2</span><span class="c1">//文件类型
</span><span class="c1"></span><span class="cp">#define OBJN_TY_NUL 0</span><span class="c1">//默认类型
</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">s_OBJNODE</span>
<span class="p">{</span>
    <span class="n">spinlock_t</span>  <span class="n">on_lock</span><span class="p">;</span>
    <span class="n">list_h_t</span>    <span class="n">on_list</span><span class="p">;</span>
    <span class="n">sem_t</span>       <span class="n">on_complesem</span><span class="p">;</span>
    <span class="n">uint_t</span>      <span class="n">on_flgs</span><span class="p">;</span>
    <span class="n">uint_t</span>      <span class="n">on_stus</span><span class="p">;</span>
    <span class="c1">//……
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span>       <span class="n">on_fname</span><span class="p">;</span><span class="c1">//文件路径名指针
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span>       <span class="n">on_finode</span><span class="p">;</span><span class="c1">//文件对应的fimgrhd_t结构指针
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span>       <span class="n">on_extp</span><span class="p">;</span><span class="c1">//扩展所用
</span><span class="c1"></span><span class="p">}</span><span class="n">objnode_t</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>打开文件分成4步：</p>
<ol>
<li>从 objnode_t 结构的文件路径中提取纯文件名</li>
<li>获取根目录文件，在根目录文件中查找对应的 rfsdir_t 结构， 看文件是否存在</li>
<li>分配一个 4KB 缓存区，把该文件对应的 rfsdir_t 结构中指向的逻辑存储块读取到缓存区</li>
<li>把缓存区中的 fimgrhd_t 结构的地址保存到 objnode_t 结构的 on_finode 属性中</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//打开文件的接口函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">rfs_open_file</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">objnode_t</span><span class="o">*</span> <span class="n">obp</span> <span class="o">=</span> <span class="p">(</span><span class="n">objnode_t</span><span class="o">*</span><span class="p">)</span><span class="n">iopack</span><span class="p">;</span>
    <span class="c1">//检查objnode_t中的文件路径名
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_fname</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//调用打开文件的核心函数
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">fmdp</span> <span class="o">=</span> <span class="n">rfs_openfileblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="p">(</span><span class="n">char_t</span><span class="o">*</span><span class="p">)</span><span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_fname</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fmdp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//把返回的fimgrhd_t结构的地址保存到objnode_t中的on_finode字段中
</span><span class="c1"></span>    <span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_finode</span> <span class="o">=</span> <span class="n">fmdp</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">DFCOKSTUS</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">//打开文件的核心函数
</span><span class="c1"></span><span class="kt">void</span><span class="o">*</span> <span class="nf">rfs_openfileblk</span><span class="p">(</span><span class="n">device_t</span> <span class="o">*</span><span class="n">devp</span><span class="p">,</span> <span class="n">char_t</span><span class="o">*</span> <span class="n">fname</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">char_t</span> <span class="n">fne</span><span class="p">[</span><span class="n">DR_NM_MAX</span><span class="p">];</span> <span class="kt">void</span><span class="o">*</span> <span class="n">rets</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span><span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">hal_memset</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">fne</span><span class="p">,</span><span class="n">DR_NM_MAX</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">rfs_ret_fname</span><span class="p">(</span><span class="n">fne</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="c1">//从文件路径名中提取纯文件名
</span><span class="c1"></span>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">rblkp</span> <span class="o">=</span> <span class="n">get_rootdirfile_blk</span><span class="p">(</span><span class="n">devp</span><span class="p">);</span> <span class="c1">//获取根目录文件
</span><span class="c1"></span>    <span class="n">fimgrhd_t</span><span class="o">*</span> <span class="n">fmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">fimgrhd_t</span><span class="o">*</span><span class="p">)</span><span class="n">rblkp</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_type</span> <span class="o">!=</span> <span class="n">FMD_DIR_TYPE</span><span class="p">)</span> <span class="p">{</span><span class="c1">//判断根目录文件的类型是否合理 
</span><span class="c1"></span>        <span class="n">rets</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//判断根目录文件里有没有数据
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfwritebk</span> <span class="o">==</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fleblk</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fb_blkstart</span> <span class="o">&amp;&amp;</span> 
<span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfinwbkoff</span> <span class="o">==</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fileifstbkoff</span><span class="p">)</span> <span class="p">{</span> 
        <span class="n">rets</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">rfsdir_t</span><span class="o">*</span> <span class="n">dirp</span> <span class="o">=</span> <span class="p">(</span><span class="n">rfsdir_t</span><span class="o">*</span><span class="p">)((</span><span class="n">uint_t</span><span class="p">)(</span><span class="n">fmp</span><span class="p">)</span> <span class="o">+</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fileifstbkoff</span><span class="p">);</span> 
    <span class="kt">void</span><span class="o">*</span> <span class="n">maxchkp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)((</span><span class="n">uint_t</span><span class="p">)</span><span class="n">rblkp</span> <span class="o">+</span> <span class="n">FSYS_ALCBLKSZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(;(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">dirp</span> <span class="o">&lt;</span> <span class="n">maxchkp</span><span class="p">;)</span> <span class="p">{</span><span class="c1">//开始遍历文件对应的rfsdir_t结构
</span><span class="c1"></span>        <span class="k">if</span><span class="p">(</span><span class="n">dirp</span><span class="o">-&gt;</span><span class="n">rdr_type</span> <span class="o">==</span> <span class="n">RDR_FIL_TYPE</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//如果文件名相同就跳转到opfblk标号处运行
</span><span class="c1"></span>            <span class="k">if</span><span class="p">(</span><span class="n">rfs_strcmp</span><span class="p">(</span><span class="n">dirp</span><span class="o">-&gt;</span><span class="n">rdr_name</span><span class="p">,</span> <span class="n">fne</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">goto</span> <span class="n">opfblk</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">dirp</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//如果到这里说明没有找到该文件对应的rfsdir_t结构，所以设置返回值为NULL
</span><span class="c1"></span>    <span class="n">rets</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">opfblk</span><span class="p">:</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="n">new_buf</span><span class="p">(</span><span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span><span class="c1">//分配4KB大小的缓冲区
</span><span class="c1"></span>    <span class="c1">//读取该文件占用的逻辑储存块
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">read_rfsdevblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">dirp</span><span class="o">-&gt;</span><span class="n">rdr_blknr</span><span class="p">)</span> <span class="o">==</span> <span class="n">DFCERRSTUS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rets</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="k">goto</span> <span class="n">err1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">fimgrhd_t</span><span class="o">*</span> <span class="n">ffmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">fimgrhd_t</span><span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ffmp</span><span class="o">-&gt;</span><span class="n">fmd_type</span> <span class="o">==</span> <span class="n">FMD_NUL_TYPE</span> <span class="o">||</span> <span class="n">ffmp</span><span class="o">-&gt;</span><span class="n">fmd_fileifstbkoff</span> <span class="o">!=</span> <span class="mh">0x200</span><span class="p">)</span> <span class="p">{</span><span class="c1">//判断将要打开的文件是否合法
</span><span class="c1"></span>        <span class="n">rets</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="k">goto</span> <span class="n">err1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">rets</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span> <span class="k">goto</span> <span class="n">err</span><span class="p">;</span><span class="c1">//设置缓冲区首地址为返回值
</span><span class="c1"></span><span class="nl">err1</span><span class="p">:</span>
    <span class="n">del_buf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span> <span class="c1">//上面的步骤若出现问题就要释放缓冲区
</span><span class="c1"></span><span class="nl">err</span><span class="p">:</span>
    <span class="n">del_rootdirfile_blk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">rblkp</span><span class="p">);</span> <span class="c1">//释放根目录文件
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">rets</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="读写文件">读写文件</h3>
<p>读文件的大致流程如下 ：</p>
<ol>
<li>检查 objnode_t 结构中用于存放文件数据的缓冲区及其大小</li>
<li>检查 imgrhd_t 结构中文件相关信息</li>
<li>把文件的数据读取到 objnode_t 结构中指向的缓冲区中</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//读取文件数据的接口函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">rfs_read_file</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">objnode_t</span><span class="o">*</span> <span class="n">obp</span> <span class="o">=</span> <span class="p">(</span><span class="n">objnode_t</span><span class="o">*</span><span class="p">)</span><span class="n">iopack</span><span class="p">;</span>
    <span class="c1">//检查文件是否已经打开，以及用于存放文件数据的缓冲区和它的大小是否合理
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_finode</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_buf</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_bufsz</span> <span class="o">!=</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">)</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">rfs_readfileblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="p">(</span><span class="n">fimgrhd_t</span><span class="o">*</span><span class="p">)</span><span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_finode</span><span class="p">,</span> <span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_buf</span><span class="p">,</span> <span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_len</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//实际读取文件数据的函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">rfs_readfileblk</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span> <span class="n">fimgrhd_t</span><span class="o">*</span> <span class="n">fmp</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//检查文件的相关信息是否合理
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_sfblk</span> <span class="o">!=</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfwritebk</span> <span class="o">||</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfwritebk</span> <span class="o">!=</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fleblk</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fb_blkstart</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//检查读取文件数据的长度是否大于（4096-512）
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">FSYS_ALCBLKSZ</span> <span class="o">-</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fileifstbkoff</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//指向文件数据的开始地址
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">wrp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)((</span><span class="n">uint_t</span><span class="p">)</span><span class="n">fmp</span> <span class="o">+</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fileifstbkoff</span><span class="p">);</span>
    <span class="c1">//把文件开始处的数据复制len个字节到buf指向的缓冲区中
</span><span class="c1"></span>    <span class="n">hal_memcpy</span><span class="p">(</span><span class="n">wrp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">DFCOKSTUS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>写文件逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//写入文件数据的接口函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">rfs_write_file</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">objnode_t</span><span class="o">*</span> <span class="n">obp</span> <span class="o">=</span> <span class="p">(</span><span class="n">objnode_t</span><span class="o">*</span><span class="p">)</span><span class="n">iopack</span><span class="p">;</span>
    <span class="c1">//检查文件是否已经打开，以及用于存放文件数据的缓冲区和它的大小是否合理
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_finode</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_buf</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_bufsz</span> <span class="o">!=</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">rfs_writefileblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="p">(</span><span class="n">fimgrhd_t</span><span class="o">*</span><span class="p">)</span><span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_finode</span><span class="p">,</span> <span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_buf</span><span class="p">,</span> <span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_len</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//实际写入文件数据的函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">rfs_writefileblk</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span> <span class="n">fimgrhd_t</span><span class="o">*</span> <span class="n">fmp</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="n">uint_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//检查文件的相关信息是否合理
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_sfblk</span> <span class="o">!=</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfwritebk</span> <span class="o">||</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfwritebk</span> <span class="o">!=</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_fleblk</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">fb_blkstart</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//检查当前将要写入数据的偏移量加上写入数据的长度，是否大于等于4KB
</span><span class="c1"></span>    <span class="k">if</span><span class="p">((</span><span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfinwbkoff</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//指向将要写入数据的内存空间
</span><span class="c1"></span>    <span class="kt">void</span><span class="o">*</span> <span class="n">wrp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)((</span><span class="n">uint_t</span><span class="p">)</span><span class="n">fmp</span> <span class="o">+</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfinwbkoff</span><span class="p">);</span>
    <span class="c1">//把buf缓冲区中的数据复制len个字节到wrp指向的内存空间中去
</span><span class="c1"></span>    <span class="n">hal_memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">wrp</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_filesz</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span><span class="c1">//增加文件大小
</span><span class="c1"></span>    <span class="c1">//使fmd_curfinwbkoff指向下一次将要写入数据的位置
</span><span class="c1"></span>    <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfinwbkoff</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
    <span class="c1">//把文件数据写入到相应的逻辑储存块中，完成数据同步
</span><span class="c1"></span>    <span class="n">write_rfsdevblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">fmp</span><span class="p">,</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_curfwritebk</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">DFCOKSTUS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="关闭文件">关闭文件</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C">
<span class="c1">//关闭文件的接口函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">rfs_close_file</span><span class="p">(</span><span class="n">device_t</span><span class="o">*</span> <span class="n">devp</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">iopack</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">objnode_t</span><span class="o">*</span> <span class="n">obp</span> <span class="o">=</span> <span class="p">(</span><span class="n">objnode_t</span><span class="o">*</span><span class="p">)</span><span class="n">iopack</span><span class="p">;</span>
    <span class="c1">//检查文件是否已经打开了
</span><span class="c1"></span>    <span class="k">if</span><span class="p">(</span><span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_finode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="n">DFCERRSTUS</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">rfs_closefileblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">obp</span><span class="o">-&gt;</span><span class="n">on_finode</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//关闭文件的核心函数
</span><span class="c1"></span><span class="n">drvstus_t</span> <span class="nf">rfs_closefileblk</span><span class="p">(</span><span class="n">device_t</span> <span class="o">*</span><span class="n">devp</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">fblkp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//指向文件的fimgrhd_t结构
</span><span class="c1"></span>    <span class="n">fimgrhd_t</span><span class="o">*</span> <span class="n">fmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">fimgrhd_t</span><span class="o">*</span><span class="p">)</span><span class="n">fblkp</span><span class="p">;</span>
    <span class="c1">//完成文件数据的同步
</span><span class="c1"></span>    <span class="n">write_rfsdevblk</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">fblkp</span><span class="p">,</span> <span class="n">fmp</span><span class="o">-&gt;</span><span class="n">fmd_sfblk</span><span class="p">);</span>
    <span class="c1">//释放缓冲区
</span><span class="c1"></span>    <span class="n">del_buf</span><span class="p">(</span><span class="n">fblkp</span><span class="p">,</span> <span class="n">FSYS_ALCBLKSZ</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">DFCOKSTUS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="第三十五讲-linux如何管理文件">第三十五讲 Linux如何管理文件</h1>
<h2 id="vfs-虚拟文件系统">VFS 虚拟文件系统</h2>
<p>VFS（Virtual Filesystem）可以理解问通用文件系统的抽象层，
不管存储设备使用什么文件系统，都可以统一使用一套接口</p>
<p><img src="/image/play_os_in_action/35_1.webp" alt="VFS"></p>
<h2 id="vfs-数据结构">VFS 数据结构</h2>
<p>VFS为了屏蔽各个文件系统的差异，必须定义一组统一的数据结构，规范
各个文件系统的实现，每种结构都对应一套回调函数集合。</p>
<h3 id="超级块结构">超级块结构</h3>
<p>超级块结构是一个文件系统安装在 VFS 中的标识，其中包含了规定的标准信息，也有具体文件系统的特有信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">super_block</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_head</span>    <span class="n">s_list</span><span class="p">;</span> <span class="c1">//超级块链表
</span><span class="c1"></span>    <span class="n">dev_t</span>           <span class="n">s_dev</span><span class="p">;</span>     <span class="c1">//设备标识
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span>       <span class="n">s_blocksize_bits</span><span class="p">;</span><span class="c1">//以位为单位的块大小
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span>       <span class="n">s_blocksize</span><span class="p">;</span><span class="c1">//以字节为单位的块大小
</span><span class="c1"></span>    <span class="n">loff_t</span>          <span class="n">s_maxbytes</span><span class="p">;</span> <span class="c1">//一个文件最大多少字节
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">s_type</span><span class="p">;</span> <span class="c1">//文件系统类型
</span><span class="c1"></span>    <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span>   <span class="o">*</span><span class="n">s_op</span><span class="p">;</span><span class="c1">//超级块函数集合
</span><span class="c1"></span>    <span class="k">const</span> <span class="k">struct</span> <span class="n">dquot_operations</span>   <span class="o">*</span><span class="n">dq_op</span><span class="p">;</span><span class="c1">//磁盘限额函数集合
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span>       <span class="n">s_flags</span><span class="p">;</span><span class="c1">//挂载标志
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span>       <span class="n">s_magic</span><span class="p">;</span><span class="c1">//文件系统魔数
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">dentry</span>       <span class="o">*</span><span class="n">s_root</span><span class="p">;</span><span class="c1">//挂载目录
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">s_umount</span><span class="p">;</span><span class="c1">//卸载信号量
</span><span class="c1"></span>    <span class="kt">int</span>         <span class="n">s_count</span><span class="p">;</span><span class="c1">//引用计数
</span><span class="c1"></span>    <span class="n">atomic_t</span>        <span class="n">s_active</span><span class="p">;</span><span class="c1">//活动计数
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">s_bdev</span><span class="p">;</span><span class="c1">//块设备
</span><span class="c1"></span>    <span class="kt">void</span>            <span class="o">*</span><span class="n">s_fs_info</span><span class="p">;</span><span class="c1">//文件系统信息
</span><span class="c1"></span>    <span class="n">time64_t</span>           <span class="n">s_time_min</span><span class="p">;</span><span class="c1">//最小时间限制
</span><span class="c1"></span>    <span class="n">time64_t</span>           <span class="n">s_time_max</span><span class="p">;</span><span class="c1">//最大时间限制
</span><span class="c1"></span>    <span class="kt">char</span>            <span class="n">s_id</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>   <span class="c1">//标识名称
</span><span class="c1"></span>    <span class="n">uuid_t</span>          <span class="n">s_uuid</span><span class="p">;</span>     <span class="c1">//文件系统的UUID
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_lru</span>     <span class="n">s_dentry_lru</span><span class="p">;</span><span class="c1">//LRU方式挂载的目录 
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_lru</span>     <span class="n">s_inode_lru</span><span class="p">;</span><span class="c1">//LRU方式挂载的索引结点
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">mutex</span>        <span class="n">s_sync_lock</span><span class="p">;</span><span class="c1">//同步锁  
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span>    <span class="n">s_inodes</span><span class="p">;</span>   <span class="c1">//所有的索引节点
</span><span class="c1"></span>    <span class="n">spinlock_t</span>      <span class="n">s_inode_wblist_lock</span><span class="p">;</span><span class="c1">//回写索引节点的锁
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span>    <span class="n">s_inodes_wb</span><span class="p">;</span>    <span class="c1">//挂载所有要回写的索引节点
</span><span class="c1"></span><span class="p">}</span> <span class="n">__randomize_layout</span><span class="p">;</span>


<span class="k">struct</span> <span class="n">super_operations</span> <span class="p">{</span>
    <span class="c1">//分配一个新的索引结点结构
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
    <span class="c1">//销毁给定的索引节点
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//释放给定的索引节点
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//VFS在索引节点为脏(改变)时，会调用此函数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dirty_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
    <span class="c1">//该函数用于将给定的索引节点写入磁盘
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">);</span>
    <span class="c1">//在最后一个指向索引节点的引用被释放后，VFS会调用该函数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">drop_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">evict_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//减少超级块计数调用
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put_super</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//同步文件系统调用
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">sync_fs</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">);</span>
    <span class="c1">//释放超级块调用
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">freeze_super</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//释放文件系统调用
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">freeze_fs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">thaw_super</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unfreeze_fs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//VFS通过调用该函数，获取文件系统状态
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">statfs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//当指定新的安装选项重新安装文件系统时，VFS会调用此函数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remount_fs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//VFS调用该函数中断安装操作。该函数被网络文件系统使用，如NFS
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">umount_begin</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="目录结构">目录结构</h3>
<p><img src="/image/play_os_in_action/35_2.webp" alt="dentry"></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="c1">//快速字符串保存关于字符串的 &#34;元数据&#34;（即长度和哈希值）
</span><span class="c1"></span><span class="k">struct</span> <span class="n">qstr</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="p">{</span>
            <span class="n">HASH_LEN_DECLARE</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="n">u64</span> <span class="n">hash_len</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="c1">//指向名称字符串
</span><span class="c1"></span><span class="p">};</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d_flags</span><span class="p">;</span>       <span class="c1">//目录标志
</span><span class="c1"></span>    <span class="n">seqcount_spinlock_t</span> <span class="n">d_seq</span><span class="p">;</span>  <span class="c1">//锁
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">hlist_bl_node</span> <span class="n">d_hash</span><span class="p">;</span><span class="c1">//目录的哈希链表    
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_parent</span><span class="p">;</span>    <span class="c1">//指向父目录
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">qstr</span> <span class="n">d_name</span><span class="p">;</span>         <span class="c1">//目录名称
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">d_inode</span><span class="p">;</span>      <span class="c1">//指向目录文件的索引节点 
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">d_iname</span><span class="p">[</span><span class="n">DNAME_INLINE_LEN</span><span class="p">];</span>    <span class="c1">//短目录名
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">lockref</span> <span class="n">d_lockref</span><span class="p">;</span>   <span class="c1">//目录锁与计数
</span><span class="c1"></span>    <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="o">*</span><span class="n">d_op</span><span class="p">;</span><span class="c1">//目录的函数集
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">d_sb</span><span class="p">;</span>   <span class="c1">//指向超级块
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">d_time</span><span class="p">;</span>       <span class="c1">//时间
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">d_fsdata</span><span class="p">;</span>         <span class="c1">//指向具体文件系统的数据
</span><span class="c1"></span>    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_lru</span><span class="p">;</span>     <span class="c1">//LRU链表
</span><span class="c1"></span>        <span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">d_wait</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_child</span><span class="p">;</span>   <span class="c1">//挂入父目录的链表节点 
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_subdirs</span><span class="p">;</span> <span class="c1">//挂载所有子目录的链表
</span><span class="c1"></span><span class="p">}</span> <span class="n">__randomize_layout</span><span class="p">;</span>


<span class="c1">//快速字符串保存关于字符串的 &#34;元数据&#34;（即长度和哈希值）
</span><span class="c1"></span><span class="k">struct</span> <span class="n">qstr</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="p">{</span>
            <span class="n">HASH_LEN_DECLARE</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="n">u64</span> <span class="n">hash_len</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="c1">//指向名称字符串
</span><span class="c1"></span><span class="p">};</span>
<span class="k">struct</span> <span class="n">dentry</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d_flags</span><span class="p">;</span>       <span class="c1">//目录标志
</span><span class="c1"></span>    <span class="n">seqcount_spinlock_t</span> <span class="n">d_seq</span><span class="p">;</span>  <span class="c1">//锁
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">hlist_bl_node</span> <span class="n">d_hash</span><span class="p">;</span><span class="c1">//目录的哈希链表    
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_parent</span><span class="p">;</span>    <span class="c1">//指向父目录
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">qstr</span> <span class="n">d_name</span><span class="p">;</span>         <span class="c1">//目录名称
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">d_inode</span><span class="p">;</span>      <span class="c1">//指向目录文件的索引节点 
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">d_iname</span><span class="p">[</span><span class="n">DNAME_INLINE_LEN</span><span class="p">];</span>    <span class="c1">//短目录名
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">lockref</span> <span class="n">d_lockref</span><span class="p">;</span>   <span class="c1">//目录锁与计数
</span><span class="c1"></span>    <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="o">*</span><span class="n">d_op</span><span class="p">;</span><span class="c1">//目录的函数集
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">d_sb</span><span class="p">;</span>   <span class="c1">//指向超级块
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">d_time</span><span class="p">;</span>       <span class="c1">//时间
</span><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">d_fsdata</span><span class="p">;</span>         <span class="c1">//指向具体文件系统的数据
</span><span class="c1"></span>    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_lru</span><span class="p">;</span>     <span class="c1">//LRU链表
</span><span class="c1"></span>        <span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">d_wait</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_child</span><span class="p">;</span>   <span class="c1">//挂入父目录的链表节点 
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_subdirs</span><span class="p">;</span> <span class="c1">//挂载所有子目录的链表
</span><span class="c1"></span><span class="p">}</span> <span class="n">__randomize_layout</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="文件索引节点">文件索引节点</h3>
<p>inode结构表示一个文件索引节点，里面包含文件权限、文件所属用户、文件访问和修改时间、
文件数据块号等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">inode</span> <span class="p">{</span>
    <span class="n">umode_t</span>         <span class="n">i_mode</span><span class="p">;</span><span class="c1">//文件访问权限
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">short</span>      <span class="n">i_opflags</span><span class="p">;</span><span class="c1">//打开文件时的标志
</span><span class="c1"></span>    <span class="n">kuid_t</span>          <span class="n">i_uid</span><span class="p">;</span><span class="c1">//文件所属的用户id
</span><span class="c1"></span>    <span class="n">kgid_t</span>          <span class="n">i_gid</span><span class="p">;</span><span class="c1">//文件所属的用户组id
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span>        <span class="n">i_flags</span><span class="p">;</span><span class="c1">//标志
</span><span class="c1"></span>    <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span>   <span class="o">*</span><span class="n">i_op</span><span class="p">;</span><span class="c1">//inode函数集
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">super_block</span>  <span class="o">*</span><span class="n">i_sb</span><span class="p">;</span><span class="c1">//指向所属超级块
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">address_space</span>    <span class="o">*</span><span class="n">i_mapping</span><span class="p">;</span><span class="c1">//文件数据在内存中的页缓存
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">long</span>       <span class="n">i_ino</span><span class="p">;</span><span class="c1">//inode号
</span><span class="c1"></span>    <span class="n">dev_t</span>           <span class="n">i_rdev</span><span class="p">;</span><span class="c1">//实际设备标志符
</span><span class="c1"></span>    <span class="n">loff_t</span>          <span class="n">i_size</span><span class="p">;</span><span class="c1">//文件大小，以字节为单位
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">timespec64</span>   <span class="n">i_atime</span><span class="p">;</span><span class="c1">//文件访问时间
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">timespec64</span>   <span class="n">i_mtime</span><span class="p">;</span><span class="c1">//文件修改时间
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">timespec64</span>   <span class="n">i_ctime</span><span class="p">;</span><span class="c1">//最后修改时间
</span><span class="c1"></span>    <span class="n">spinlock_t</span>      <span class="n">i_lock</span><span class="p">;</span> <span class="c1">//保护inode的自旋锁
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">short</span>          <span class="n">i_bytes</span><span class="p">;</span><span class="c1">//使用的字节数
</span><span class="c1"></span>    <span class="n">u8</span>          <span class="n">i_blkbits</span><span class="p">;</span><span class="c1">//以位为单位的块大小；
</span><span class="c1"></span>    <span class="n">u8</span>          <span class="n">i_write_hint</span><span class="p">;</span>
    <span class="n">blkcnt_t</span>        <span class="n">i_blocks</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span>    <span class="n">i_io_list</span><span class="p">;</span>  
    <span class="k">struct</span> <span class="n">list_head</span>    <span class="n">i_lru</span><span class="p">;</span>      <span class="c1">//在缓存LRU中的链表节点
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span>    <span class="n">i_sb_list</span><span class="p">;</span><span class="c1">//在超级块中的链表节点
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">list_head</span>    <span class="n">i_wb_list</span><span class="p">;</span>
    <span class="n">atomic64_t</span>      <span class="n">i_version</span><span class="p">;</span><span class="c1">//版本号
</span><span class="c1"></span>    <span class="n">atomic64_t</span>      <span class="n">i_sequence</span><span class="p">;</span> 
    <span class="n">atomic_t</span>        <span class="n">i_count</span><span class="p">;</span><span class="c1">//计数
</span><span class="c1"></span>    <span class="n">atomic_t</span>        <span class="n">i_dio_count</span><span class="p">;</span><span class="c1">//直接io进程计数
</span><span class="c1"></span>    <span class="n">atomic_t</span>        <span class="n">i_writecount</span><span class="p">;</span><span class="c1">//写进程计数
</span><span class="c1"></span>    <span class="k">union</span> <span class="p">{</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span>    <span class="o">*</span><span class="n">i_fop</span><span class="p">;</span><span class="c1">//文件函数集合 
</span><span class="c1"></span>        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="n">file_lock_context</span>    <span class="o">*</span><span class="n">i_flctx</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">address_space</span>    <span class="n">i_data</span><span class="p">;</span>
    <span class="kt">void</span>            <span class="o">*</span><span class="n">i_private</span><span class="p">;</span> <span class="c1">//私有数据指针
</span><span class="c1"></span><span class="p">}</span> <span class="n">__randomize_layout</span><span class="p">;</span>


<span class="k">struct</span> <span class="n">inode_operations</span> <span class="p">{</span>
    <span class="c1">//VFS通过系统create()和open()接口来调用该函数，从而为dentry对象创建一个新的索引节点
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>
    <span class="c1">//该函数在特定目录中寻找索引节点，该索引节点要对应于dentry中给出的文件名
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">lookup</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//被系统link()接口调用，用来创建硬连接。硬链接名称由dentry参数指定
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">link</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//被系统unlink()接口调用，删除由目录项dentry链接的索引节点对象
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">unlink</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//被系统symlik()接口调用，创建符号连接，该符号连接名称由symname指定，连接对象是dir目录中的dentry目录项
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">symlink</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//被mkdir()接口调用，创建一个新目录。
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mkdir</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="c1">//被rmdir()接口调用，删除dentry目录项代表的文件
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rmdir</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//被mknod()接口调用，创建特殊文件(设备文件、命名管道或套接字)。
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mknod</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">dev_t</span><span class="p">);</span>
    <span class="c1">//VFS调用该函数来移动文件。文件源路径在old_dir目录中，源文件由old_dentry目录项所指定，目标路径在new_dir目录中，目标文件由new_dentry指定
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">rename</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//被系统readlink()接口调用，拷贝数据到特定的缓冲buffer中。拷贝的数据来自dentry指定的符号链接
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">readlink</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="c1">//被VFS调用，从一个符号连接查找他指向的索引节点
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">follow_link</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//在follow_link()调用之后，该函数由vfs调用进行清除工作
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">put_link</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//被VFS调用，修改文件的大小，在调用之前，索引节点的i_size项必须被设置成预期的大小
</span><span class="c1"></span>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">truncate</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//该函数用来检查给定的inode所代表的文件是否允许特定的访问模式，如果允许特定的访问模式，返回0，否则返回负值的错误码
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">permission</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="c1">//被notify_change接口调用，在修改索引节点之后，通知发生了改变事件
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//在通知索引节点需要从磁盘中更新时，VFS会调用该函数
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">getattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="p">);</span>
    <span class="c1">//被VFS调用，向dentry指定的文件设置扩展属性
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setxattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="c1">//被VFS调用，拷贝给定文件的扩展属性name对应的数值
</span><span class="c1"></span>    <span class="n">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">getxattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">);</span>
    <span class="c1">//该函数将特定文件所有属性列表拷贝到一个缓冲列表中
</span><span class="c1"></span>    <span class="n">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">listxattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">);</span>
    <span class="c1">//该函数从给定文件中删除指定的属性
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">removexattr</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>      
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="实例结构">实例结构</h3>
<p>进程打开的文件使用 file 结构表示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="k">struct</span> <span class="n">file</span> <span class="p">{</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">llist_node</span>   <span class="n">fu_llist</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">rcu_head</span>     <span class="n">fu_rcuhead</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">f_u</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">path</span>     <span class="n">f_path</span><span class="p">;</span> <span class="c1">//文件路径
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">inode</span>        <span class="o">*</span><span class="n">f_inode</span><span class="p">;</span>  <span class="c1">//文件对应的inode
</span><span class="c1"></span>    <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span>    <span class="o">*</span><span class="n">f_op</span><span class="p">;</span><span class="c1">//文件函数集合
</span><span class="c1"></span>    <span class="n">spinlock_t</span>      <span class="n">f_lock</span><span class="p">;</span>  <span class="c1">//自旋锁
</span><span class="c1"></span>    <span class="k">enum</span> <span class="n">rw_hint</span>        <span class="n">f_write_hint</span><span class="p">;</span>
    <span class="n">atomic_long_t</span>       <span class="n">f_count</span><span class="p">;</span><span class="c1">//文件对象计数据。
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span>        <span class="n">f_flags</span><span class="p">;</span><span class="c1">//文件标志
</span><span class="c1"></span>    <span class="n">fmode_t</span>         <span class="n">f_mode</span><span class="p">;</span><span class="c1">//文件权限
</span><span class="c1"></span>    <span class="k">struct</span> <span class="n">mutex</span>        <span class="n">f_pos_lock</span><span class="p">;</span><span class="c1">//文件读写位置锁
</span><span class="c1"></span>    <span class="n">loff_t</span>          <span class="n">f_pos</span><span class="p">;</span><span class="c1">//进程读写文件的当前位置
</span><span class="c1"></span>    <span class="n">u64</span>         <span class="n">f_version</span><span class="p">;</span><span class="c1">//文件版本
</span><span class="c1"></span>    <span class="kt">void</span>            <span class="o">*</span><span class="n">private_data</span><span class="p">;</span><span class="c1">//私有数据
</span><span class="c1"></span><span class="p">}</span> <span class="n">__randomize_layout</span>


<span class="k">struct</span> <span class="n">file_operations</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span><span class="c1">//所在的模块
</span><span class="c1"></span>    <span class="n">loff_t</span> <span class="p">(</span><span class="o">*</span><span class="n">llseek</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span><span class="c1">//调整读写偏移
</span><span class="c1"></span>    <span class="n">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span><span class="c1">//读
</span><span class="c1"></span>    <span class="n">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span><span class="c1">//写
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mmap</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span><span class="c1">//映射
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span><span class="c1">//打开
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">fl_owner_t</span> <span class="n">id</span><span class="p">);</span><span class="c1">//刷新
</span><span class="c1"></span>    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span><span class="c1">//关闭
</span><span class="c1"></span><span class="p">}</span> <span class="n">__randomize_layout</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>进程结构中有个文件表，这个表其实就是 file 结构的指针数组，进程每打开一个文件就会建立一个 file 结构实例，并将其地址放入数组中，最后
返回对应的数组下标，就是调用 open 函数返回的那个整数。</p>
<h3 id="四大对象结构的关系">四大对象结构的关系</h3>
<p><img src="/image/play_os_in_action/35_3.jpg" alt="object_relationship"></p>
<h2 id="文件操作">文件操作</h2>
<h3 id="打开文件-1">打开文件</h3>
<p><img src="/image/play_os_in_action/35_4.jpg" alt="open_file"></p>
<h3 id="读写文件-1">读写文件</h3>
<p>打开一个文件后，就可以进行读写操作了。读操作是数据从文件经由内核流向进程，
而写操作是数据从进程经由内核流向文件。读文件的流程如下：</p>
<p><img src="/image/play_os_in_action/35_5.webp" alt="read_file"></p>
<h3 id="关闭文件-1">关闭文件</h3>
<p><img src="/image/play_os_in_action/35_6.webp" alt="close_file"></p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://stackoverflow.com/questions/37146637/why-is-interrupt-disabled-between-spin-lock-and-spin-unlock-in-linux">why-is-interrupt-disabled-between-spin-lock-and-spin-unlock-in-linux</a></li>
<li><a href="https://blog.csdn.net/ll15982534415/article/details/118771286">快速建立hdi文件</a></li>
</ul>

    </div>

    
    


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://ppd0705.github.io/tags/c/">C</a>
          <a href="https://ppd0705.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/spot_perpetual_arbitrage/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">期现套利策略介绍和实现</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/getting_started_with_pencil_sketch/">
            <span class="next-text nav-default">[笔记]零基础素描入门</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "ppd0705/ppd0705.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="ppd0705@icloud.com" rel="me noopener" class="iconfont"
      title="email"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://twitter.com/ppd0705" rel="me noopener" class="iconfont"
      title="twitter"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1264 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M1229.8616 18.043658c0 0-117.852626 63.135335-164.151872 67.344358-105.225559-164.151872-505.082682-92.598492-437.738325 223.078185C278.622548 312.675223 89.216542 47.506814 89.216542 47.506814s-117.852626 189.406006 75.762402 345.139833C127.097743 396.85567 55.544363 371.601535 55.544363 371.601535S26.081207 535.753407 253.368414 615.724832c-21.045112 29.463156-113.643603 8.418045-113.643603 8.418045s25.254134 143.10676 231.496229 180.987961c-143.10676 130.479693-387.230056 92.598492-370.393967 105.225559 206.242095 189.406006 1119.599946 231.496229 1128.01799-643.98042C1179.353331 249.539887 1263.533778 123.269217 1263.533778 123.269217s-130.479693 37.881201-138.897738 33.672179C1225.652577 98.015083 1229.8616 18.043658 1229.8616 18.043658"></path>
</svg>

    </a>
  
    <a href="https://github.com/ppd0705" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>
  
    <a href="https://www.douban.com/people/ppd0705/" rel="me noopener" class="iconfont"
      title="douban"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M926.917973 37.80608C959.65184 37.80608 986.19392 64.34816 986.19392 97.082027L986.19392 926.917973C986.19392 959.65184 959.65184 986.19392 926.917973 986.19392L97.082027 986.19392C64.34816 986.19392 37.80608 959.65184 37.80608 926.917973L37.80608 97.082027C37.80608 64.34816 64.34816 37.80608 97.082027 37.80608zM176.653653 176.19968 176.653653 252.678827 825.658027 252.678827 825.658027 176.19968zM217.719467 316.146347 217.719467 628.08064 273.524053 628.08064 341.292373 770.39616 157.259093 770.39616 157.259093 845.417813 842.949973 845.417813 842.949973 770.39616 654.226773 770.39616 722.899627 628.08064 783.67744 628.08064 783.67744 316.146347zM684.885333 392.891733 684.885333 553.987413 312.576 553.987413 312.576 392.891733zM570.770773 770.39616 426.653013 770.39616 359.621973 628.08064 639.443627 628.08064z"></path>
</svg>

    </a>


<a href="https://ppd0705.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2019 -
    2022
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        PPD
        
      </span></span>

  
  
    <span id="busuanzi_container">
      访客数/访问量：<span id="busuanzi_value_site_uv"></span>/<span id="busuanzi_value_site_pv"></span>
    </span>
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>












</body>
</html>
