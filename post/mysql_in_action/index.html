<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>[笔记]MySQL实战45讲 - PPD&#39;s blog</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="PPD" />
  <meta name="description" content="第一讲：一条SQL查询语句的执行过程 MySQL架构 Server层 连接器： 管理连接，权限验证 分析器：词法分析，语法分析 优化器：索引选择，joi" />

  <meta name="keywords" content="PPD, blog" />






<meta name="generator" content="Hugo 0.86.0-DEV" />


<link rel="canonical" href="https://ppd0705.github.io/post/mysql_in_action/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.b3a8813c06e6d785beba22bf8264e174fa2cb3a396b22f9ba24e2c00c18aaf7f.css" integrity="sha256-s6iBPAbm14W&#43;uiK/gmThdPoss6OWsi&#43;bok4sAMGKr38=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="[笔记]MySQL实战45讲" />
<meta property="og:description" content="第一讲：一条SQL查询语句的执行过程 MySQL架构 Server层 连接器： 管理连接，权限验证 分析器：词法分析，语法分析 优化器：索引选择，joi" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ppd0705.github.io/post/mysql_in_action/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-08-25T21:05:35+08:00" />
<meta property="article:modified_time" content="2020-08-25T21:05:35+08:00" />

<meta itemprop="name" content="[笔记]MySQL实战45讲">
<meta itemprop="description" content="第一讲：一条SQL查询语句的执行过程 MySQL架构 Server层 连接器： 管理连接，权限验证 分析器：词法分析，语法分析 优化器：索引选择，joi"><meta itemprop="datePublished" content="2020-08-25T21:05:35+08:00" />
<meta itemprop="dateModified" content="2020-08-25T21:05:35+08:00" />
<meta itemprop="wordCount" content="16596">
<meta itemprop="keywords" content="MySQL," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="[笔记]MySQL实战45讲"/>
<meta name="twitter:description" content="第一讲：一条SQL查询语句的执行过程 MySQL架构 Server层 连接器： 管理连接，权限验证 分析器：词法分析，语法分析 优化器：索引选择，joi"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">PPD's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/about">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      PPD's blog
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://ppd0705.github.io/about">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">[笔记]MySQL实战45讲</h1>
      
      <div class="post-meta">
        <time datetime="2020-08-25" class="post-time">
          2020-08-25
        </time>
        <div class="post-category">
            <a href="https://ppd0705.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"> 计算机 </a>
            
          </div>
        <span class="more-meta"> 16596 words </span>
          <span class="more-meta"> 34 min read </span>

        
        
          <span id="busuanzi_container_page_pv">
            | 阅读 <span id="busuanzi_value_page_pv"></span>
          </span>
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#第一讲一条sql查询语句的执行过程">第一讲：一条SQL查询语句的执行过程</a>
              <ul>
                <li><a href="#mysql架构">MySQL架构</a></li>
              </ul>
            </li>
            <li><a href="#第二讲一条sql更新语句的执行过程">第二讲：一条SQL更新语句的执行过程</a>
              <ul>
                <li><a href="#两种日志">两种日志</a></li>
                <li><a href="#更新流程浅绿色框表示在innodb内部执行">更新流程（浅绿色框表示在InnoDB内部执行）</a></li>
              </ul>
            </li>
            <li><a href="#第三讲事务隔离">第三讲：事务隔离</a>
              <ul>
                <li><a href="#四种隔离级别">四种隔离级别</a></li>
                <li><a href="#示例">示例</a></li>
                <li><a href="#底层实现逻辑">底层实现逻辑</a></li>
              </ul>
            </li>
            <li><a href="#第四五讲索引">第四、五讲：索引</a>
              <ul>
                <li><a href="#索引的常见模型">索引的常见模型</a></li>
                <li><a href="#innodb的b索引模型">InnoDB的B+索引模型</a></li>
                <li><a href="#索引维护">索引维护</a></li>
                <li><a href="#重建表">重建表</a></li>
                <li><a href="#覆盖索引">覆盖索引</a></li>
                <li><a href="#最左前缀原则">最左前缀原则</a></li>
                <li><a href="#索引下推">索引下推</a></li>
                <li><a href="#其他">其他</a></li>
              </ul>
            </li>
            <li><a href="#第六讲全局锁和表锁">第六讲：全局锁和表锁</a>
              <ul>
                <li><a href="#全局锁">全局锁</a></li>
                <li><a href="#表级锁">表级锁</a></li>
                <li><a href="#评论区拾遗">评论区拾遗</a></li>
              </ul>
            </li>
            <li><a href="#第七讲-行锁">第七讲 行锁</a>
              <ul>
                <li><a href="#两阶段">两阶段</a></li>
                <li><a href="#死锁">死锁</a></li>
              </ul>
            </li>
            <li><a href="#第八讲-视图">第八讲 视图</a>
              <ul>
                <li><a href="#一致性读视图consistent-read-view">一致性读视图（consistent read view）</a></li>
              </ul>
            </li>
            <li><a href="#第九讲-唯一索引和普通索引的抉择">第九讲 唯一索引和普通索引的抉择</a>
              <ul>
                <li><a href="#查询过程">查询过程</a></li>
                <li><a href="#更新过程">更新过程</a></li>
              </ul>
            </li>
            <li><a href="#第十讲-mysql为什么会选错索引">第十讲 Mysql为什么会选错索引</a>
              <ul>
                <li><a href="#优化器选择索引的逻辑">优化器选择索引的逻辑</a></li>
                <li><a href="#选择异常和处理">选择异常和处理</a></li>
                <li><a href="#评论区拾遗-1">评论区拾遗</a></li>
              </ul>
            </li>
            <li><a href="#第十一讲-字符串索引">第十一讲 字符串索引</a>
              <ul>
                <li><a href="#前缀索引">前缀索引</a></li>
                <li><a href="#其他-1">其他</a></li>
              </ul>
            </li>
            <li><a href="#第十二讲-mysql为什么会抖动">第十二讲 MySQL为什么会“抖动”</a>
              <ul>
                <li><a href="#原因-flush刷脏页">原因： flush刷脏页</a></li>
                <li><a href="#触发场景">触发场景：</a></li>
                <li><a href="#刷脏页策略控制">刷脏页策略控制</a></li>
              </ul>
            </li>
            <li><a href="#第十三讲-表删除">第十三讲 表删除</a>
              <ul>
                <li><a href="#表">表</a></li>
                <li><a href="#行">行</a></li>
                <li><a href="#重建表-1">重建表</a></li>
                <li><a href="#评论区拾遗-2">评论区拾遗</a></li>
              </ul>
            </li>
            <li><a href="#第十四讲-count">第十四讲 count(*)</a></li>
            <li><a href="#第十五讲-日志和索引相关问题答疑">第十五讲 日志和索引相关问题答疑</a>
              <ul>
                <li><a href="#日志相关">日志相关</a></li>
              </ul>
            </li>
            <li><a href="#第十六讲-order-by">第十六讲 order by</a>
              <ul>
                <li><a href="#全字段排序">全字段排序</a></li>
                <li><a href="#rowid排序">rowid排序</a></li>
                <li><a href="#课后问题-sessiona-最后看到的a是多少">课后问题: sessionA 最后看到的A是多少</a></li>
              </ul>
            </li>
            <li><a href="#第十七讲-随机消息">第十七讲 随机消息</a>
              <ul>
                <li><a href="#order-by-rand">order by rand</a></li>
                <li><a href="#随机排序法">随机排序法</a></li>
              </ul>
            </li>
            <li><a href="#第十八讲-隐式转换">第十八讲 隐式转换</a></li>
            <li><a href="#第十九讲-常见的阻塞场景">第十九讲 常见的阻塞场景</a>
              <ul>
                <li><a href="#查询长时间不返回">查询长时间不返回</a></li>
                <li><a href="#查询慢">查询慢</a></li>
              </ul>
            </li>
            <li><a href="#第二十讲-幻读">第二十讲 幻读</a></li>
            <li><a href="#第二十一讲">第二十一讲</a>
              <ul>
                <li><a href="#加锁规则">加锁规则</a></li>
                <li><a href="#案例一-等值查询间隙锁">案例一 等值查询间隙锁</a></li>
                <li><a href="#案例二-非唯一索引等值锁">案例二 非唯一索引等值锁</a></li>
                <li><a href="#案例三-主键索引范围锁">案例三 主键索引范围锁</a></li>
                <li><a href="#案例四-非唯一索引范围锁">案例四 非唯一索引范围锁</a></li>
                <li><a href="#案例五-唯一索引范围的bug">案例五 唯一索引范围的bug</a></li>
                <li><a href="#案例六-limit语句加锁">案例六 limit语句加锁</a></li>
                <li><a href="#案例七-死锁案例">案例七 死锁案例</a></li>
                <li><a href="#案例八">案例八</a></li>
              </ul>
            </li>
            <li><a href="#第二十二讲-饮鸩止渴的方法">第二十二讲 饮鸩止渴的方法</a>
              <ul>
                <li><a href="#max_connectio超标">max_connectio超标</a></li>
                <li><a href="#慢查询">慢查询</a></li>
                <li><a href="#语句没有写好">语句没有写好</a></li>
              </ul>
            </li>
            <li><a href="#第二十三讲-mysql如何保证数据不丢">第二十三讲 MySQL如何保证数据不丢</a>
              <ul>
                <li><a href="#binlog的写入机制">binlog的写入机制</a></li>
                <li><a href="#redo-log写入机制">redo log写入机制</a></li>
              </ul>
            </li>
            <li><a href="#第二十四讲-mysql如何保证主从一致">第二十四讲 MySQL如何保证主从一致</a>
              <ul>
                <li><a href="#从库同步逻辑">从库同步逻辑</a></li>
                <li><a href="#binlog">binlog</a></li>
              </ul>
            </li>
            <li><a href="#第二十五讲-mysql如何保证高可用">第二十五讲 MySQL如何保证高可用</a>
              <ul>
                <li><a href="#主备延迟">主备延迟</a></li>
                <li><a href="#延迟引入的原因">延迟引入的原因</a></li>
                <li><a href="#主备切换可靠性优先">主备切换（可靠性优先）</a></li>
                <li><a href="#主备切换可用性优先">主备切换（可用性优先）</a></li>
              </ul>
            </li>
            <li><a href="#第二十六讲-备库为什么会延迟好几个小时">第二十六讲 备库为什么会延迟好几个小时</a>
              <ul>
                <li><a href="#并行复制策略">并行复制策略</a></li>
              </ul>
            </li>
            <li><a href="#第二十七讲-主库出问题了从库怎么办">第二十七讲 主库出问题了，从库怎么办</a></li>
            <li><a href="#第二十八讲-读写分离有那些坑">第二十八讲 读写分离有那些坑</a>
              <ul>
                <li><a href="#常用读写分离方案">常用读写分离方案</a></li>
                <li><a href="#常用处理过期度的方案">常用处理过期度的方案</a></li>
              </ul>
            </li>
            <li><a href="#第29讲-如何判断数据库是否出问题了">第29讲 如何判断数据库是否出问题了</a>
              <ul>
                <li><a href="#select-1">select 1</a></li>
                <li><a href="#查表判断">查表判断</a></li>
                <li><a href="#更新判断">更新判断</a></li>
                <li><a href="#内部统计">内部统计</a></li>
                <li><a href="#检测">检测</a></li>
              </ul>
            </li>
            <li><a href="#第30讲-用动态的观点看加锁">第30讲 用动态的观点看加锁</a>
              <ul>
                <li><a href="#不等号条件里面的等值查询">不等号条件里面的等值查询</a></li>
                <li><a href="#等值查询的过程">等值查询的过程</a></li>
                <li><a href="#查看死锁">查看死锁</a></li>
                <li><a href="#锁范围变化">锁范围变化</a></li>
                <li><a href="#评论收集">评论收集</a></li>
              </ul>
            </li>
            <li><a href="#第31讲-删除数据除了跑路还能怎么办">第31讲 删除数据除了跑路还能怎么办</a>
              <ul>
                <li><a href="#删除行">删除行</a></li>
                <li><a href="#删表库">删表/库</a></li>
                <li><a href="#评论收集-1">评论收集</a></li>
              </ul>
            </li>
            <li><a href="#第32讲-为何有kill不掉的语句">第32讲 为何有kill不掉的语句</a>
              <ul>
                <li><a href="#两个kill命令">两个kill命令</a></li>
                <li><a href="#kill无效的情况">kill无效的情况</a></li>
                <li><a href="#客户端ctrlc">客户端ctrl+c</a></li>
              </ul>
            </li>
            <li><a href="#第33讲-查太多数据内存会不会打爆">第33讲 查太多数据，内存会不会打爆？</a></li>
            <li><a href="#第34讲-可不可以用join">第34讲 可不可以用join</a>
              <ul>
                <li><a href="#index-nested-loop-join">Index Nested-Loop Join</a></li>
                <li><a href="#simple-nested-loop-join">Simple Nested-Loop Join</a></li>
                <li><a href="#block-nested-loop-join">Block Nested-Loop Join</a></li>
                <li><a href="#结论">结论</a></li>
                <li><a href="#案例">案例</a></li>
              </ul>
            </li>
            <li><a href="#第35讲-join优化">第35讲 join优化</a>
              <ul>
                <li><a href="#multi-range-read优化">Multi-Range Read优化</a></li>
                <li><a href="#batched-key-accessbka">Batched Key Access(BKA)</a></li>
                <li><a href="#bnl性能问题">BNL性能问题</a></li>
                <li><a href="#bnl转bka">BNL转BKA</a></li>
              </ul>
            </li>
            <li><a href="#第36讲-为什么临时表可以重名">第36讲 为什么临时表可以重名</a>
              <ul>
                <li><a href="#临时表不一定是内存表">临时表不一定是内存表</a></li>
                <li><a href="#临时表的特性">临时表的特性</a></li>
                <li><a href="#应用">应用</a></li>
                <li><a href="#为什么临时表可以重名">为什么临时表可以重名</a></li>
                <li><a href="#主备复制">主备复制</a></li>
              </ul>
            </li>
            <li><a href="#第37讲-什么时候会使用内部临时表">第37讲 什么时候会使用内部临时表</a>
              <ul>
                <li><a href="#union执行流程">union执行流程</a></li>
                <li><a href="#group-by执行流程">group by执行流程</a></li>
                <li><a href="#group-by优化---索引">group by优化&mdash;索引</a></li>
                <li><a href="#group-by优化---直接排序">group by优化&mdash;直接排序</a></li>
              </ul>
            </li>
            <li><a href="#第38讲-要不要用memory引擎">第38讲 要不要用Memory引擎</a>
              <ul>
                <li><a href="#memory引擎的区别">memory引擎的区别</a></li>
                <li><a href="#使用b-tree索引">使用B-tree索引</a></li>
                <li><a href="#内存表的局限">内存表的局限</a></li>
                <li><a href="#使用场景">使用场景</a></li>
              </ul>
            </li>
            <li><a href="#第39讲-自增主键为什么不是连续的">第39讲 自增主键为什么不是连续的</a>
              <ul>
                <li><a href="#自增值的存储">自增值的存储</a></li>
                <li><a href="#自增值的修改机制">自增值的修改机制</a></li>
                <li><a href="#自增主键不连续的原因">自增主键不连续的原因</a></li>
                <li><a href="#表自增锁释放策略-innodb_autoinc_lock_mode">表自增锁释放策略 innodb_autoinc_lock_mode</a></li>
                <li><a href="#批量申请自增id策略">批量申请自增id策略</a></li>
              </ul>
            </li>
            <li><a href="#第40讲-insert语句锁为什么这么多">第40讲 insert语句锁为什么这么多</a></li>
            <li><a href="#第41讲-怎么快速复制一张表">第41讲 怎么快速复制一张表</a>
              <ul>
                <li><a href="#使用mysqldump">使用mysqldump</a></li>
                <li><a href="#导出csv文件">导出csv文件</a></li>
                <li><a href="#物理拷贝">物理拷贝</a></li>
                <li><a href="#对比">对比</a></li>
              </ul>
            </li>
            <li><a href="#第42讲-grant">第42讲 grant</a>
              <ul>
                <li><a href="#全局权限">全局权限</a></li>
                <li><a href="#db权限">db权限</a></li>
                <li><a href="#表权限和列权限">表权限和列权限</a></li>
                <li><a href="#flush_privileges">flush_privileges</a></li>
              </ul>
            </li>
            <li><a href="#第43讲-要不要使用分区表">第43讲 要不要使用分区表</a></li>
            <li><a href="#第44讲-答疑三">第44讲 答疑三</a>
              <ul>
                <li><a href="#join的写法">join的写法</a></li>
                <li><a href="#distinct和group-by的性能">distinct和group by的性能</a></li>
                <li><a href="#备库自增主键问题">备库自增主键问题</a></li>
              </ul>
            </li>
            <li><a href="#第45讲-自增id用完怎么办">第45讲 自增id用完怎么办</a>
              <ul>
                <li><a href="#表定义自增id">表定义自增id</a></li>
                <li><a href="#系统自增row_id">系统自增row_id</a></li>
                <li><a href="#thread_id">thread_id</a></li>
              </ul>
            </li>
            <li><a href="#参考">参考</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h3 id="第一讲一条sql查询语句的执行过程">第一讲：一条SQL查询语句的执行过程</h3>
<h4 id="mysql架构">MySQL架构</h4>
<p><img src="/image/mysql_in_action/29691D8C-C1EF-4987-88EA-E83320479CDE.png" alt="0d2070e8f84c4801adbfa03bda1f98d9"></p>
<h5 id="server层">Server层</h5>
<ul>
<li>连接器： 管理连接，权限验证</li>
<li>分析器：词法分析，语法分析</li>
<li>优化器：索引选择，join顺序选择，执行计划制定</li>
<li>执行器：操作引擎返回结果</li>
</ul>
<h5 id="存储引擎层">存储引擎层</h5>
<ul>
<li>负责数据的存储和提取</li>
</ul>
<h3 id="第二讲一条sql更新语句的执行过程">第二讲：一条SQL更新语句的执行过程</h3>
<h4 id="两种日志">两种日志</h4>
<ul>
<li>redo log: InnoDB引擎特有的的日志系统；大小固定，循环写；物理日志，记录的是数据页做的改动</li>
<li>binlog: Server层的日志, 逻辑日志，记录的是sql语句的原始逻辑</li>
</ul>
<h4 id="更新流程浅绿色框表示在innodb内部执行">更新流程（浅绿色框表示在InnoDB内部执行）</h4>
<p><img src="/image/mysql_in_action/02DEDD8D-FBB3-492D-8A4F-C51E0EBDB0D0.png" alt="2e5bff4910ec189fe1ee6e2ecc7b4bbe"></p>
<ul>
<li>redo log 两阶段提交</li>
<li>相关参数设定：
<ul>
<li>innodb_flush_log_at_trx_commit=1表示每次事务的redo log 都持久化到磁盘</li>
<li>sync_binlog=1表示每次的binlog都持久化到磁盘</li>
</ul>
</li>
</ul>
<h3 id="第三讲事务隔离">第三讲：事务隔离</h3>
<h4 id="四种隔离级别">四种隔离级别</h4>
<ul>
<li>读未提交(read uncommitted)：
<ul>
<li>事务还未提交时能被其他事务看到</li>
</ul>
</li>
<li>读提交(read committed)：
<ul>
<li>事务提交后才能被其他事务看到</li>
</ul>
</li>
<li>可重复读(repeatable read)(默认选项)：
<ul>
<li>事务执行过程中看到的数据和该事务启动时一致</li>
</ul>
</li>
<li>串行化(serializable)：
<ul>
<li>读写冲突的时候，后一个事务必须等前一个事务执行完成才能继续执行</li>
</ul>
</li>
</ul>
<h4 id="示例">示例</h4>
<h5 id="初始化">初始化</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">CREATE</span><span class="w"> </span><span class="k">DATABASE</span><span class="w"> </span><span class="n">TEST</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="k">c</span><span class="w"> </span><span class="nb">int</span><span class="p">)</span><span class="w"> </span><span class="n">engine</span><span class="w"> </span><span class="n">InnoDB</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">T</span><span class="p">(</span><span class="k">c</span><span class="p">)</span><span class="w"> </span><span class="k">values</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h5 id="对于如下示例在不同的隔离级别c1c2c3的结果分别是什么">对于如下示例，在不同的隔离级别<code>c1</code>/<code>c2</code>/<code>c3</code>的结果分别是什么？</h5>
<table>
<thead>
<tr>
<th style="text-align:center">事务A</th>
<th style="text-align:center">事务B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">start transaction;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">select * from t;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">start transaction;</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">update t set c = c + 1 where c = 1;</td>
</tr>
<tr>
<td style="text-align:center">select * from t;(<code>c1</code>)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">commit;</td>
</tr>
<tr>
<td style="text-align:center">select * from t;(<code>c2</code>)</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">commit;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">select * from t;(<code>c3</code>)</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<ul>
<li><em>read uncommitted</em> : 均为2</li>
<li><em>read committed</em> : c1为1，c2/c3为2</li>
<li><em>repeatable read</em> : c1/c2为1, c3为2</li>
<li><em>serializable</em> : c1/c2为1, c3为2 (事务B update时阻塞)</li>
</ul>
<h4 id="底层实现逻辑">底层实现逻辑</h4>
<ul>
<li>“读未提交”隔离级别下直接返回记录上的最新值</li>
<li>“串行化”隔离级别下直接用加锁的方式来避免并行访问</li>
<li>“读已提交”事务在每次Read操作时，都会建立Read View</li>
<li>“可重复读”在事务第一次Read时建立一个视图，整个事务存在期间都用这个视图,但是update操作时会读当前并更新视图</li>
</ul>
<h3 id="第四五讲索引">第四、五讲：索引</h3>
<h4 id="索引的常见模型">索引的常见模型</h4>
<ul>
<li>哈希表: 适合等值查询的场景</li>
<li>有序数组：适用于静态存储，等值查询和范围查询都适用</li>
<li>搜索树</li>
</ul>
<h4 id="innodb的b索引模型">InnoDB的B+索引模型</h4>
<ul>
<li>主键索引(clustered index)：叶子节点存有整行数据</li>
<li>二级索引（secondary index）： 叶子节点存有主键的值</li>
</ul>
<h4 id="索引维护">索引维护</h4>
<ul>
<li>自增主键是追加操作，不会触发叶子节点的分裂</li>
<li>主键长度越小，二级索引的叶子节点就越小，更节省空间</li>
<li>数据页太小会加深层数，太大会增加加载时间和查询时间</li>
</ul>
<h4 id="重建表">重建表</h4>
<p>alter table T engine=InnoDB 减少数据空洞</p>
<h4 id="覆盖索引">覆盖索引</h4>
<p>所查询的数据在索引树上，无需再回表</p>
<h4 id="最左前缀原则">最左前缀原则</h4>
<p>索引（a, b）可用于查询条件有a或a和b的情况</p>
<h4 id="索引下推">索引下推</h4>
<p>对索引中包含的字段先做判断， 减少回表次数，如查询 <code>select * from table where name like &quot;王%&quot; and age = 10</code>, 索引为（name, age）,有索引下推时会对索引中的age做判断而非在回表后再判断</p>
<h4 id="其他">其他</h4>
<ul>
<li>主键为(a, b)的表索引c和索引（c, a）等价</li>
</ul>
<h3 id="第六讲全局锁和表锁">第六讲：全局锁和表锁</h3>
<h4 id="全局锁">全局锁</h4>
<ul>
<li>效果： 加上全局锁时整个服务处于只读状态</li>
<li>加锁命令：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="o">#</span><span class="w"> </span><span class="n">FTWRL</span><span class="w">
</span><span class="w"></span><span class="n">Flush</span><span class="w"> </span><span class="n">tables</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="k">read</span><span class="w"> </span><span class="k">lock</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>典型使用场景：做全库逻辑备份</li>
</ul>
<p>注:</p>
<ul>
<li>
<p>对于使用InnoDB的库备份是可用 <code>msyqldump --single-transaction</code></p>
</li>
<li>
<p>全库只读也可用<code>set global readonly=true</code>的方式,但这个对超级用户无效</p>
</li>
</ul>
<h4 id="表级锁">表级锁</h4>
<p>分类有2种： 表锁和元数据锁(MDL：meta data lock)</p>
<h5 id="表锁">表锁</h5>
<ul>
<li>语法：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="o">#</span><span class="w"> </span><span class="err">加锁</span><span class="w">
</span><span class="w"></span><span class="k">lock</span><span class="w"> </span><span class="n">tables</span><span class="w"> </span><span class="k">table_name</span><span class="w"> </span><span class="k">read</span><span class="o">/</span><span class="k">write</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="o">#</span><span class="w"> </span><span class="err">解锁</span><span class="w">
</span><span class="w"></span><span class="n">unlock</span><span class="w"> </span><span class="n">tables</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>效果：
<ul>
<li>读锁：其他session写会阻塞,当前session不可写，不可访问其他表</li>
<li>写锁: 其他session读写都会阻塞，当前session不可以访问其他表</li>
</ul>
</li>
</ul>
<h5 id="元数据mld锁">元数据MLD锁</h5>
<ul>
<li>
<p>获取： 自动获取</p>
</li>
<li>
<p>类型</p>
<ul>
<li>读锁：增删改查操作</li>
<li>写锁：变更表结构</li>
</ul>
</li>
<li>
<p>互斥性</p>
<ul>
<li>读锁之间不互斥</li>
<li>读写锁之间、写写锁之间互斥，会发生阻塞</li>
</ul>
</li>
</ul>
<h4 id="评论区拾遗">评论区拾遗</h4>
<ul>
<li>OnlineDDL 过程
<ol>
<li>拿MDL写锁  (避免并发DDL)</li>
<li>降级成MDL读锁</li>
<li>真正做DDL</li>
<li>升级成MDL写锁</li>
<li>释放MDL锁</li>
</ol>
</li>
</ul>
<h3 id="第七讲-行锁">第七讲 行锁</h3>
<p>行锁是由引擎层实现的，如MyISAM就不支持</p>
<h4 id="两阶段">两阶段</h4>
<ul>
<li>执行相应语句时加上，事务结束时释放</li>
<li>尽量将最可能锁冲突的的语句放在事务最后</li>
</ul>
<h4 id="死锁">死锁</h4>
<ul>
<li>参数innodb_lock_wait_timeout 锁超时， 默认50s</li>
<li>参数innodb_deadlock_detect,检测死锁，默认打开，复杂度O(n2)，所以尽量控制并发事务量</li>
<li>死锁检测只会在阻塞时才会执行，只会检测依赖的事务</li>
</ul>
<h3 id="第八讲-视图">第八讲 视图</h3>
<p><img src="/image/mysql_in_action/5A850DE9-FF8F-4935-95F9-26CE332387A3.png" alt="68d08d277a6f7926a41cc5541d3dfced"></p>
<h4 id="一致性读视图consistent-read-view">一致性读视图（consistent read view）</h4>
<ul>
<li>用于RC和RR隔离级别的实现</li>
<li>begin/start transaction并不会马上启动事务，需要等到第一个执行操作才启动，显式启动可用start transaction with consistent snapshot</li>
<li>每行数据可能有多个版本，每个版本有自己的trx_id(即对应的事务id)，旧的版本需要根据当前版本和undo log计算出了</li>
<li>更新数据都是先读后写，读指读当前的值（current read）, 如果当前的记录的行锁被其他事务占用，就需要等待</li>
<li>读语句加上lock in share mode或for update 也是当前读</li>
<li>读提交隔离级别下，每个语句执行前都会重新算出一个视图</li>
<li>重复读隔离级别下， 第一个执行操作时会建立一个视图，后续复用这个视图</li>
</ul>
<h3 id="第九讲-唯一索引和普通索引的抉择">第九讲 唯一索引和普通索引的抉择</h3>
<h4 id="查询过程">查询过程</h4>
<ul>
<li>数据按页读入内存，InnoDB默认页大小为16KB</li>
</ul>
<h4 id="更新过程">更新过程</h4>
<ul>
<li>
<p>当数据在内存中时直接更新</p>
</li>
<li>
<p>当数据不在内存中， 将更新操作缓存在change buffer中，之后再merge, change buffer减少了随机磁盘访问</p>
</li>
<li>
<p>merge的流程</p>
<ul>
<li>从磁盘读入数据页到内存</li>
<li>依次更新change buffer中相关记录</li>
<li>将内存数据的变更和change buffer的变更写入redo log</li>
</ul>
</li>
<li>
<p>唯一索引需要将数据页读入内存中才能判断唯一性，故不能使用change buffer</p>
</li>
<li>
<p>对于普通索引，如果是写多读少的场景如日志系统，适合change buffer</p>
</li>
<li>
<p>change buffer用的是buffer pool里面的内存，innodb_change_buffer_max_size设置其百分比</p>
</li>
<li>
<p>redo log 会记录在内存数据页更新数据的操作和change buffer的操作；redo log 主要节省的是随机写磁盘的IO消耗，改为顺序写，而change buffer主要节省的是随机读存盘的IO消耗</p>
</li>
<li>
<p>change buffer的数据会持久化到ibdata系统表里，内存不足或checkpoint的时候会触发落盘</p>
</li>
</ul>
<h3 id="第十讲-mysql为什么会选错索引">第十讲 Mysql为什么会选错索引</h3>
<h4 id="优化器选择索引的逻辑">优化器选择索引的逻辑</h4>
<p>采样统计预估扫描行情</p>
<ul>
<li>
<p>方式：选择N个数据页，统计这些页面的不同值，得到一个平均值，然后乘以这个索引的页数，得到这个索引的基数cardinality，基数越大，表示区分度也好</p>
</li>
<li>
<p>更新： 当变更的数据行数超过1/M，会自动触发重新做索引统计</p>
</li>
</ul>
<p>回表也会被优化器列入考虑因素</p>
<p>analyze table 来解决统计信息不准确的问题</p>
<h4 id="选择异常和处理">选择异常和处理</h4>
<ul>
<li>使用force index</li>
<li>修改语句，引导MySQL使用我们期望的索引</li>
<li>新建更适合的索引或者删除多余的索引</li>
</ul>
<h4 id="评论区拾遗-1">评论区拾遗</h4>
<ul>
<li>where a in (1,3) and b in (2, 4)会转换成 (a=1 and b=2) or (a=1 and b=4) or (a=3 and b=2) or (a=3 and b=4)</li>
</ul>
<h3 id="第十一讲-字符串索引">第十一讲 字符串索引</h3>
<h4 id="前缀索引">前缀索引</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">alter</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">SUser</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="n">index2</span><span class="p">(</span><span class="n">email</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>使用前缀索引，定义好长度，可以做到既省空间又不用额外增加太多的查询成本，使用前缀索引可能会损失区分度，需要预设一个可接受的比例</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="c1">--- 查看不同长度前缀的数量
</span><span class="c1"></span><span class="k">select</span><span class="w"> 
</span><span class="w">    </span><span class="k">count</span><span class="p">(</span><span class="k">distinct</span><span class="w"> </span><span class="k">left</span><span class="p">(</span><span class="n">filed</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="err">）</span><span class="k">as</span><span class="w"> </span><span class="n">L4</span><span class="p">,</span><span class="w"> 
</span><span class="w">    </span><span class="k">count</span><span class="p">(</span><span class="k">distinct</span><span class="w"> </span><span class="k">left</span><span class="p">(</span><span class="n">filed</span><span class="p">,,</span><span class="mi">5</span><span class="p">)</span><span class="err">）</span><span class="k">as</span><span class="w"> </span><span class="n">L5</span><span class="p">,</span><span class="w"> 
</span><span class="w">    </span><span class="k">count</span><span class="p">(</span><span class="k">distinct</span><span class="w"> </span><span class="k">left</span><span class="p">(</span><span class="n">filed</span><span class="p">,,</span><span class="mi">6</span><span class="p">)</span><span class="err">）</span><span class="k">as</span><span class="w"> </span><span class="n">L6</span><span class="p">,</span><span class="w"> 
</span><span class="w">    </span><span class="k">count</span><span class="p">(</span><span class="k">distinct</span><span class="w"> </span><span class="k">left</span><span class="p">(</span><span class="n">filed</span><span class="p">,,</span><span class="mi">7</span><span class="p">)</span><span class="err">）</span><span class="k">as</span><span class="w"> </span><span class="n">L7</span><span class="w">
</span><span class="w"></span><span class="k">from</span><span class="w"> </span><span class="n">SUser</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>使用前缀索引用不上覆盖索引，对应字段只存了前缀部分</p>
<h4 id="其他-1">其他</h4>
<ul>
<li>如果前缀区分度比后缀区分度低，可倒序存储再建前缀索引提高区分度</li>
<li>可以增加一个int32字段存hash值</li>
</ul>
<h3 id="第十二讲-mysql为什么会抖动">第十二讲 MySQL为什么会“抖动”</h3>
<h4 id="原因-flush刷脏页">原因： flush刷脏页</h4>
<h4 id="触发场景">触发场景：</h4>
<ul>
<li>redo log写满了</li>
<li>系统内存不足</li>
<li>Mysql空闲时</li>
<li>Mysql正常关闭时</li>
</ul>
<h4 id="刷脏页策略控制">刷脏页策略控制</h4>
<ul>
<li>innodb_io_capacity： 磁盘IO能力，可设成磁盘的IOPS，IOPS可用如下命令测试</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"> fio -filename<span class="o">=</span><span class="nv">$filename</span> -direct<span class="o">=</span><span class="m">1</span> -iodepth <span class="m">1</span> -thread -rw<span class="o">=</span>randrw -ioengine<span class="o">=</span>psync -bs<span class="o">=</span>16k -size<span class="o">=</span>500M -numjobs<span class="o">=</span><span class="m">10</span> -runtime<span class="o">=</span><span class="m">10</span> -group_reporting -name<span class="o">=</span>mytest 
</code></pre></td></tr></table>
</div>
</div><ul>
<li>刷盘速度参考因素： 脏页比例，redo log写盘速度</li>
<li>innodb_max_dirty_pages_pct 脏页比例上限，默认值75%， 计算方式Innodb_buffer_pool_pages_dirty/Innodb_buffer_pool_pages_total</li>
<li>innodb_flush_neighbors控制是否把相邻的脏页也顺便一起flush, MySQL8.0默认为0</li>
<li>LSN(log sequence number)日志序号 可以用show engine innodb status 查看</li>
</ul>
<h3 id="第十三讲-表删除">第十三讲 表删除</h3>
<h4 id="表">表</h4>
<ul>
<li>参数innodb_file_per_table控制每个表是否单独存一个文件， 默认为on, 表数据存储在一个以.ibd为后缀的文件中,如果使用drop table, 会直接删除这个文件</li>
</ul>
<h4 id="行">行</h4>
<ul>
<li>删除数据时只是把对应数据标记为已删除，对应位置可以复用，符合范围条件的数据可以复用这个空间</li>
<li>如果整个数据页都标记为删除，可以复用到任何位置</li>
<li>如果相邻的两个数据页利用率都很小，系统会将数据合并到一个页，另外一个数据页被标记为可复用</li>
<li>如果用delete删除整个表，所有的数据页被标记为可复用，但文件不会变小</li>
<li>插入数据可能导致数据页分裂</li>
</ul>
<h4 id="重建表-1">重建表</h4>
<ul>
<li>重建表可以减少数据空洞（每个页留了1/16给后续的更新用）： alter table A engine=InnoDB</li>
</ul>
<p><img src="/image/mysql_in_action/EFDE128B-3C15-447C-B25D-2C73AFA9E38B.png" alt="2d1cfbbeb013b851a56390d38b5321f0"></p>
<ul>
<li>
<p>Online DDL(data definition Language)（5.6起重建表的默认流程）</p>
<ul>
<li>建立一个临时文件，用原始表的记录生成B+树，存储到临时文件</li>
<li>同时把期间原始表的操作记录到一个日志文件中</li>
<li>临时文件生成后，将日志中的操作应用到到临时文件</li>
<li>用临时文件提花原始表的数据文件</li>
</ul>
</li>
<li>
<p>optimize talbe = recreate table + analyze table(对索引信息做重新统计)</p>
</li>
</ul>
<h4 id="评论区拾遗-2">评论区拾遗</h4>
<ul>
<li>truntace table t 等于 drop table + create table</li>
<li>重建表时数据页会按90%满的比例来重新整理页数据（10%留给UPDATE使用）</li>
</ul>
<h3 id="第十四讲-count">第十四讲 count(*)</h3>
<p>实现方式</p>
<ul>
<li>MyISAM: 把表的总行数存在了磁盘，查询的时候直接返回这个数</li>
<li>InnoDB：一行一行读取，累计计数</li>
<li>show table status能取得估算的总行数</li>
</ul>
<p>单独实现计数</p>
<ul>
<li>存redis，高效</li>
<li>存mysql另一张表，持久化，可用事务保证一致性</li>
</ul>
<p>不同count的区别</p>
<ul>
<li>count(1)：引擎遍历整张表，但不取值</li>
<li>count(id)：引擎层遍历整张表逐行解析数据将id返回给server层，</li>
<li>count(字段)：引擎层遍历整张表逐行解析数据将对应字段值返回给server层</li>
</ul>
<p>结论：count(字段)&lt;count(主键 id)&lt;count(1)≈count(*)</p>
<h3 id="第十五讲-日志和索引相关问题答疑">第十五讲 日志和索引相关问题答疑</h3>
<h4 id="日志相关">日志相关</h4>
<h5 id="两阶段提交过程中crash">两阶段提交过程中crash</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">graph TD
A(写入redolog 处于prepare状态) --&gt; |时刻A| B(写入binlog)
B --&gt; |时刻B| C[提交事务 处于commit状态]
</code></pre></td></tr></table>
</div>
</div><ul>
<li>时刻A crash: binlog未写入，redo log未提交，事务会回滚</li>
<li>时刻B
<ul>
<li>如果binglog完整则提交事务</li>
<li>binlog不完整则回滚</li>
</ul>
</li>
</ul>
<h5 id="binlog如何验证完整性">binlog如何验证完整性</h5>
<ul>
<li>statement格式：最后会有comit</li>
<li>row格式：最后会XID event</li>
<li>5.6.2版本之后还引入了binlog-checksum参数</li>
</ul>
<h5 id="redo-log-和binlog如何关联">redo log 和binlog如何关联</h5>
<p>通过XID关联</p>
<p>奔溃恢复的时候，按顺序扫描redo log，如果既有prepare又有commit的redo log,就直接提交，如果没找commit，则拿XID找对应的binlog</p>
<h5 id="redo-log-buffer">redo log buffer</h5>
<p>一个事务可能有多个操作，操作对应的red log先在redo log buffer中缓存，等执行commit时在写入文件</p>
<h3 id="第十六讲-order-by">第十六讲 order by</h3>
<p>using filesort表示需要排序，MySQL会给每个线程分配一块内存sort_buffer用于排序</p>
<h4 id="全字段排序">全字段排序</h4>
<p>把需要查询的字段一行一行查询出放入sort_buffer，再进行快速排序，如果要排序的数据量小于sort_buff_size,排序在内存中完成，否则会利用磁盘临时文件辅助排序，外部排序一般使用归并排序算法。</p>
<h4 id="rowid排序">rowid排序</h4>
<p>max_length_for_sort_data控制用于排序的行数据长度上限，如果超过这个值就只将排序用到的列和主键列放入sort_buffer，在排完序后再回表找到其他需要的字段. 所以会有两次访问主索引数</p>
<h4 id="课后问题-sessiona-最后看到的a是多少">课后问题: sessionA 最后看到的A是多少</h4>
<table>
<thead>
<tr>
<th style="text-align:center">sessionA</th>
<th style="text-align:center">sessionB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">start transaction;</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">select * from t where id =1; （query result: a=3）</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">update t set a = 5 where id = 1;</td>
</tr>
<tr>
<td style="text-align:center">update t set a = 5 where id = 1;</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">select * from t where id =1;</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>答： 取决于binlog_row_image，binlog_row_image=minimal时a=3,binlog_row_image=full为5。因为mysql在full时会读出所有字段，更新前会判断是否需要更新</p>
<h3 id="第十七讲-随机消息">第十七讲 随机消息</h3>
<h4 id="order-by-rand">order by rand</h4>
<p>rand是建一个临时表，每行给一个随机值(0, 1),然后在sort buffer中排序,内存中会用到快排，文件中会用归并排序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">select word from words order by rand() limit 3;
</code></pre></td></tr></table>
</div>
</div><p><code>internal_tmp_disk_storage_engine</code>控制临时表的类型，默认建内存临时表，如果超过了<code>tmp_table_size</code>就会转成磁盘临时表</p>
<h4 id="随机排序法">随机排序法</h4>
<ul>
<li>方法一</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="k">max</span><span class="p">(</span><span class="n">id</span><span class="p">),</span><span class="k">min</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="o">@</span><span class="n">M</span><span class="p">,</span><span class="o">@</span><span class="n">N</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">set</span><span class="w"> </span><span class="o">@</span><span class="n">X</span><span class="o">=</span><span class="w"> </span><span class="n">floor</span><span class="p">((</span><span class="o">@</span><span class="n">M</span><span class="o">-@</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">rand</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">@</span><span class="n">N</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="o">@</span><span class="n">X</span><span class="w"> </span><span class="k">limit</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>方法二</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="o">@</span><span class="k">C</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">
</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="o">@</span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">floor</span><span class="p">(</span><span class="o">@</span><span class="k">C</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rand</span><span class="p">());</span><span class="w">
</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="o">@</span><span class="k">sql</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">concat</span><span class="p">(</span><span class="s2">&#34;select * from t limit &#34;</span><span class="p">,</span><span class="w"> </span><span class="o">@</span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;,1&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"> </span><span class="k">prepare</span><span class="w"> </span><span class="n">stmt</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="o">@</span><span class="k">sql</span><span class="p">;</span><span class="w">
</span><span class="w"> </span><span class="k">execute</span><span class="w"> </span><span class="n">stmt</span><span class="p">;</span><span class="w">
</span><span class="w"> </span><span class="k">DEALLOCATE</span><span class="w"> </span><span class="k">prepare</span><span class="w"> </span><span class="n">stmt</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="第十八讲-隐式转换">第十八讲 隐式转换</h3>
<ul>
<li>
<p>函数：对字段做了函数操作，就用不上索引，因为可能会破坏索引值的有序性</p>
</li>
<li>
<p>隐式类型转化，字符串和数字做比较的话，是将字符串转换成数字</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">str_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="c1">-- 等同于 select * from t where CAST(str_a as signed int) = 100;
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="c1">-- 验证
</span><span class="c1"></span><span class="k">select</span><span class="w"> </span><span class="s2">&#34;12mw23&#34;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>隐式字符编码转换</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="c1">-- traddelog字符编码为utf8mb4, trade_detaul为utf8
</span><span class="c1">-- tradeid字段有索引
</span><span class="c1"></span><span class="k">select</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">tradelog</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">trade_detail</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">tradeid</span><span class="o">=</span><span class="n">l</span><span class="p">.</span><span class="n">tradeid</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="cm">/*语句Q1*/</span><span class="w">
</span><span class="w"></span><span class="c1">-- 其中查询是用不上索引，因为在tradeid上做了隐式字符转换
</span><span class="c1"></span><span class="w">
</span><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">trade_detail</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">tradeid</span><span class="o">=</span><span class="err">$</span><span class="n">L2</span><span class="p">.</span><span class="n">tradeid</span><span class="p">.</span><span class="n">value</span><span class="p">;</span><span class="cm">/*语句2*/</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">-- 等同于
</span><span class="c1"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">trade_detail</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="k">CONVERT</span><span class="p">(</span><span class="n">tradeid</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="n">utf8mb4</span><span class="p">)</span><span class="o">=</span><span class="err">$</span><span class="n">L2</span><span class="p">.</span><span class="n">tradeid</span><span class="p">.</span><span class="n">value</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c1">-- 优化
</span><span class="c1"></span><span class="k">select</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">tradelog</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">trade_detail</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">tradeid</span><span class="o">=</span><span class="k">CONVERT</span><span class="p">(</span><span class="n">l</span><span class="p">.</span><span class="n">tradeid</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="n">utf8</span><span class="p">)</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">l</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="w"> 
</span><span class="w">
</span><span class="w"></span><span class="c1">-- 原因是tradeid没有了函数操作，即：
</span><span class="c1"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">trade_detail</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">tradeid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">CONVERT</span><span class="p">(</span><span class="err">$</span><span class="n">L2</span><span class="p">.</span><span class="n">tradeid</span><span class="p">.</span><span class="n">value</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="n">utf8mb4</span><span class="p">)</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="第十九讲-常见的阻塞场景">第十九讲 常见的阻塞场景</h3>
<h4 id="查询长时间不返回">查询长时间不返回</h4>
<ul>
<li>等MDL锁</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">lock</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">write</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>可以通过查询 sys.schema_table_lock_waits 这张表，我们就可以直接找出造成阻塞的 process id</p>
<ul>
<li>等flush</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="n">flush</span><span class="w"> </span><span class="n">tables</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="k">read</span><span class="w"> </span><span class="k">lock</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>等行锁</li>
</ul>
<p>查询锁占用信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="n">mysql</span><span class="o">&gt;</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">sys</span><span class="p">.</span><span class="n">innodb_lock_waits</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">locked_table</span><span class="o">=</span><span class="s1">&#39;`test`.`t`&#39;</span><span class="err">\</span><span class="k">G</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="查询慢">查询慢</h4>
<ul>
<li>没有命中索引</li>
<li>一致性读时 undolog太多，回滚到对应版本耗时长，这种情况会比当前读慢（<code>lock in share mode</code>)</li>
</ul>
<h3 id="第二十讲-幻读">第二十讲 幻读</h3>
<ul>
<li>幻读：一个事务，相同查询语句后一次查询看到了前一次查询没有看到的行。</li>
<li>RR级别默认可重复读不会发生幻读，只有当前读(for update)才会出现幻读</li>
<li>行锁只能锁住行, 新插入记录可能是行之间的间隙。所以需要引入了间隙锁</li>
<li>间隙锁：锁住两个值之间的空隙, 间隙锁之间不存在冲突关系(即多个session可以锁同一个区间)</li>
<li>间隙锁和行锁合成next-key lock,每个next-key lock 都是前开后闭区间</li>
<li>间隙锁可能导致死锁，如下表，在id=9不存在的情况下，两个sesson会锁住间隙,insert时互相等待。</li>
</ul>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin; select * from t where id=9 for update</td>
<td></td>
</tr>
<tr>
<td></td>
<td>begin; select * from t where id=9 for update</td>
</tr>
<tr>
<td></td>
<td>insert into values(9,9,9)</td>
</tr>
<tr>
<td>insert into values(9,9,9)</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>RC级别没有间隙锁，可能会出现数据和日志不一致的情况，binlog格式需要设为row</li>
<li>下表sessionA会加锁:
<ul>
<li>next-key lock: (5, 10], (10, 15], (15, 20]</li>
<li>gap lock: (20, 25)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
<th>sesionC</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin; select * from t where c&gt;=15 and c &lt;=20 order by c desc for update</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into values(11,11,11)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>insert into values(9,9,9)</td>
</tr>
</tbody>
</table>
<h3 id="第二十一讲">第二十一讲</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="c1">-- 基础数据
</span><span class="c1"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="o">`</span><span class="n">t</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="w">
</span><span class="w">  </span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="o">`</span><span class="k">c</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="o">`</span><span class="n">d</span><span class="o">`</span><span class="w"> </span><span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w">
</span><span class="w">  </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="p">),</span><span class="w">
</span><span class="w">  </span><span class="k">KEY</span><span class="w"> </span><span class="o">`</span><span class="k">c</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="k">c</span><span class="o">`</span><span class="p">)</span><span class="w">
</span><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">values</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span><span class="w">
</span><span class="w"></span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">),(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">),(</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">25</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="加锁规则">加锁规则</h4>
<ul>
<li>原则1：基本单位是next-key lock</li>
<li>原则2：查找过程中访问到的对象才会加锁</li>
<li>优化1：唯一索引的等值查询，给唯一索引加锁的时候，next-key lock会退化为行锁</li>
<li>优化2：索引的等值查询，向右遍历到最后一个值不满足等值条件时，next-ket lock会退化为间隙锁</li>
<li>bug1: 唯一索引上的范围查询，会访问到不满足条件的第一个值为止</li>
</ul>
<h4 id="案例一-等值查询间隙锁">案例一 等值查询间隙锁</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">begin</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">update</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="n">d</span><span class="o">=</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>根据原则1和优化2，最终加锁范围是(5, 10)</p>
<h4 id="案例二-非唯一索引等值锁">案例二 非唯一索引等值锁</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">begin</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="k">c</span><span class="o">=</span><span class="mi">5</span><span class="w"> </span><span class="k">lock</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">share</span><span class="w"> </span><span class="k">mode</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>根据原则1、原则2和优化2，最终加锁范围是（0, 5],(5, 10)，因为使用可覆盖索引，所以主键索引上没有锁。</li>
<li>lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。你要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。</li>
</ul>
<h4 id="案例三-主键索引范围锁">案例三 主键索引范围锁</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">begin</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">update</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>首次定位查找id=10是按等值查询判断，之后范围判断，最终加锁是是行锁10,next-key lock (10, 15]</p>
<h4 id="案例四-非唯一索引范围锁">案例四 非唯一索引范围锁</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">begin</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="o">&gt;=</span><span class="mi">10</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">update</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>根据原则1 (5, 10], (10, 15]</p>
<h4 id="案例五-唯一索引范围的bug">案例五 唯一索引范围的bug</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">begin;
select * from t where id&gt;10 and id&lt;=15 for update;
</code></pre></td></tr></table>
</div>
</div><p>根据原则1和bug1： (10, 15], (25, 20]</p>
<h4 id="案例六-limit语句加锁">案例六 limit语句加锁</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">begin</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w">  </span><span class="k">where</span><span class="w"> </span><span class="k">c</span><span class="o">=</span><span class="mi">10</span><span class="w"> </span><span class="k">limit</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">update</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>因为有limit加锁区间为(5, 10]</p>
<h4 id="案例七-死锁案例">案例七 死锁案例</h4>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin; select * from t where id=10 lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set d=d+1 where c=10;(blocked)</td>
</tr>
<tr>
<td>insert into values(9,9,9);</td>
<td></td>
</tr>
<tr>
<td></td>
<td>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</td>
</tr>
</tbody>
</table>
<p>sessionA开始加上了(5,10],(10,15), insert导致sessionB死锁说明，session加上了gap lock (5, 10),即next-lock加锁是分两步（加间隙锁和加行锁）执行的,间隙锁不是排他的而行锁是</p>
<h4 id="案例八">案例八</h4>
<table>
<thead>
<tr>
<th>sessionA</th>
<th>sessionB</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin; select * from t where c&gt;=15 and c &lt;=20 order by c desc lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into values(6,6,6);</td>
</tr>
</tbody>
</table>
<ul>
<li>c: (5, 25)</li>
<li>id: 15 ,20</li>
</ul>
<h3 id="第二十二讲-饮鸩止渴的方法">第二十二讲 饮鸩止渴的方法</h3>
<h4 id="max_connectio超标">max_connectio超标</h4>
<h5 id="方案一-清理空闲的线程">方案一 清理空闲的线程</h5>
<ul>
<li>清理空闲的线程 kill connction $thread_id</li>
<li>查看事务详情： select * from information_schema.innodb_trx</li>
</ul>
<h5 id="方案二-减少连接过程的消耗">方案二 减少连接过程的消耗</h5>
<ul>
<li>重启数据库 使用&ndash;skip-grant-tables参数启动，这样连接过程和语句执行过程都会跳过权限验证阶段，mysql8.0之后默认吃屎只能本地客户端连接，提高安全性</li>
</ul>
<h4 id="慢查询">慢查询</h4>
<h5 id="索引没有设成好">索引没有设成好</h5>
<ul>
<li>5.6之后可以在线DDL: alter table add index</li>
</ul>
<h4 id="语句没有写好">语句没有写好</h4>
<ul>
<li>查询重写</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">query_rewrite</span><span class="p">.</span><span class="n">rewrite_rules</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span><span class="w"> </span><span class="n">replacement</span><span class="p">,</span><span class="w"> </span><span class="n">pattern_database</span><span class="p">)</span><span class="w"> </span><span class="k">values</span><span class="p">(</span><span class="s2">&#34;select * from t where id+1=?&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;select * from t where id = ? - 1&#34;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;db1&#34;</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="k">call</span><span class="w"> </span><span class="n">quetry_rewrite</span><span class="p">.</span><span class="n">flush_rewrite_rules</span><span class="p">();</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h5 id="mysql选错索引">MySQL选错索引</h5>
<ul>
<li>使用force index</li>
</ul>
<h3 id="第二十三讲-mysql如何保证数据不丢">第二十三讲 MySQL如何保证数据不丢</h3>
<h4 id="binlog的写入机制">binlog的写入机制</h4>
<ul>
<li>binlog先写入binlog cache，每个线程都有独立的cache, 事务提交的时候再写到binlog中</li>
<li>一个事务的binlog是是一次性写入的，如果超过了binlog_cache_size,会用到临时文件</li>
<li>参数sync_binlog控制写入机制
<ul>
<li>0，只write（写入文件系统page cache）</li>
<li>1, 每次都fsync,持久化到磁盘</li>
<li>n, 积累n个事务才fsync（通常n为100~1000之间）</li>
</ul>
</li>
<li>binlog_group_commit_sync_delay 参数 表示延迟n微秒后fysync， 判断顺序会先判断参数sync_binlog，满足后才会对该参数判断</li>
<li>binlog_group_commit_sync_no_delay_count 积累n次后才调用fsync，和上一个参数是或的关系</li>
</ul>
<h4 id="redo-log写入机制">redo log写入机制</h4>
<ul>
<li>同样也有三种状态，在redo log buffer中、page cache 中、 磁盘中</li>
<li>innodb_flush_log_at_trx_commit参数
<ul>
<li>0， 写入redog buffer</li>
<li>1， 每次都持久化到磁盘</li>
<li>2， 只write到page cache</li>
</ul>
</li>
<li>InnoDB后台线程会每隔一秒将buffer中的日志调用write和fsync持久到磁盘</li>
<li>组提交（group commit）: fsync的时候会将当前所有事务一起fsync</li>
</ul>
<p><img src="/image/mysql_in_action/23_1.png" alt="23_1.png"></p>
<h3 id="第二十四讲-mysql如何保证主从一致">第二十四讲 MySQL如何保证主从一致</h3>
<h4 id="从库同步逻辑">从库同步逻辑</h4>
<ul>
<li>io_thread负责和主库建立长连接，接收主库发送过来的binlog, 并写入本地文件relay log</li>
<li>sql_thread读取relay log，并执行</li>
<li>binlog中有server id信息，如果发现server id和自己一样，就会丢弃，这样避免了双Master架构循环写入的问题</li>
</ul>
<h4 id="binlog">binlog</h4>
<h5 id="三种格式">三种格式</h5>
<ul>
<li>statement SQL原始语句</li>
<li>row  记录具体操作和主键id以及其他字段的值</li>
<li>mixed(上面两种格式混合)</li>
</ul>
<h5 id="格式优缺点">格式优缺点</h5>
<ul>
<li>statement可能导致主备不一致（如删除操作主从库选择的索引可能不一样）</li>
<li>row格式占用空间大</li>
<li>mixed MySQL自己判断SQL语句是否会引起主备不一致，如有可能就用row格式，否则用statement格式</li>
<li>mixed格式中使用了now函数的语句会用statements格式，因为binlog记录了上下文<code>SET TIMESTAMP=xxxxxxx</code></li>
</ul>
<h5 id="部分操作命令">部分操作命令</h5>
<ul>
<li>show variables like &lsquo;%log-bin%&rsquo; 查看binlog是否打开</li>
<li>show binlog events in ’master.000001‘ 查看binlog</li>
<li>mysqlbinlog -v data/master.000001 -start-position=100 查看binlog 详细信息</li>
</ul>
<h3 id="第二十五讲-mysql如何保证高可用">第二十五讲 MySQL如何保证高可用</h3>
<h4 id="主备延迟">主备延迟</h4>
<ul>
<li>
<p>定义 指的是同一个事务，在备库执行完成的时间和主库执行完成的时间的差值，如下面的<code>T1-T3</code>
T1: 主库执行完成一个事务，写入binlog
T2: 备库B接收完这个binlog
T3: 备库B执行完成这个事务</p>
</li>
<li>
<p>seconds_behinds_master 表出差当前备注延迟了多少秒</p>
<ul>
<li>可用<code>show slave status</code> 查看</li>
<li>计算方式: binlog中有一个字段记录了主库写入时间，这个时间和备库当前系统时间的差值</li>
<li>备库连接到主库时会通过<code>SELECT UNIX_TIMESTAMP()</code>获取主库的系统时间，计算seconds_behind_master会自动扣掉系统时间的差值</li>
</ul>
</li>
</ul>
<h4 id="延迟引入的原因">延迟引入的原因</h4>
<ul>
<li>备库服务器性能不如主库</li>
<li>备库查询压力大</li>
<li>大事务</li>
</ul>
<h4 id="主备切换可靠性优先">主备切换（可靠性优先）</h4>
<ol>
<li>等待seconds_behind_master小于某个阈值（如5s）</li>
<li>将主库改为只读，即设置readonly=true</li>
<li>等待seconds_behind_master变为0</li>
<li>将备注改成可读写状态，即设置readonly=false</li>
<li>将写入请求切换到备库</li>
</ol>
<h4 id="主备切换可用性优先">主备切换（可用性优先）</h4>
<p>可能出现数据不一致的情况</p>
<h3 id="第二十六讲-备库为什么会延迟好几个小时">第二十六讲 备库为什么会延迟好几个小时</h3>
<h4 id="并行复制策略">并行复制策略</h4>
<ul>
<li>
<p>由一个sql_thread变成一个coordinator+多个work线程</p>
</li>
<li>
<p>coordinator分发规则</p>
<ul>
<li>同一个事务放到同一个worker</li>
<li>涉及同一行数据的事务放到同一个workder</li>
</ul>
</li>
<li>
<p>Mysql5.6开始持DB级别的并行复制</p>
</li>
<li>
<p>MariaD支持 commid_id相同(组提交)的binlog并行复制</p>
</li>
<li>
<p>MySQL5.7 通过slave-parallel-type参数控制并行复制策略</p>
<ul>
<li>DATABASE: DB级别的并行复制</li>
<li>LOGICAL_CLOCK： 同时处于prepare或commit状态的日志可以并行复制</li>
</ul>
</li>
<li>
<p>MySQL5.7.22新增了binlog-transaction-dependency-tracking参数</p>
<ul>
<li>COMMIT_ORDER 同上</li>
<li>WRITESET: 事务涉及的每一行，计算出hash值，组成writeset, 如果两个事务没有操作相同的行，及它们的writeset没有交集，就可以并行</li>
<li>WRITE_SESSION：在WRITESET的基础上添加一个约束：主库上同一个线程先后执行的两个事务，从库上也保证先后执行</li>
</ul>
</li>
</ul>
<h3 id="第二十七讲-主库出问题了从库怎么办">第二十七讲 主库出问题了，从库怎么办</h3>
<ul>
<li>
<p>一主多备切换时发成冲突</p>
<ul>
<li>主动跳过错误 <code>set global sql_slave_skip_counter=1</code></li>
<li>忽略常见的错误（唯一键冲突，删数据到不到行）：slave_skip_errors 设置为 “1032,1062”</li>
</ul>
</li>
<li>
<p>使用GTID (global transaction identifier)</p>
<ul>
<li>全局事务ID,提交的时候生成，是事务的唯一标识</li>
<li>格式<code>server_uuid:gno</code>， server_uuid是实例第一次启动时自动生成的，gno是一个整数，初始值是1，每次提交事务的时候分配给这个事务并加1</li>
<li>开启： 实例启动时加上参数gtid_mode=on 和 enforce_gtid_consistency=on</li>
</ul>
</li>
</ul>
<h3 id="第二十八讲-读写分离有那些坑">第二十八讲 读写分离有那些坑</h3>
<h4 id="常用读写分离方案">常用读写分离方案</h4>
<ul>
<li>客户端主动选择主库还是备库进行查询。</li>
<li>加入中间代理层proxy, proxy根据请求分发路由</li>
</ul>
<h4 id="常用处理过期度的方案">常用处理过期度的方案</h4>
<h5 id="方案一-判断主备无延迟">方案一 判断主备无延迟</h5>
<ul>
<li>show slave status
<ul>
<li>查看seconds_behind_master是否==0</li>
<li>对比位点Read_Master_Log_Pos和Exec_Master_Log_Pos</li>
<li>对比GTID集合Retrieved_Gtid_Set和Executed_Gtid_Set</li>
</ul>
</li>
<li>配合semi-sync： 主库收到一个从库binlog的ack后才会提交事务</li>
</ul>
<h5 id="方案二-等主库位点">方案二 等主库位点</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="n">master_pos_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">[,</span><span class="w"> </span><span class="n">timeout</span><span class="p">]);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>参数 file 和 pos 指的是主库上的文件名和位置, timeout 可选</li>
<li>正常返回的结果是一个正整数, 等待超过N秒，就返回-1, 开始执行的时候，就发现已经执行过这个位置了，则返回0, 备库同步线程发生异常，则返回NULL</li>
<li>所以&gt;=0, 从库读， 否则走主库
<img src="MySQL%E5%AE%9E%E6%88%98.resources/88751E1A-A1E2-477E-BA32-C26036F8F026.png" alt="b20ae91ea46803df1b63ed683e1de357"></li>
</ul>
<h5 id="方案三-等gtid">方案三 等GTID</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="n">wait_for_executed_gtid_set</span><span class="p">(</span><span class="n">gtid_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>超时返回1，等到从库执行的事务包含传入的gtid_set返回0</li>
<li>MySQL 5.7.6 版本开始，允许在执行完更新类事务后，把这个事务的GTID返回给客户端，可以通过mysql_session_track_get_first获取</li>
</ul>
<h3 id="第29讲-如何判断数据库是否出问题了">第29讲 如何判断数据库是否出问题了</h3>
<h4 id="select-1">select 1</h4>
<ul>
<li>
<p><code>select 1</code> 只能说明进程还在，并不能说明主库没问题</p>
</li>
<li>
<p>反例</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>session1</th>
<th>session2</th>
</tr>
</thead>
<tbody>
<tr>
<td>set global innodb_thread_concurrency=1; （设置并发查询上限为1）</td>
<td></td>
</tr>
<tr>
<td>select sleep(100) from t;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>select 1; (Query OK)</td>
</tr>
<tr>
<td></td>
<td>select * from t; （blocked)</td>
</tr>
</tbody>
</table>
<h4 id="查表判断">查表判断</h4>
<p><code>select * from db.health_check</code></p>
<ul>
<li>磁盘满后，binlog无法写入，更新操作会被堵住，但读操作仍可正常进行</li>
</ul>
<h4 id="更新判断">更新判断</h4>
<ul>
<li>版本1  <code>update mysql.health_check set t_modified=now()</code>； 这个情况不是和双M架构，双M同时发起检测的话可能会冲突</li>
<li>版本2 <code>insert into mysql.health_check(id, t_modified) values (&amp;&amp;server_id, now()) on duplicate key update t_modified=now();</code></li>
</ul>
<h4 id="内部统计">内部统计</h4>
<p>外部检测具有随机性，可能不能及时发现问题, Mysql5.6之后提供了performance_schema库，file_summary_by_event_name统计了每次IO请求的时间。</p>
<h5 id="使用redo-log">使用redo log</h5>
<p>开启监控</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">update</span><span class="w"> </span><span class="n">setup_instruments</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="n">ENABLED</span><span class="o">=</span><span class="s1">&#39;YES&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">Timed</span><span class="o">=</span><span class="s1">&#39;YES&#39;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">like</span><span class="w"> </span><span class="s1">&#39;%wait/io/file/innodb/innodb_log_file%&#39;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>查看</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">performance_schema</span><span class="p">.</span><span class="n">file_summary_by_event_name</span><span class="w">  </span><span class="k">where</span><span class="w"> </span><span class="n">event_name</span><span class="o">=</span><span class="s1">&#39;wait/io/file/innodb/innodb_log_file&#39;</span><span class="err">\</span><span class="k">G</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>COUNT_STAR: 所有IO的总次数， 后4列分别是总和，最小值，平均值，最大值，单位是皮秒</li>
<li>COUNT_READ 读操作</li>
<li>COUNT_WRITE 写操作</li>
<li>COUNT_MISC 其他</li>
</ul>
<h5 id="使用bin-log">使用bin log</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">performance_schema</span><span class="p">.</span><span class="n">file_summary_by_event_name</span><span class="w">  </span><span class="k">where</span><span class="w"> </span><span class="n">event_name</span><span class="o">=</span><span class="s1">&#39;wait/io/file/sql/binlog&#39;</span><span class="err">\</span><span class="k">G</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="检测">检测</h4>
<p>检测单次IO请求时间是否超过200毫秒</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="n">event_name</span><span class="p">,</span><span class="n">MAX_TIMER_WAIT</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">performance_schema</span><span class="p">.</span><span class="n">file_summary_by_event_name</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">event_name</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;wait/io/file/innodb/innodb_log_file&#39;</span><span class="p">,</span><span class="s1">&#39;wait/io/file/sql/binlog&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">MAX_TIMER_WAIT</span><span class="o">&gt;</span><span class="mi">200</span><span class="o">*</span><span class="mi">1000000000</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>清空数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">truncate</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">performance_schema</span><span class="p">.</span><span class="n">file_summary_by_event_name</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h3 id="第30讲-用动态的观点看加锁">第30讲 用动态的观点看加锁</h3>
<h4 id="不等号条件里面的等值查询">不等号条件里面的等值查询</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">begin</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">id</span><span class="o">&gt;</span><span class="mi">9</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">id</span><span class="o">&lt;</span><span class="mi">12</span><span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">desc</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">update</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>加锁范围(0, 5], (5, 10], (10, 15)
15没有锁因为树搜索开始定位记录时用的是等值查询，优化器找第一个<code>id&lt;12</code>的值时找到了（10， 15）这个间隙</p>
<h4 id="等值查询的过程">等值查询的过程</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">begin</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="k">lock</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">share</span><span class="w"> </span><span class="k">mode</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>加锁过程</p>
<ul>
<li>c=5：(0, 5], (5, 10)</li>
<li>c=10: (5, 10], （10， 15）</li>
<li>c=20: (15, 20], (20, 25)</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="k">in</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="k">desc</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">update</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>加锁过程</p>
<ul>
<li>c=20: (15, 20], (20, 25)</li>
<li>c=10: (5, 10], （10， 15）</li>
<li>c=5：(0, 5], (5, 10)</li>
</ul>
<h4 id="查看死锁">查看死锁</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">show</span><span class="w"> </span><span class="n">engine</span><span class="w"> </span><span class="n">innodb</span><span class="w"> </span><span class="n">status</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>lock_mode X waiting表示next-key lock；</li>
<li>lock_mode X locks rec but not gap是只有行锁；</li>
<li>还有一种 “locks gap before rec”，就是只有间隙锁；</li>
</ul>
<h4 id="锁范围变化">锁范围变化</h4>
<table>
<thead>
<tr>
<th>session1</th>
<th>session2</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin;select * from t where id&gt;10 and id&lt;=15;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>delete from t where id=10; (Query OK)</td>
</tr>
<tr>
<td></td>
<td>insert into i valus(10, 10, 10); （blocked)</td>
</tr>
</tbody>
</table>
<p>delete操作导致两个间隙锁(5, 10), (10, 15)变成了一个(5,15),
其实所谓间隙就是间隙右边的那个记录定义的。</p>
<table>
<thead>
<tr>
<th>session1</th>
<th>session2</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin;select c from t where id&gt;5 lock in share mode;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set c = 1 where id=5 ; (Query OK)</td>
</tr>
<tr>
<td></td>
<td>update t set c = 5 where c = 1; （blocked)</td>
</tr>
</tbody>
</table>
<p>(5,10]、(10,15]、(15,20]、(20,25]和 (25,supremum] 变成了(1,10]、(10,15]、(15,20]、(20,25]和 (25,supremum]</p>
<h4 id="评论收集">评论收集</h4>
<h5 id="评论1">评论1</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="k">c</span><span class="o">&gt;=</span><span class="mi">15</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="k">c</span><span class="o">&lt;=</span><span class="mi">20</span><span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="k">desc</span><span class="w"> </span><span class="k">lock</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">share</span><span class="w"> </span><span class="k">mode</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>先定位索引c上最右边c=20的行，所以第一个等值查询会扫描到c=25</li>
<li>然后通过优化2，next-key lock退化为间隙锁，则会加上间隙锁（20，25)</li>
<li>紧接着再向左遍历，会加 next-key lock (15, 20], (10, 15], 因为要扫描到c=10才停下来，所以也会加next-key lock (5,10]</li>
</ul>
<h3 id="第31讲-删除数据除了跑路还能怎么办">第31讲 删除数据除了跑路还能怎么办</h3>
<h4 id="删除行">删除行</h4>
<ul>
<li>修改binlog然后回放,前提是binlog_format为row和binlog_row_image=FULL</li>
</ul>
<h4 id="删表库">删表/库</h4>
<ul>
<li>近期备份+binlog</li>
<li>使用延迟从库</li>
</ul>
<h4 id="评论收集-1">评论收集</h4>
<h5 id="评论1-1">评论1</h5>
<p>对生产数据库操作，公司DBA提出的编写脚本方法，个人觉得还是值得分享，虽说可能大部分公司也可能有这样的规范。修改生产的数据，或者添加索引优化，都要先写好四个脚本：备份脚本、执行脚本、验证脚本和回滚脚本。备份脚本是对需要变更的数据备份到一张表中，固定需要操作的数据行，以便误操作或业务要求进行回滚；执行脚本就是对数据变更的脚本，为防Update错数据，一般连备份表进行Update操作；验证脚本是验证数据变更或影响行数是否达到预期要求效果；回滚脚本就是将数据回滚到修改前的状态。虽说分四步骤写脚本可能会比较繁琐，但是这能够很大程度避免数据误操作。</p>
<h3 id="第32讲-为何有kill不掉的语句">第32讲 为何有kill不掉的语句</h3>
<h4 id="两个kill命令">两个kill命令</h4>
<ul>
<li><code>kill query thread_id</code>: 将session 的运行状态改为 THD::KILL_QUERY，并发信号给执行线程，表示终止这个线程正在执行的语句</li>
<li><code>kill thread_id</code>: 将session 的运行状态改为 THD::KILL_CONNECION并断开执行线程网络连接， 并发信号给执行线程</li>
</ul>
<h4 id="kill无效的情况">kill无效的情况</h4>
<ul>
<li>线程状态虽然改了，但线程还没有执行到判断线程状态的逻辑</li>
<li>终止逻辑比较长，如大事务被kill时回滚也比较耗时，某些操作用到的临时文件，删除临时文件也可能受到IO资源的影响耗时较久</li>
</ul>
<h4 id="客户端ctrlc">客户端ctrl+c</h4>
<p>此时客户端会另起一个连接发一个kill query</p>
<h3 id="第33讲-查太多数据内存会不会打爆">第33讲 查太多数据，内存会不会打爆？</h3>
<ul>
<li>MySQL是边读边发的，如果state一直处于<code>sending to client</code>,表示服务器端的socket send buffer写满了</li>
<li>MySQL进入执行阶段后，state会置于<code>sending data</code></li>
<li>由于Innodb对于LRU算法的改进，冷数据的全表扫描不会影响到buffer pool的查询命中率
<ul>
<li>按5:3的比例把整个链表分成了young区域和old区域，前5/8为young区域</li>
<li>LRU_old指针指向old区域第一个位置</li>
<li>新插入的数据页先放在LRU_old处</li>
<li>访问old区域的数据页时，如果存在的时间超过了1s,则将其移动至整个链表的头部</li>
</ul>
</li>
</ul>
<p><img src="/image/mysql_in_action/33_1.png" alt="33_1"></p>
<h3 id="第34讲-可不可以用join">第34讲 可不可以用join</h3>
<h4 id="index-nested-loop-join">Index Nested-Loop Join</h4>
<p>被驱动表能使用索引</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">straight_join</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">a</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">a</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>straight_join 关闭优化器优化，这样t1必定为驱动表，t2必定为被驱动表</li>
<li>执行流程
<ol>
<li>从表t1读出一行数据R</li>
<li>从R中找出a到t2中查找</li>
<li>取出t2中满足条件的行，和R组合，作为结果集的一部分</li>
<li>重复1~3</li>
</ol>
</li>
</ul>
<p><img src="/image/mysql_in_action/34_1.png" alt="34_1"></p>
<ul>
<li>join的复杂度
假设被驱动表的行数是M,搜索树的复杂度为log2M,走两次索引，则查询一行的时间复杂度为2*log2M,驱动表的行数为N,整合执行过程的复杂度是N+N*2*log2M (2倍是因为需要回表)
这种情况显然驱动表的行数N对复杂度的影响更大</li>
</ul>
<h4 id="simple-nested-loop-join">Simple Nested-Loop Join</h4>
<p>被驱动表没有索引，每次匹配一行都要全表扫描</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">straight_join</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">a</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">b</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>join复杂度
<ul>
<li>扫描行数 N + N*M</li>
<li>判断次数 N*M</li>
</ul>
</li>
</ul>
<h4 id="block-nested-loop-join">Block Nested-Loop Join</h4>
<p>被驱动表没有索引,但将驱动表的数据载入join_buffer中</p>
<ul>
<li>执行流程
<ol>
<li>将驱动表的数据读入join_buffer（如果buffer满了会分批加载）</li>
<li>扫描被启动表，按行取出和join_buffer中的数据对比，满足条件的作为结果集的一部分返回</li>
</ol>
</li>
</ul>
<p><img src="/image/mysql_in_action/34_2.png" alt="34_2"></p>
<ul>
<li>join复杂度
<ul>
<li>扫描行数 N + M（如果join_buffer只能一次只能加载一半数据，则扫描行数为 N + 2*M）</li>
<li>判断次数 N*M</li>
</ul>
</li>
</ul>
<h4 id="结论">结论</h4>
<ul>
<li>能用Index-Nested-Loop Join时可以使用</li>
<li>尽量不用Block Nested-Loop Join算法，尤其在大表上的join</li>
<li>Index Nested-Loopp Join 应该选择小表做驱动</li>
<li>Block Nested-Loop Join在join buffer够大的情况下没有影响，否则应该选小表做驱动</li>
<li>小表是以按条件过滤之后参与join的数数据量做判断</li>
</ul>
<h4 id="案例">案例</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="n">straight_join</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="o">&lt;=</span><span class="mi">50</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="n">straight_join</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="o">&lt;=</span><span class="mi">50</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>应该选t2做驱动表，这样只需再出50条数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="p">,</span><span class="n">t2</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w">  </span><span class="n">t1</span><span class="w">  </span><span class="n">straight_join</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="p">,</span><span class="n">t2</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w">  </span><span class="n">t2</span><span class="w">  </span><span class="n">straight_join</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>应该选t1做驱动表，只需要放一个字段b,而t2需要三个字段id, a, b</p>
<h3 id="第35讲-join优化">第35讲 join优化</h3>
<p>基础表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="w">
</span><span class="w"></span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">t1</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w"> </span><span class="k">index</span><span class="p">(</span><span class="n">a</span><span class="p">));</span><span class="w">
</span><span class="w"></span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">like</span><span class="w"> </span><span class="n">t1</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">drop</span><span class="w"> </span><span class="k">procedure</span><span class="w"> </span><span class="n">idata</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">delimiter</span><span class="w"> </span><span class="p">;;</span><span class="w">
</span><span class="w"></span><span class="k">create</span><span class="w"> </span><span class="k">procedure</span><span class="w"> </span><span class="n">idata</span><span class="p">()</span><span class="w">
</span><span class="w"></span><span class="k">begin</span><span class="w">
</span><span class="w">  </span><span class="k">declare</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="nb">int</span><span class="p">;</span><span class="w">
</span><span class="w">  </span><span class="k">set</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">  </span><span class="n">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">1000</span><span class="p">)</span><span class="k">do</span><span class="w">
</span><span class="w">    </span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">values</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">1001</span><span class="o">-</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">set</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="n">while</span><span class="p">;</span><span class="w">
</span><span class="w">  
</span><span class="w">  </span><span class="k">set</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">  </span><span class="n">while</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;=</span><span class="mi">1000000</span><span class="p">)</span><span class="k">do</span><span class="w">
</span><span class="w">    </span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">values</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w">
</span><span class="w">    </span><span class="k">set</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="w">
</span><span class="w">  </span><span class="k">end</span><span class="w"> </span><span class="n">while</span><span class="p">;</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">end</span><span class="p">;;</span><span class="w">
</span><span class="w"></span><span class="k">delimiter</span><span class="w"> </span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">call</span><span class="w"> </span><span class="n">idata</span><span class="p">();</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="multi-range-read优化">Multi-Range Read优化</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">a</span><span class="o">&gt;=</span><span class="mi">1</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">a</span><span class="o">&lt;=</span><span class="mi">100</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>回表的时候将id值先放入read_rnd_buffer中，排序后再依次查数据，按主键递增顺序查询，对磁盘的读比较接近顺序读，能够提升读性能。</li>
<li>通过设置<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code>开启</li>
</ul>
<p><img src="/image/mysql_in_action/35_1.png" alt="35_1"></p>
<h4 id="batched-key-accessbka">Batched Key Access(BKA)</h4>
<p>BKA是对 Index Nested-Loop Join(NLJ)的优化: 将驱动表的数据缓存存到join_buffer中, 一次性的将数据传给被驱动表取匹配</p>
<p><img src="/image/mysql_in_action/35_2.png" alt="35_2"></p>
<p>开启</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">mysql</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">set</span><span class="w"> </span><span class="n">optimizer_switch</span><span class="o">=</span><span class="s1">&#39;mrr=on,mrr_cost_based=off,batched_key_access=on&#39;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="bnl性能问题">BNL性能问题</h4>
<ul>
<li>可能会多次扫描被驱动表，占用磁盘IO</li>
<li>join需要执行M*N次对比，占用CPU</li>
<li>影响buffer pool的命中率
<ul>
<li>如果数据量小于buffer pool的3/8(即能完全放入old区域)，多次扫描可能导致数据进入lru的头部</li>
<li>如果数据量很大，正常的业务数据可能没有机会进入young区,因为可能old区域的数据在1s内就被完全淘汰了</li>
</ul>
</li>
</ul>
<h4 id="bnl转bka">BNL转BKA</h4>
<h5 id="如果合适在被驱动表上建索引可以直接建索引转bka">如果合适在被驱动表上建索引，可以直接建索引转BKA</h5>
<h5 id="如果被驱动表不合适建索引如下情况">如果被驱动表不合适建索引，如下情况</h5>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t12</span><span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="n">t2</span><span class="p">.</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">b</span><span class="w"> </span><span class="o">&gt;</span><span class="mi">1</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">b</span><span class="o">&lt;=</span><span class="mi">2000</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>可以通过建立和被驱动表同结构临时表tmp_t，且给字段b加上索引，然后满足条件的数据放入临时表</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">create</span><span class="w"> </span><span class="k">temporary</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tmp_t</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w"> </span><span class="k">index</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="n">engine</span><span class="o">=</span><span class="n">innodb</span><span class="p">;</span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">tmp_t</span><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">b</span><span class="o">&gt;=</span><span class="mi">1</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;=</span><span class="mi">2000</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">tmp_t</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="n">b</span><span class="o">=</span><span class="n">tmp_t</span><span class="p">.</span><span class="n">b</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>也可以业务端模拟hash join: 将t1的1000行数据放入hash set,然后将满足条件的2000行数据依次取去hash set中匹配</li>
</ul>
<h3 id="第36讲-为什么临时表可以重名">第36讲 为什么临时表可以重名</h3>
<h4 id="临时表不一定是内存表">临时表不一定是内存表</h4>
<ul>
<li>内存表指的engine=memory的表,数据保存在内存中，表结构保存在磁盘</li>
<li>临时表可以使用各种engine</li>
</ul>
<h4 id="临时表的特性">临时表的特性</h4>
<table>
<thead>
<tr>
<th>session A</th>
<th>session B</th>
</tr>
</thead>
<tbody>
<tr>
<td>create temporary table t(c int)engine=myisam;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>show create table t; // table &rsquo;t' doesn&rsquo;t exist</td>
</tr>
<tr>
<td>create table t(id int primary key)engine=innodb;show tables;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insert into values(1); select * from t; //返回1</td>
</tr>
<tr>
<td>select * from t // Empty set</td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>创建语法： <code>create temporary table</code></li>
<li>临时表只能被创建它的session可见</li>
<li>临时表可以和普通表同名，同名时show create table语句和增删改查访问的是临时表</li>
<li>show tables不显示临时表</li>
<li>session结束时会自动删除临时表</li>
</ul>
<h4 id="应用">应用</h4>
<ul>
<li>分库分表的场景：先建立临时表，每个表的执行结果插入临时表，最后在临时表执行查询语句即可</li>
</ul>
<h4 id="为什么临时表可以重名">为什么临时表可以重名</h4>
<ul>
<li>表结构存在临时目录（select @@tmpdir), 文件命名格式为<code>#sql{procees_id:hex}_{thread_id}_num.frm</code></li>
<li>table_def_key在库名+表名的基础上，又加上了“server_id+thread_id”</li>
<li>每个线程维护了一个临时表链表，对表进行操作时，会先遍历链表，没有找到才会找普通表；session结束的时候会对链表中的临时表进行drop temppory table</li>
</ul>
<h4 id="主备复制">主备复制</h4>
<ul>
<li>如果 binlog_format=row, 和临时表有关的语句不会记录</li>
<li>备库创建临时表时table_def_key会加上thread_id信息，避免主库不同session建立同名的临时表时冲突</li>
</ul>
<h3 id="第37讲-什么时候会使用内部临时表">第37讲 什么时候会使用内部临时表</h3>
<h4 id="union执行流程">union执行流程</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="p">(</span><span class="k">select</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="p">(</span><span class="k">select</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">desc</span><span class="w"> </span><span class="k">limit</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ol>
<li>创建内存临时表，该表只有一个字段f,且为主键</li>
<li>执行第一个子查询，得到1000这个值，并存入临时表</li>
<li>执行第二个子查询：
<ul>
<li>拿到第一行id=1000, 试图插入临时表，但由于1000这个值已经存在于临时表，违反了唯一性约束，所以插入失败，然后继续执行</li>
<li>取到第二行id=999， 插入临时表成功</li>
</ul>
</li>
<li>从临时表中按行取出数据，返回结果，并删除临时表</li>
</ol>
<p>注：如果改成<code>union all</code>,就没有了去重的语义，所以不需要临时表</p>
<p><img src="/image/mysql_in_action/37_1.png" alt="37_1"></p>
<h4 id="group-by执行流程">group by执行流程</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="n">id</span><span class="o">%</span><span class="mi">10</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">group</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>从<code>Extra</code>信息中可以看出：使用了覆盖索引<code>a</code>,使用了临时表，使用了filesort</p>
<ol>
<li>创建临时表，表里有两个字段m和c, 主键是m;</li>
<li>扫描表t1的索引a,依次取出叶子节点的id值，计算id%10的结果，记为x:
<ul>
<li>如果x不存在，则插入一个记录(x, 1)</li>
<li>否则将x这一行的c值加1</li>
</ul>
</li>
<li>根据字段m进行排序，然后返回给客户端</li>
</ol>
<p>如果不需要排序可以加上<code>order by null</code></p>
<p>如果执行过程中发现内存临时表存储大小达到了上限，会转成磁盘临时表</p>
<h4 id="group-by优化---索引">group by优化&mdash;索引</h4>
<p>group by需要构造一个带唯一索引的表，如果保证输入数据是有序的那就只需要从左到按顺序扫描就可以了, 因此我们可以利用mysql的索引,而不再需要构建临时表
mysql5.7支持了generated column机制，用来实现列数据的关联更新</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">alter</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">column</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">generated</span><span class="w"> </span><span class="n">always</span><span class="w"> </span><span class="k">as</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">100</span><span class="p">),</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">index</span><span class="p">(</span><span class="n">z</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>所以原来的语句可以替换为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">group</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="group-by优化---直接排序">group by优化&mdash;直接排序</h4>
<p>如果知道数据量很大，内存临时表放不下，可以加<code>SQL_BIG_RESULT</code>提示直接走磁盘临时表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="n">SQL_BIG_RESULT</span><span class="w"> </span><span class="n">id</span><span class="o">%</span><span class="mi">100</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">group</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> 
</span></code></pre></td></tr></table>
</div>
</div><p>由于磁盘临时表是B+树存储, 存储效率不如数组效率来得高，优化器会直接用数组</p>
<ul>
<li>初始化sort buffer, 确认放入一个整形字段，记为m;</li>
<li>扫描索引a,依次取出里面的id值，将id%1000的值存入sort buffer</li>
<li>扫描完后对m排序，如果sort buffer内存不够用，就会用磁盘临时文件辅助排序</li>
<li>排完序后就得到了一个有序数组</li>
</ul>
<p>执行流程如下图</p>
<p><img src="/image/mysql_in_action/37_2.png" alt="37_2"></p>
<h3 id="第38讲-要不要用memory引擎">第38讲 要不要用Memory引擎</h3>
<h4 id="memory引擎的区别">memory引擎的区别</h4>
<ul>
<li>数据和索引分开存放，数据部分以数组的形式单独存放</li>
<li>主键使用hash索引, 索引的key并不是有序的</li>
<li>范围查询的时候需要全表扫描，也就是顺序扫描数组</li>
<li>数据按写入顺序存放,有空洞就可以插入新值</li>
<li>数据位置发生变化时，内存表需要修改所有索引，innodb只要改主键索引</li>
<li>内存表不支持变长数据类型，varchar(N)会当做char(N),所以每行的数据长度相同</li>
</ul>
<h4 id="使用b-tree索引">使用B-tree索引</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">alter</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="n">a_btree_index</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="n">btree</span><span class="p">(</span><span class="n">id</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="内存表的局限">内存表的局限</h4>
<ul>
<li>只支持表锁，有任何更新，会堵住其他所有读写操作</li>
<li>数据可能会被清空</li>
</ul>
<h4 id="使用场景">使用场景</h4>
<ul>
<li>临时表： 其他线程不可见，没有并发；不需要持久化</li>
</ul>
<h3 id="第39讲-自增主键为什么不是连续的">第39讲 自增主键为什么不是连续的</h3>
<h4 id="自增值的存储">自增值的存储</h4>
<ul>
<li>MyISAM: 自增值保存在数据文件中</li>
<li>InnoDB: 自增值保存在内存中
<ul>
<li>5.7及之前： 重启后第一次打开表的时候会去找max(id)然后将max(id)+1作为当前的自增值</li>
<li>8.0开始自增值的变更记录存在了redo log中，重启的时候依靠redo log恢复</li>
</ul>
</li>
</ul>
<h4 id="自增值的修改机制">自增值的修改机制</h4>
<ul>
<li>插入数据时如果字段指定为0、null或未指定值，那就把这个字段设为自增值</li>
<li>否则用指定的值</li>
</ul>
<h4 id="自增主键不连续的原因">自增主键不连续的原因</h4>
<ul>
<li>唯一索引冲突</li>
<li>事务回滚</li>
</ul>
<h4 id="表自增锁释放策略-innodb_autoinc_lock_mode">表自增锁释放策略 innodb_autoinc_lock_mode</h4>
<ul>
<li>0: 语句结束后再释放锁</li>
<li>1: 对于普通insert语句自增锁在申请之后马上释放，类似insert&hellip; select这种不知道具体插入数据量的语句，等语句结束后再释放锁</li>
<li>2（8.0.3版本默认值）： 申请后就释放锁 （对于insert&hellip;select语句可以设置为2同时binlog_format=row, 这样既提升并发性，也不会出现数据不一致的问题）</li>
</ul>
<h4 id="批量申请自增id策略">批量申请自增id策略</h4>
<p>对于批量插入数据的语句</p>
<ul>
<li>第一次申请分配1个</li>
<li>第n次分配2^(n-1)个</li>
</ul>
<h3 id="第40讲-insert语句锁为什么这么多">第40讲 insert语句锁为什么这么多</h3>
<ul>
<li>insert&hellip;select 在RR隔离级别下，会给select的表扫描到的记录和间隙加读锁</li>
<li>insert 和select的对象是同一个表时可能造成循环写入，需用临时表做优化</li>
<li>insert语句如果出现唯一键冲突，会在冲突的唯一值上加上next-key lock</li>
</ul>
<h3 id="第41讲-怎么快速复制一张表">第41讲 怎么快速复制一张表</h3>
<h4 id="使用mysqldump">使用mysqldump</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="n">mysqldump</span><span class="w"> </span><span class="o">-</span><span class="n">h$host</span><span class="w"> </span><span class="o">-</span><span class="n">P$port</span><span class="w"> </span><span class="o">-</span><span class="n">u$user</span><span class="w"> </span><span class="c1">--add-locks=0 --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where=&#34;a&gt;900&#34; --result-file=/client_tmp/t.sql
</span></code></pre></td></tr></table>
</div>
</div><p>参数解释</p>
<ul>
<li><code>--single-transaction</code>: 使用<code>start transaction with consistant snapshot</code> 而非加表锁</li>
<li><code>--add-locks=0</code>: b表示输出文件里不增加<code>lock tables t write</code></li>
<li><code>--no-create-info</code>: 不要导出表结构</li>
<li><code>--set-gtid-pruged-id=off</code>: 不输出和GTID相关的信息</li>
</ul>
<h4 id="导出csv文件">导出csv文件</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="c1">--- 导出
</span><span class="c1"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">db1</span><span class="p">.</span><span class="n">t</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">900</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">outfile</span><span class="w"> </span><span class="s1">&#39;/server_tmp/t.csv&#39;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="c1">--- 导入
</span><span class="c1"></span><span class="k">load</span><span class="w"> </span><span class="k">data</span><span class="w"> </span><span class="n">infile</span><span class="w"> </span><span class="s1">&#39;/server_tmp/t.csv&#39;</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">db2</span><span class="p">.</span><span class="n">t</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="物理拷贝">物理拷贝</h4>
<p><img src="/image/mysql_in_action/41_1.png" alt="41_1"></p>
<h4 id="对比">对比</h4>
<ul>
<li>物理拷贝最快，只能服务器上拷贝，只能全表拷贝,只能都是innoDB引擎</li>
<li>mysqldump支持where</li>
<li>select &hellip;info outfile最灵活</li>
</ul>
<h3 id="第42讲-grant">第42讲 grant</h3>
<p>创建测试用户</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">create</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="s1">&#39;ua&#39;</span><span class="o">@</span><span class="s1">&#39;%&#39;</span><span class="w"> </span><span class="n">identified</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="s1">&#39;pa&#39;</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="全局权限">全局权限</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">grant</span><span class="w"> </span><span class="k">all</span><span class="w"> </span><span class="k">privileges</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="o">*</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="s1">&#39;ua&#39;</span><span class="o">@</span><span class="s1">&#39;%&#39;</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="k">grant</span><span class="w"> </span><span class="k">option</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个grant命令做了两个动作</p>
<ol>
<li>磁盘中，将mysql.user表该用户所有表示权限的字段都改为‘Y’</li>
<li>内存里，从数组acl_users中找到这个用户对应的对象，将access二进制值全改为1</li>
</ol>
<p>grant不会影响到已经登录的连接</p>
<h4 id="db权限">db权限</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="n">grank</span><span class="w"> </span><span class="k">all</span><span class="w"> </span><span class="n">priviges</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">db1</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="s1">&#39;ua&#39;</span><span class="o">@</span><span class="s1">&#39;%&#39;</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="k">grant</span><span class="w"> </span><span class="k">option</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>这个grant命令做了两个动作</p>
<ol>
<li>磁盘中，将mysql.db表该用户所有表示权限的字段都改为‘Y’</li>
<li>内存里，从数组acl_dbs中找到这个用户对应的对象，将access二进制值全改为1</li>
</ol>
<p>db权限在<code>use db</code>时会将权限保存在会话变量中。所以不会受到权限变更影响,除此之外其他已有的连接会受到影响</p>
<h4 id="表权限和列权限">表权限和列权限</h4>
<p>表权限定义存储在<code>mysql.tables_priv</code>中，列权限定义存在<code>mysql.columns_priv</code>中，这两类权限组合起来存在内存的hash结果column_priv_hash中。</p>
<p>变更时会同步更新内存中的hash结构，因此会影响到已存在的连接</p>
<h4 id="flush_privileges">flush_privileges</h4>
<p><code>flush privileges</code>命令会清空全局内存权限数据，然后从表中读取数据重新构造。所以当内存权限数据和磁盘权限数据相同的话不需要flush privilefes</p>
<p>需要该操作往往是因为直接使用DML语句操作系统权限表造成的</p>
<p><img src="/image/mysql_in_action/42_1.png" alt="42_1"></p>
<p>删除用户应该使用drop user</p>
<h3 id="第43讲-要不要使用分区表">第43讲 要不要使用分区表</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="p">(</span><span class="n">PARTITION</span><span class="w"> </span><span class="n">p_2017</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">LESS</span><span class="w"> </span><span class="k">THAN</span><span class="w"> </span><span class="p">(</span><span class="mi">2017</span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InnoDB</span><span class="p">,</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="n">p_2018</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">LESS</span><span class="w"> </span><span class="k">THAN</span><span class="w"> </span><span class="p">(</span><span class="mi">2018</span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InnoDB</span><span class="p">,</span><span class="w"> </span><span class="n">PARTITION</span><span class="w"> </span><span class="n">p_2019</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">LESS</span><span class="w"> </span><span class="k">THAN</span><span class="w"> </span><span class="p">(</span><span class="mi">2019</span><span class="p">)</span><span class="w"> </span><span class="n">ENGINE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InnoDB</span><span class="p">,</span><span class="n">PARTITION</span><span class="w"> </span><span class="n">p_others</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="k">LESS</span><span class="w"> </span><span class="k">THAN</span><span class="w"> </span><span class="k">MAXVALUE</span><span class="w"> </span><span class="n">ENGINE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InnoDB</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>对于引擎层来说是多个表，对于Server层来说是一个表</p>
<p>因为服务层是单个表，所以共用一个MDL锁</p>
<p>因为在引擎层是多个表，等值查询产生的间隙锁，引擎层加锁的时候只会锁一个表</p>
<p>第一次访问的时候需要访问所有分区</p>
<p>分区策略可以使用range list hash等</p>
<h3 id="第44讲-答疑三">第44讲 答疑三</h3>
<h4 id="join的写法">join的写法</h4>
<p>初始数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">f1</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w"> </span><span class="k">index</span><span class="p">(</span><span class="n">f1</span><span class="p">))</span><span class="n">engine</span><span class="o">=</span><span class="n">innodb</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">b</span><span class="p">(</span><span class="n">f1</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w"> </span><span class="n">f2</span><span class="w"> </span><span class="nb">int</span><span class="p">)</span><span class="n">engine</span><span class="o">=</span><span class="n">innodb</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">values</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">values</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">7</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Q1</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">left</span><span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">f1</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">f2</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>驱动表为a,因为b.f1没有索引使用Block Nested Loop Join算法。执行的流程是：
把表a的内容读入join_buffer中，顺序扫描b,判断是否符合join条件，符合的话作为结果集的一行返回。最后对于没有被匹配的表a的行，把剩余字段补NULL返回</p>
<p><img src="/image/mysql_in_action/44_1.png" alt="44_1"></p>
<ul>
<li>Q2</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">left</span><span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">f1</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">f2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">f2</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>驱动表为b,使用Index Nested-Loop Join, 顺序扫面b,每一行用b.f1到a中去查，然后再判断f2字段是否相等，如果是则作为结果集的一行.</p>
<p>因为与NUll值比较永远返回NULL, where a.f2 = b.f2就不会包含b.f2是NULL的行。优化器把left join改成了join, 因为a.f1有所以所以把b作为了驱动表，可以通过show warning查看这个改写的结果</p>
<p>所以left join 左表不一定是驱动表</p>
<p>如果要符合left join语句，就不能把驱动表的字段放在where条件里做等值判断</p>
<ul>
<li>Q3</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">on</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">f1</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">f1</span><span class="p">)</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">f2</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">f2</span><span class="p">);</span><span class="w"> </span><span class="cm">/*Q3*/</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Q4</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">on</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">f1</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">f1</span><span class="p">)</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">f2</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">f2</span><span class="p">);</span><span class="w"> </span><span class="cm">/*Q3*/</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>通过<code>show warnings</code> 可以看到Q3/Q4都被转换了为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">join</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">f1</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">f1</span><span class="p">)</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">f2</span><span class="o">=</span><span class="n">b</span><span class="p">.</span><span class="n">f2</span><span class="p">);</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><h4 id="distinct和group-by的性能">distinct和group by的性能</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="k">select</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">group</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="k">null</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="k">distinct</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>由于group不需要聚合，以上两句语句执行流程是一样的</p>
<ul>
<li>创建临时表，只有字段a,且创建唯一索引a</li>
<li>遍历全表，将数据一次插入临时表，如唯一键冲突则跳过</li>
<li>遍历完之后将临时表作为结果集放回给客户端</li>
</ul>
<h4 id="备库自增主键问题">备库自增主键问题</h4>
<p>自增id的生成顺序和binlog的写入顺序可能不同，在binlog=statement格式下，insert语句之前会记录<code>SET INSERT_ID=XXX</code>,所以不会出现问题</p>
<h3 id="第45讲-自增id用完怎么办">第45讲 自增id用完怎么办</h3>
<h4 id="表定义自增id">表定义自增id</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">t</span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="n">auto_increment</span><span class="w"> </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="p">)</span><span class="w"> </span><span class="n">auto_increment</span><span class="o">=</span><span class="mi">4294967295</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">values</span><span class="p">(</span><span class="k">null</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="o">//</span><span class="err">成功插入一行</span><span class="w"> </span><span class="mi">4294967295</span><span class="w">
</span><span class="w"></span><span class="k">show</span><span class="w"> </span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">
</span><span class="w"></span><span class="cm">/* CREATE TABLE `t` (
</span><span class="cm">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
</span><span class="cm">  PRIMARY KEY (`id`)
</span><span class="cm">) ENGINE=InnoDB AUTO_INCREMENT=4294967295;
</span><span class="cm">*/</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">values</span><span class="p">(</span><span class="k">null</span><span class="p">);</span><span class="w">
</span><span class="w"></span><span class="o">//</span><span class="n">Duplicate</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="s1">&#39;4294967295&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="s1">&#39;PRIMARY&#39;</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>达到上限后AUTO_INCREMENT不会改变，后续插入后报主键冲突</p>
<h4 id="系统自增row_id">系统自增row_id</h4>
<p>创建InnoDB表如果没有指定主键，会创建一个不可见的长度为8字节的无符号整形,数据写入时，只取了后面6字节， 所以到row_id == 2^48时，想当时row_id=0, 这是会覆盖已经存在的行</p>
<h4 id="thread_id">thread_id</h4>
<p>thread_id_counter: 4字节 全局变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">// todo: lean c++
do {
  new_id= thread_id_counter++;
} while (!thread_ids.insert_unique(new_id).second);
</code></pre></td></tr></table>
</div>
</div><h3 id="参考">参考</h3>
<ul>
<li><a href="https://helloworlde.github.io/blog/blog/MySQL/MySQL-%E4%B8%AD%E5%85%B3%E4%BA%8Egap-lock-next-key-lock-%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98.html">next-lock key</a></li>
<li><a href="https://www.cnblogs.com/bdsir/p/8745553.html">数据页结构</a></li>
</ul>

    </div>

    
    


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://ppd0705.github.io/tags/mysql/">MySQL</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/redis_core_technologies/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">[笔记]Redis核心技术与实战</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/pydantic_note/">
            <span class="next-text nav-default">[笔记]Pydantic</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "ppd0705/ppd0705.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="ppd0705@icloud.com" rel="me noopener" class="iconfont"
      title="email"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://twitter.com/ppd0705" rel="me noopener" class="iconfont"
      title="twitter"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1264 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M1229.8616 18.043658c0 0-117.852626 63.135335-164.151872 67.344358-105.225559-164.151872-505.082682-92.598492-437.738325 223.078185C278.622548 312.675223 89.216542 47.506814 89.216542 47.506814s-117.852626 189.406006 75.762402 345.139833C127.097743 396.85567 55.544363 371.601535 55.544363 371.601535S26.081207 535.753407 253.368414 615.724832c-21.045112 29.463156-113.643603 8.418045-113.643603 8.418045s25.254134 143.10676 231.496229 180.987961c-143.10676 130.479693-387.230056 92.598492-370.393967 105.225559 206.242095 189.406006 1119.599946 231.496229 1128.01799-643.98042C1179.353331 249.539887 1263.533778 123.269217 1263.533778 123.269217s-130.479693 37.881201-138.897738 33.672179C1225.652577 98.015083 1229.8616 18.043658 1229.8616 18.043658"></path>
</svg>

    </a>
  
    <a href="https://github.com/ppd0705" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>
  
    <a href="https://www.douban.com/people/ppd0705/" rel="me noopener" class="iconfont"
      title="douban"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M926.917973 37.80608C959.65184 37.80608 986.19392 64.34816 986.19392 97.082027L986.19392 926.917973C986.19392 959.65184 959.65184 986.19392 926.917973 986.19392L97.082027 986.19392C64.34816 986.19392 37.80608 959.65184 37.80608 926.917973L37.80608 97.082027C37.80608 64.34816 64.34816 37.80608 97.082027 37.80608zM176.653653 176.19968 176.653653 252.678827 825.658027 252.678827 825.658027 176.19968zM217.719467 316.146347 217.719467 628.08064 273.524053 628.08064 341.292373 770.39616 157.259093 770.39616 157.259093 845.417813 842.949973 845.417813 842.949973 770.39616 654.226773 770.39616 722.899627 628.08064 783.67744 628.08064 783.67744 316.146347zM684.885333 392.891733 684.885333 553.987413 312.576 553.987413 312.576 392.891733zM570.770773 770.39616 426.653013 770.39616 359.621973 628.08064 639.443627 628.08064z"></path>
</svg>

    </a>


<a href="https://ppd0705.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2019 -
    2022
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        PPD
        
      </span></span>

  
  
    <span id="busuanzi_container">
      访客数/访问量：<span id="busuanzi_value_site_uv"></span>/<span id="busuanzi_value_site_pv"></span>
    </span>
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>












</body>
</html>
